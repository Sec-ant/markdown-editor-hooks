diff --git a/dist/prosemirror-unified.cjs b/dist/prosemirror-unified.cjs
index 3327af8abcfeb0784ccbf219fbe4ca573b559a8c..be3ef79f8e50cbe7a98e9070df7aa05b84f85f00 100644
--- a/dist/prosemirror-unified.cjs
+++ b/dist/prosemirror-unified.cjs
@@ -1,522 +1,427 @@
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__ from "prosemirror-inputrules";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__ from "prosemirror-state";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__ from "prosemirror-commands";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_keymap_62566a86__ from "prosemirror-keymap";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_model_701384b1__ from "prosemirror-model";
-import * as __WEBPACK_EXTERNAL_MODULE_unified__ from "unified";
-/******/ // The require scope
-/******/ var __webpack_require__ = {};
-/******/ 
-/************************************************************************/
-/******/ /* webpack/runtime/define property getters */
-/******/ (() => {
-/******/ 	// define getter functions for harmony exports
-/******/ 	__webpack_require__.d = (exports, definition) => {
-/******/ 		for(var key in definition) {
-/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
-/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
-/******/ 			}
-/******/ 		}
-/******/ 	};
-/******/ })();
-/******/ 
-/******/ /* webpack/runtime/hasOwnProperty shorthand */
-/******/ (() => {
-/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
-/******/ })();
-/******/ 
-/******/ /* webpack/runtime/make namespace object */
-/******/ (() => {
-/******/ 	// define __esModule on exports
-/******/ 	__webpack_require__.r = (exports) => {
-/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
-/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
-/******/ 		}
-/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
-/******/ 	};
-/******/ })();
-/******/ 
-/************************************************************************/
-var __webpack_exports__ = {};
-// ESM COMPAT FLAG
-__webpack_require__.r(__webpack_exports__);
-
-// EXPORTS
-__webpack_require__.d(__webpack_exports__, {
-  Extension: () => (/* reexport */ Extension),
-  MarkExtension: () => (/* reexport */ MarkExtension),
-  MarkInputRule: () => (/* reexport */ MarkInputRule),
-  NodeExtension: () => (/* reexport */ NodeExtension),
-  ProseMirrorUnified: () => (/* reexport */ ProseMirrorUnified),
-  SyntaxExtension: () => (/* reexport */ SyntaxExtension),
-  createProseMirrorNode: () => (/* reexport */ createProseMirrorNode)
-});
-
-;// CONCATENATED MODULE: ./src/createProseMirrorNode.ts
-/**
- * @public
- */
+"use strict";
+Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
+const prosemirrorInputrules = require("prosemirror-inputrules");
+const prosemirrorState = require("prosemirror-state");
+const prosemirrorCommands = require("prosemirror-commands");
+const prosemirrorKeymap = require("prosemirror-keymap");
+const prosemirrorModel = require("prosemirror-model");
+const unified = require("unified");
 function createProseMirrorNode(nodeName, schema, children, attrs = {}) {
-    if (nodeName === null) {
-        return [];
-    }
-    const proseMirrorNode = schema.nodes[nodeName].createAndFill(attrs, children);
-    if (proseMirrorNode === null) {
-        return [];
-    }
-    return [proseMirrorNode];
+  if (nodeName === null) {
+    return [];
+  }
+  const proseMirrorNode = schema.nodes[nodeName].createAndFill(attrs, children);
+  if (proseMirrorNode === null) {
+    return [];
+  }
+  return [proseMirrorNode];
 }
-
-;// CONCATENATED MODULE: ./src/Extension.ts
-/**
- * @public
- */
 class Extension {
-    /* eslint-disable @typescript-eslint/class-methods-use-this -- Invalid for interfaces */
-    dependencies() {
-        return [];
-    }
-    unifiedInitializationHook(processor) {
-        return processor;
-    }
+  /* eslint-disable @typescript-eslint/class-methods-use-this -- Invalid for interfaces */
+  dependencies() {
+    return [];
+  }
+  unifiedInitializationHook(processor) {
+    return processor;
+  }
+  /* eslint-enable */
 }
-
-;// CONCATENATED MODULE: ./src/SyntaxExtension.ts
-
-/**
- * @public
- */
 class SyntaxExtension extends Extension {
-    /* eslint-disable @typescript-eslint/class-methods-use-this, @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars -- These are invalid for interfaces */
-    postUnistToProseMirrorHook(
-    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden
-    context) { }
-    proseMirrorInputRules(
-    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden
-    proseMirrorSchema) {
-        return [];
-    }
-    proseMirrorKeymap(
-    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden
-    proseMirrorSchema) {
-        return {};
-    }
-    unistToProseMirrorTest(node) {
-        return node.type === this.unistNodeName();
-    }
+  /* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/class-methods-use-this, @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars -- These are invalid for interfaces */
+  postUnistToProseMirrorHook(context) {
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {};
+  }
+  unistToProseMirrorTest(node) {
+    return node.type === this.unistNodeName();
+  }
 }
-
-;// CONCATENATED MODULE: ./src/MarkExtension.ts
-
-/**
- * @public
- */
 class MarkExtension extends SyntaxExtension {
 }
-
-;// CONCATENATED MODULE: external "prosemirror-inputrules"
-var x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var y = (x) => (() => (x))
-const external_prosemirror_inputrules_namespaceObject = x({ ["InputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.InputRule), ["inputRules"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.inputRules) });
-;// CONCATENATED MODULE: external "prosemirror-state"
-var external_prosemirror_state_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_state_y = (x) => (() => (x))
-const external_prosemirror_state_namespaceObject = external_prosemirror_state_x({ ["SelectionRange"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.SelectionRange), ["TextSelection"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.TextSelection) });
-;// CONCATENATED MODULE: ./src/MarkInputRule.ts
-
-
-/**
- * @public
- */
-class MarkInputRule extends external_prosemirror_inputrules_namespaceObject.InputRule {
-    constructor(matcher, markType) {
-        super(matcher, (state, match, start, end) => this.markHandler(state, match, start, end));
-        this.markType = markType;
-    }
-    static markApplies(doc, ranges, type) {
-        for (const range of ranges) {
-            const { $from, $to } = range;
-            let applies = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
-            doc.nodesBetween($from.pos, $to.pos, (node) => {
-                if (applies) {
-                    return false;
-                }
-                applies = node.inlineContent && node.type.allowsMarkType(type);
-                return true;
-            });
-            if (applies) {
-                return true;
-            }
+class MarkInputRule extends prosemirrorInputrules.InputRule {
+  constructor(matcher, markType) {
+    super(
+      matcher,
+      (state, match, start, end) => this.markHandler(state, match, start, end)
+    );
+    this.markType = markType;
+  }
+  static markApplies(doc, ranges, type) {
+    for (const range of ranges) {
+      const { $from, $to } = range;
+      let applies = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
+      doc.nodesBetween($from.pos, $to.pos, (node) => {
+        if (applies) {
+          return false;
         }
-        return false;
-    }
-    markHandler(state, match, start, end) {
-        var _a, _b;
-        if (!(state.selection instanceof external_prosemirror_state_namespaceObject.TextSelection)) {
-            return null;
-        }
-        // Determine if mark applies to match
-        const $start = state.doc.resolve(start);
-        const $end = state.doc.resolve(end);
-        const range = [new external_prosemirror_state_namespaceObject.SelectionRange($start, $end)];
-        if (!MarkInputRule.markApplies(state.doc, range, this.markType)) {
-            return null;
-        }
-        // List all existing marks and add the new one
-        const newMarks = (_b = (_a = state.doc.nodeAt(start)) === null || _a === void 0 ? void 0 : _a.marks.map((mark) => mark.type)) !== null && _b !== void 0 ? _b : [];
-        newMarks.push(this.markType);
-        // Replace the affected range with the matched text - this removes e.g. the asterisks around italic
-        const tr = state.tr.replaceWith(start, end, this.markType.schema.text(match[1]));
-        // Add back all marks, including the new one
-        for (const markType of newMarks) {
-            tr.addMark(tr.mapping.map(start), tr.mapping.map(end), markType.create(null));
-        }
-        // Make the text editor insert clean text with no marks on next input
-        for (const markType of newMarks) {
-            tr.removeStoredMark(markType);
-        }
-        // Add back the last character
-        return tr.insertText(match[2]);
-    }
+        applies = node.inlineContent && node.type.allowsMarkType(type);
+        return true;
+      });
+      if (applies) {
+        return true;
+      }
+    }
+    return false;
+  }
+  markHandler(state, match, start, end) {
+    var _a;
+    if (!(state.selection instanceof prosemirrorState.TextSelection)) {
+      return null;
+    }
+    const $start = state.doc.resolve(start);
+    const $end = state.doc.resolve(end);
+    const range = [new prosemirrorState.SelectionRange($start, $end)];
+    if (!MarkInputRule.markApplies(state.doc, range, this.markType)) {
+      return null;
+    }
+    const newMarks = ((_a = state.doc.nodeAt(start)) == null ? void 0 : _a.marks.map((mark) => mark.type)) ?? [];
+    newMarks.push(this.markType);
+    let inner = "";
+    let trailing = "";
+    if (match.groups) {
+      ({ i: inner, t: trailing } = match.groups);
+    } else {
+      ({ 1: inner, 2: trailing } = match);
+    }
+    const tr = state.tr.replaceWith(
+      start,
+      end,
+      this.markType.schema.text(inner)
+    );
+    for (const markType of newMarks) {
+      tr.addMark(
+        tr.mapping.map(start),
+        tr.mapping.map(end),
+        markType.create(null)
+      );
+    }
+    for (const markType of newMarks) {
+      tr.removeStoredMark(markType);
+    }
+    if (trailing !== "\n") {
+      tr.insertText(trailing);
+    }
+    return tr;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/NodeExtension.ts
-
-/**
- * @public
- */
 class NodeExtension extends SyntaxExtension {
-    // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inalid for an interface
-    proseMirrorNodeView() {
-        return null;
-    }
-    proseMirrorToUnistTest(node) {
-        return this.proseMirrorNodeName() === node.type.name;
-    }
+  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inalid for an interface
+  proseMirrorNodeView() {
+    return null;
+  }
+  proseMirrorToUnistTest(node) {
+    return this.proseMirrorNodeName() === node.type.name;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/ExtensionManager.ts
-
-
-function isNodeExtension(extension) {
-    return extension instanceof NodeExtension;
+class ExtensionManager {
+  constructor(extensions) {
+    this.markExtensionList = /* @__PURE__ */ new Map();
+    this.nodeExtensionList = /* @__PURE__ */ new Map();
+    this.otherExtensionList = /* @__PURE__ */ new Map();
+    for (const extension of extensions) {
+      this.add(extension);
+    }
+  }
+  extensions() {
+    return this.syntaxExtensions().concat(
+      Array.from(this.otherExtensionList.values())
+    );
+  }
+  markExtensions() {
+    return Array.from(this.markExtensionList.values());
+  }
+  nodeExtensions() {
+    return Array.from(this.nodeExtensionList.values());
+  }
+  syntaxExtensions() {
+    return this.nodeExtensions().concat(
+      this.markExtensions()
+    );
+  }
+  add(extension) {
+    for (const dependency of extension.dependencies()) {
+      this.add(dependency);
+    }
+    if (isMarkExtension(extension)) {
+      this.markExtensionList.set(extension.constructor.name, extension);
+      return;
+    }
+    if (isNodeExtension(extension)) {
+      this.nodeExtensionList.set(extension.constructor.name, extension);
+      return;
+    }
+    this.otherExtensionList.set(extension.constructor.name, extension);
+  }
 }
 function isMarkExtension(extension) {
-    return extension instanceof MarkExtension;
+  return extension instanceof MarkExtension;
 }
-class ExtensionManager {
-    constructor(extensions) {
-        this.markExtensionList = new Map();
-        this.nodeExtensionList = new Map();
-        this.otherExtensionList = new Map();
-        for (const extension of extensions) {
-            this.add(extension);
-        }
-    }
-    add(extension) {
-        for (const dependency of extension.dependencies()) {
-            this.add(dependency);
-        }
-        if (isMarkExtension(extension)) {
-            this.markExtensionList.set(extension.constructor.name, extension);
-            return;
-        }
-        if (isNodeExtension(extension)) {
-            this.nodeExtensionList.set(extension.constructor.name, extension);
-            return;
-        }
-        this.otherExtensionList.set(extension.constructor.name, extension);
-    }
-    extensions() {
-        return this.syntaxExtensions().concat(Array.from(this.otherExtensionList.values()));
-    }
-    markExtensions() {
-        return Array.from(this.markExtensionList.values());
-    }
-    nodeExtensions() {
-        return Array.from(this.nodeExtensionList.values());
-    }
-    syntaxExtensions() {
-        return this.nodeExtensions().concat(this.markExtensions());
-    }
+function isNodeExtension(extension) {
+  return extension instanceof NodeExtension;
 }
-
-;// CONCATENATED MODULE: ./src/InputRulesBuilder.ts
-
 class InputRulesBuilder {
-    constructor(extensionManager, proseMirrorSchema) {
-        this.rules = [].concat.apply([], extensionManager
-            .syntaxExtensions()
-            .map((extension) => extension.proseMirrorInputRules(proseMirrorSchema)));
-    }
-    build() {
-        return (0,external_prosemirror_inputrules_namespaceObject.inputRules)({ rules: this.rules });
-    }
+  constructor(extensionManager, proseMirrorSchema) {
+    this.rules = [].concat.apply(
+      [],
+      extensionManager.syntaxExtensions().map((extension) => extension.proseMirrorInputRules(proseMirrorSchema))
+    );
+  }
+  build() {
+    var _a;
+    const inputRulesPlugin = prosemirrorInputrules.inputRules({ rules: this.rules });
+    const originalHandleKeyDown = (_a = inputRulesPlugin.props.handleKeyDown) == null ? void 0 : _a.bind(inputRulesPlugin);
+    const customHandleKeyDown = (view, event) => {
+      var _a2;
+      if (event.key === "Enter") {
+        const { from, to } = view.state.selection;
+        (_a2 = inputRulesPlugin.props.handleTextInput) == null ? void 0 : _a2.call(
+          inputRulesPlugin,
+          view,
+          from,
+          to,
+          "\n"
+        );
+      }
+      return originalHandleKeyDown == null ? void 0 : originalHandleKeyDown(view, event);
+    };
+    inputRulesPlugin.props.handleKeyDown = customHandleKeyDown;
+    return inputRulesPlugin;
+  }
 }
-
-;// CONCATENATED MODULE: external "prosemirror-commands"
-var external_prosemirror_commands_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_commands_y = (x) => (() => (x))
-const external_prosemirror_commands_namespaceObject = external_prosemirror_commands_x({ ["baseKeymap"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.baseKeymap), ["chainCommands"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.chainCommands) });
-;// CONCATENATED MODULE: external "prosemirror-keymap"
-var external_prosemirror_keymap_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_keymap_y = (x) => (() => (x))
-const external_prosemirror_keymap_namespaceObject = external_prosemirror_keymap_x({ ["keymap"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_keymap_62566a86__.keymap) });
-;// CONCATENATED MODULE: ./src/KeymapBuilder.ts
-
-
 class KeymapBuilder {
-    constructor(extensionManager, proseMirrorSchema) {
-        this.keymap = new Map();
-        for (const extension of extensionManager.syntaxExtensions()) {
-            this.addKeymap(extension.proseMirrorKeymap(proseMirrorSchema));
-        }
-        this.addKeymap(external_prosemirror_commands_namespaceObject.baseKeymap);
-    }
-    addKeymap(map) {
-        for (const key in map) {
-            if (!Object.prototype.hasOwnProperty.call(map, key)) {
-                continue;
-            }
-            if (!this.keymap.get(key)) {
-                this.keymap.set(key, []);
-            }
-            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Set above.
-            this.keymap.get(key).push(map[key]);
-        }
-    }
-    build() {
-        const chainedKeymap = {};
-        this.keymap.forEach((commands, key) => {
-            chainedKeymap[key] = (0,external_prosemirror_commands_namespaceObject.chainCommands)(...commands);
-        });
-        return (0,external_prosemirror_keymap_namespaceObject.keymap)(chainedKeymap);
-    }
+  constructor(extensionManager, proseMirrorSchema) {
+    this.keymap = /* @__PURE__ */ new Map();
+    for (const extension of extensionManager.syntaxExtensions()) {
+      this.addKeymap(extension.proseMirrorKeymap(proseMirrorSchema));
+    }
+    this.addKeymap(prosemirrorCommands.baseKeymap);
+  }
+  build() {
+    const chainedKeymap = {};
+    this.keymap.forEach((commands, key) => {
+      chainedKeymap[key] = prosemirrorCommands.chainCommands(...commands);
+    });
+    return prosemirrorKeymap.keymap(chainedKeymap);
+  }
+  addKeymap(map) {
+    for (const key in map) {
+      if (!Object.prototype.hasOwnProperty.call(map, key)) {
+        continue;
+      }
+      if (!this.keymap.get(key)) {
+        this.keymap.set(key, []);
+      }
+      this.keymap.get(key).push(map[key]);
+    }
+  }
 }
-
-;// CONCATENATED MODULE: ./src/NodeViewBuilder.ts
 class NodeViewBuilder {
-    constructor(extensionManager) {
-        this.nodeViews = {};
-        for (const extension of extensionManager.nodeExtensions()) {
-            const proseMirrorNodeName = extension.proseMirrorNodeName();
-            const proseMirrorNodeView = extension.proseMirrorNodeView();
-            if (proseMirrorNodeName !== null && proseMirrorNodeView !== null) {
-                this.nodeViews[proseMirrorNodeName] = proseMirrorNodeView;
-            }
-        }
-    }
-    build() {
-        return this.nodeViews;
-    }
+  constructor(extensionManager) {
+    this.nodeViews = {};
+    for (const extension of extensionManager.nodeExtensions()) {
+      const proseMirrorNodeName = extension.proseMirrorNodeName();
+      const proseMirrorNodeView = extension.proseMirrorNodeView();
+      if (proseMirrorNodeName !== null && proseMirrorNodeView !== null) {
+        this.nodeViews[proseMirrorNodeName] = proseMirrorNodeView;
+      }
+    }
+  }
+  build() {
+    return this.nodeViews;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/ProseMirrorToUnistConverter.ts
 class ProseMirrorToUnistConverter {
-    constructor(extensionManager) {
-        this.extensionManager = extensionManager;
-    }
-    convertNode(node) {
-        let convertedNodes = null;
-        for (const extension of this.extensionManager.nodeExtensions()) {
-            if (!extension.proseMirrorToUnistTest(node)) {
-                continue;
-            }
-            let convertedChildren = [];
-            for (let i = 0; i < node.childCount; ++i) {
-                convertedChildren = convertedChildren.concat(this.convertNode(node.child(i)));
-            }
-            convertedNodes = extension.proseMirrorNodeToUnistNodes(node, convertedChildren);
+  constructor(extensionManager) {
+    this.extensionManager = extensionManager;
+  }
+  convert(node) {
+    const rootNode = this.convertNode(node);
+    if (rootNode.length !== 1) {
+      throw new Error(
+        "Couldn't find any way to convert the root ProseMirror node."
+      );
+    }
+    return rootNode[0];
+  }
+  convertNode(node) {
+    let convertedNodes = null;
+    for (const extension of this.extensionManager.nodeExtensions()) {
+      if (!extension.proseMirrorToUnistTest(node)) {
+        continue;
+      }
+      let convertedChildren = [];
+      for (let i = 0; i < node.childCount; ++i) {
+        convertedChildren = convertedChildren.concat(
+          this.convertNode(node.child(i))
+        );
+      }
+      convertedNodes = extension.proseMirrorNodeToUnistNodes(
+        node,
+        convertedChildren
+      );
+    }
+    if (convertedNodes === null) {
+      console.warn(
+        `Couldn't find any way to convert ProseMirror node of type "${node.type.name}" to a unist node.`
+      );
+      return [];
+    }
+    return convertedNodes.map((convertedNode) => {
+      let postProcessedNode = convertedNode;
+      for (const mark of node.marks) {
+        let processed = false;
+        for (const extension of this.extensionManager.markExtensions()) {
+          if (mark.type.name === extension.proseMirrorMarkName()) {
+            postProcessedNode = extension.processConvertedUnistNode(
+              postProcessedNode,
+              mark
+            );
+            processed = true;
+          }
         }
-        if (convertedNodes === null) {
-            // eslint-disable-next-line no-console -- Intended console warning
-            console.warn(`Couldn't find any way to convert ProseMirror node of type "${node.type.name}" to a unist node.`);
-            return [];
+        if (!processed) {
+          console.warn(
+            `Couldn't find any way to convert ProseMirror mark of type "${mark.type.name}" to a unist node.`
+          );
         }
-        return convertedNodes.map((convertedNode) => {
-            let postProcessedNode = convertedNode;
-            for (const mark of node.marks) {
-                let processed = false;
-                for (const extension of this.extensionManager.markExtensions()) {
-                    if (mark.type.name === extension.proseMirrorMarkName()) {
-                        postProcessedNode = extension.processConvertedUnistNode(postProcessedNode, mark);
-                        processed = true;
-                    }
-                }
-                if (!processed) {
-                    // eslint-disable-next-line no-console -- Intended console warning
-                    console.warn(`Couldn't find any way to convert ProseMirror mark of type "${mark.type.name}" to a unist node.`);
-                }
-            }
-            return postProcessedNode;
-        });
-    }
-    convert(node) {
-        const rootNode = this.convertNode(node);
-        if (rootNode.length !== 1) {
-            throw new Error("Couldn't find any way to convert the root ProseMirror node.");
-        }
-        return rootNode[0];
-    }
+      }
+      return postProcessedNode;
+    });
+  }
 }
-
-;// CONCATENATED MODULE: external "prosemirror-model"
-var external_prosemirror_model_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_model_y = (x) => (() => (x))
-const external_prosemirror_model_namespaceObject = external_prosemirror_model_x({ ["Schema"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_model_701384b1__.Schema) });
-;// CONCATENATED MODULE: ./src/SchemaBuilder.ts
-
 class SchemaBuilder {
-    constructor(extensionManager) {
-        this.marks = {};
-        this.nodes = {};
-        for (const extension of extensionManager.nodeExtensions()) {
-            const name = extension.proseMirrorNodeName();
-            const spec = extension.proseMirrorNodeSpec();
-            if (name !== null && spec !== null) {
-                this.nodes[name] = spec;
-            }
-        }
-        for (const extension of extensionManager.markExtensions()) {
-            const name = extension.proseMirrorMarkName();
-            const spec = extension.proseMirrorMarkSpec();
-            if (name !== null && spec !== null) {
-                this.marks[name] = spec;
-            }
-        }
-    }
-    build() {
-        return new external_prosemirror_model_namespaceObject.Schema({
-            marks: this.marks,
-            nodes: this.nodes,
-        });
-    }
+  constructor(extensionManager) {
+    this.marks = {};
+    this.nodes = {};
+    for (const extension of extensionManager.nodeExtensions()) {
+      const name = extension.proseMirrorNodeName();
+      const spec = extension.proseMirrorNodeSpec();
+      if (name !== null && spec !== null) {
+        this.nodes[name] = spec;
+      }
+    }
+    for (const extension of extensionManager.markExtensions()) {
+      const name = extension.proseMirrorMarkName();
+      const spec = extension.proseMirrorMarkSpec();
+      if (name !== null && spec !== null) {
+        this.marks[name] = spec;
+      }
+    }
+  }
+  build() {
+    return new prosemirrorModel.Schema({
+      marks: this.marks,
+      nodes: this.nodes
+    });
+  }
 }
-
-;// CONCATENATED MODULE: external "unified"
-var external_unified_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_unified_y = (x) => (() => (x))
-const external_unified_namespaceObject = external_unified_x({ ["unified"]: () => (__WEBPACK_EXTERNAL_MODULE_unified__.unified) });
-;// CONCATENATED MODULE: ./src/UnifiedBuilder.ts
-
 class UnifiedBuilder {
-    constructor(extensionManager) {
-        this.extensionManager = extensionManager;
-    }
-    build() {
-        let processor = (0,external_unified_namespaceObject.unified)();
-        for (const extension of this.extensionManager.extensions()) {
-            processor = extension.unifiedInitializationHook(processor);
-        }
-        return processor;
-    }
+  constructor(extensionManager) {
+    this.extensionManager = extensionManager;
+  }
+  build() {
+    let processor = unified.unified();
+    for (const extension of this.extensionManager.extensions()) {
+      processor = extension.unifiedInitializationHook(processor);
+    }
+    return processor;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/UnistToProseMirrorConverter.ts
 class UnistToProseMirrorConverter {
-    constructor(extensionManager, proseMirrorSchema) {
-        this.extensionManager = extensionManager;
-        this.proseMirrorSchema = proseMirrorSchema;
-    }
-    static unistNodeIsParent(node) {
-        return "children" in node;
-    }
-    convertNode(node, context) {
-        for (const extension of this.extensionManager.syntaxExtensions()) {
-            if (!extension.unistToProseMirrorTest(node)) {
-                continue;
-            }
-            let convertedChildren = [];
-            if (UnistToProseMirrorConverter.unistNodeIsParent(node)) {
-                convertedChildren = [].concat.apply([], node.children.map((child) => this.convertNode(child, context)));
-            }
-            return extension.unistNodeToProseMirrorNodes(node, this.proseMirrorSchema, convertedChildren, context);
-        }
-        // eslint-disable-next-line no-console -- Intended console warning
-        console.warn(`Couldn't find any way to convert unist node of type "${node.type}" to a ProseMirror node.`);
-        return [];
-    }
-    convert(unist) {
-        const context = {};
-        const rootNode = this.convertNode(unist, context);
-        for (const extension of this.extensionManager.syntaxExtensions()) {
-            extension.postUnistToProseMirrorHook(context);
-        }
-        if (rootNode.length !== 1) {
-            throw new Error("Couldn't find any way to convert the root unist node.");
-        }
-        return rootNode[0];
-    }
+  constructor(extensionManager, proseMirrorSchema) {
+    this.extensionManager = extensionManager;
+    this.proseMirrorSchema = proseMirrorSchema;
+  }
+  static unistNodeIsParent(node) {
+    return "children" in node;
+  }
+  convert(unist) {
+    const context = {};
+    const rootNode = this.convertNode(unist, context);
+    for (const extension of this.extensionManager.syntaxExtensions()) {
+      extension.postUnistToProseMirrorHook(context);
+    }
+    if (rootNode.length !== 1) {
+      throw new Error("Couldn't find any way to convert the root unist node.");
+    }
+    return rootNode[0];
+  }
+  convertNode(node, context) {
+    for (const extension of this.extensionManager.syntaxExtensions()) {
+      if (!extension.unistToProseMirrorTest(node)) {
+        continue;
+      }
+      let convertedChildren = [];
+      if (UnistToProseMirrorConverter.unistNodeIsParent(node)) {
+        convertedChildren = [].concat.apply(
+          [],
+          node.children.map((child) => this.convertNode(child, context))
+        );
+      }
+      return extension.unistNodeToProseMirrorNodes(
+        node,
+        this.proseMirrorSchema,
+        convertedChildren,
+        context
+      );
+    }
+    console.warn(
+      `Couldn't find any way to convert unist node of type "${node.type}" to a ProseMirror node.`
+    );
+    return [];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/ProseMirrorUnified.ts
-
-
-
-
-
-
-
-
-/**
- * @public
- */
 class ProseMirrorUnified {
-    constructor(extensions = []) {
-        const extensionManager = new ExtensionManager(extensions);
-        this.builtSchema = new SchemaBuilder(extensionManager).build();
-        this.inputRulesBuilder = new InputRulesBuilder(extensionManager, this.builtSchema);
-        this.keymapBuilder = new KeymapBuilder(extensionManager, this.builtSchema);
-        this.nodeViewBuilder = new NodeViewBuilder(extensionManager);
-        this.unistToProseMirrorConverter = new UnistToProseMirrorConverter(extensionManager, this.builtSchema);
-        this.proseMirrorToUnistConverter = new ProseMirrorToUnistConverter(extensionManager);
-        this.unified = new UnifiedBuilder(extensionManager).build();
-    }
-    inputRulesPlugin() {
-        return this.inputRulesBuilder.build();
-    }
-    keymapPlugin() {
-        return this.keymapBuilder.build();
-    }
-    nodeViews() {
-        return this.nodeViewBuilder.build();
-    }
-    parse(source) {
-        const unist = this.unified.runSync(this.unified.parse(source));
-        const ret = this.unistToProseMirrorConverter.convert(unist);
-        return ret;
-    }
-    schema() {
-        return this.builtSchema;
-    }
-    serialize(doc) {
-        const unist = this.proseMirrorToUnistConverter.convert(doc);
-        const source = this.unified.stringify(unist);
-        return source;
-    }
+  constructor(extensions = []) {
+    const extensionManager = new ExtensionManager(extensions);
+    this.builtSchema = new SchemaBuilder(extensionManager).build();
+    this.inputRulesBuilder = new InputRulesBuilder(
+      extensionManager,
+      this.builtSchema
+    );
+    this.keymapBuilder = new KeymapBuilder(extensionManager, this.builtSchema);
+    this.nodeViewBuilder = new NodeViewBuilder(extensionManager);
+    this.unistToProseMirrorConverter = new UnistToProseMirrorConverter(
+      extensionManager,
+      this.builtSchema
+    );
+    this.proseMirrorToUnistConverter = new ProseMirrorToUnistConverter(
+      extensionManager
+    );
+    this.unified = new UnifiedBuilder(extensionManager).build();
+  }
+  inputRulesPlugin() {
+    return this.inputRulesBuilder.build();
+  }
+  keymapPlugin() {
+    return this.keymapBuilder.build();
+  }
+  nodeViews() {
+    return this.nodeViewBuilder.build();
+  }
+  parse(source) {
+    const unist = this.unified.runSync(this.unified.parse(source));
+    const ret = this.unistToProseMirrorConverter.convert(unist);
+    return ret;
+  }
+  schema() {
+    return this.builtSchema;
+  }
+  serialize(doc) {
+    const unist = this.proseMirrorToUnistConverter.convert(doc);
+    const source = this.unified.stringify(unist);
+    return source;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/index.ts
-
-
-
-
-
-
-
-
-module.exports = __webpack_exports__;
-
+exports.Extension = Extension;
+exports.MarkExtension = MarkExtension;
+exports.MarkInputRule = MarkInputRule;
+exports.NodeExtension = NodeExtension;
+exports.ProseMirrorUnified = ProseMirrorUnified;
+exports.SyntaxExtension = SyntaxExtension;
+exports.createProseMirrorNode = createProseMirrorNode;
 //# sourceMappingURL=prosemirror-unified.cjs.map
diff --git a/dist/prosemirror-unified.cjs.map b/dist/prosemirror-unified.cjs.map
index 893b47844fdb12bd9935584f125598695ed27fd1..616dede6f045a0f36621b6350dae41e91092743c 100644
--- a/dist/prosemirror-unified.cjs.map
+++ b/dist/prosemirror-unified.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"prosemirror-unified.cjs","mappings":"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","sources":["webpack://prosemirror-unified/webpack/bootstrap","webpack://prosemirror-unified/webpack/runtime/define property getters","webpack://prosemirror-unified/webpack/runtime/hasOwnProperty shorthand","webpack://prosemirror-unified/webpack/runtime/make namespace object","webpack://prosemirror-unified/./src/createProseMirrorNode.ts","webpack://prosemirror-unified/./src/Extension.ts","webpack://prosemirror-unified/./src/SyntaxExtension.ts","webpack://prosemirror-unified/./src/MarkExtension.ts","webpack://prosemirror-unified/external module \"prosemirror-inputrules\"","webpack://prosemirror-unified/external module \"prosemirror-state\"","webpack://prosemirror-unified/./src/MarkInputRule.ts","webpack://prosemirror-unified/./src/NodeExtension.ts","webpack://prosemirror-unified/./src/ExtensionManager.ts","webpack://prosemirror-unified/./src/InputRulesBuilder.ts","webpack://prosemirror-unified/external module \"prosemirror-commands\"","webpack://prosemirror-unified/external module \"prosemirror-keymap\"","webpack://prosemirror-unified/./src/KeymapBuilder.ts","webpack://prosemirror-unified/./src/NodeViewBuilder.ts","webpack://prosemirror-unified/./src/ProseMirrorToUnistConverter.ts","webpack://prosemirror-unified/external module \"prosemirror-model\"","webpack://prosemirror-unified/./src/SchemaBuilder.ts","webpack://prosemirror-unified/external module \"unified\"","webpack://prosemirror-unified/./src/UnifiedBuilder.ts","webpack://prosemirror-unified/./src/UnistToProseMirrorConverter.ts","webpack://prosemirror-unified/./src/ProseMirrorUnified.ts","webpack://prosemirror-unified/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { Attrs, Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\n/**\n * @public\n */\nexport function createProseMirrorNode(\n  nodeName: string | null,\n  schema: Schema<string, string>,\n  children: Array<ProseMirrorNode>,\n  attrs: Attrs = {},\n): Array<ProseMirrorNode> {\n  if (nodeName === null) {\n    return [];\n  }\n  const proseMirrorNode = schema.nodes[nodeName].createAndFill(attrs, children);\n  if (proseMirrorNode === null) {\n    return [];\n  }\n  return [proseMirrorNode];\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\n/**\n * @public\n */\nexport abstract class Extension {\n  /* eslint-disable @typescript-eslint/class-methods-use-this -- Invalid for interfaces */\n  public dependencies(): Array<Extension> {\n    return [];\n  }\n\n  public unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor;\n  }\n  /* eslint-enable */\n}\n","import type { InputRule } from \"prosemirror-inputrules\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { Extension } from \"./Extension\";\n\n/**\n * @public\n */\nexport abstract class SyntaxExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends Extension {\n  /* eslint-disable @typescript-eslint/class-methods-use-this, @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars -- These are invalid for interfaces */\n  public postUnistToProseMirrorHook(\n    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    context: Partial<UnistToProseMirrorContext>,\n  ): void {}\n\n  public proseMirrorInputRules(\n    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [];\n  }\n\n  public proseMirrorKeymap(\n    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {};\n  }\n  /* eslint-enable */\n\n  public abstract unistNodeName(): UNode[\"type\"];\n\n  public abstract unistNodeToProseMirrorNodes(\n    node: UNode,\n    schema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<UnistToProseMirrorContext>,\n  ): Array<ProseMirrorNode>;\n\n  public unistToProseMirrorTest(node: UnistNode): boolean {\n    return node.type === this.unistNodeName();\n  }\n}\n","import type { Mark, MarkSpec } from \"prosemirror-model\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { SyntaxExtension } from \"./SyntaxExtension\";\n\n/**\n * @public\n */\nexport abstract class MarkExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends SyntaxExtension<UNode, UnistToProseMirrorContext> {\n  public abstract processConvertedUnistNode(\n    convertedNode: UnistNode,\n    originalMark: Mark,\n  ): UNode;\n\n  public abstract proseMirrorMarkName(): string | null;\n\n  public abstract proseMirrorMarkSpec(): MarkSpec | null;\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"InputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.InputRule), [\"inputRules\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.inputRules) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"SelectionRange\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.SelectionRange), [\"TextSelection\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.TextSelection) });","import type { MarkType, Node as ProseMirrorNode } from \"prosemirror-model\";\n\nimport { InputRule } from \"prosemirror-inputrules\";\nimport {\n  type EditorState,\n  SelectionRange,\n  TextSelection,\n  type Transaction,\n} from \"prosemirror-state\";\n\n/**\n * @public\n */\nexport class MarkInputRule extends InputRule {\n  private readonly markType: MarkType;\n\n  public constructor(matcher: RegExp, markType: MarkType) {\n    super(matcher, (state, match, start, end) =>\n      this.markHandler(state, match, start, end),\n    );\n    this.markType = markType;\n  }\n\n  private static markApplies(\n    doc: ProseMirrorNode,\n    ranges: Array<SelectionRange>,\n    type: MarkType,\n  ): boolean {\n    for (const range of ranges) {\n      const { $from, $to } = range;\n      let applies = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n      doc.nodesBetween($from.pos, $to.pos, (node) => {\n        if (applies) {\n          return false;\n        }\n        applies = node.inlineContent && node.type.allowsMarkType(type);\n        return true;\n      });\n      if (applies) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private markHandler(\n    state: EditorState,\n    match: RegExpMatchArray,\n    start: number,\n    end: number,\n  ): Transaction | null {\n    if (!(state.selection instanceof TextSelection)) {\n      return null;\n    }\n\n    // Determine if mark applies to match\n    const $start = state.doc.resolve(start);\n    const $end = state.doc.resolve(end);\n    const range = [new SelectionRange($start, $end)];\n\n    if (!MarkInputRule.markApplies(state.doc, range, this.markType)) {\n      return null;\n    }\n\n    // List all existing marks and add the new one\n    const newMarks =\n      state.doc.nodeAt(start)?.marks.map((mark) => mark.type) ?? [];\n    newMarks.push(this.markType);\n\n    // Replace the affected range with the matched text - this removes e.g. the asterisks around italic\n    const tr = state.tr.replaceWith(\n      start,\n      end,\n      this.markType.schema.text(match[1]),\n    );\n\n    // Add back all marks, including the new one\n    for (const markType of newMarks) {\n      tr.addMark(\n        tr.mapping.map(start),\n        tr.mapping.map(end),\n        markType.create(null),\n      );\n    }\n\n    // Make the text editor insert clean text with no marks on next input\n    for (const markType of newMarks) {\n      tr.removeStoredMark(markType);\n    }\n\n    // Add back the last character\n    return tr.insertText(match[2]);\n  }\n}\n","import type { NodeSpec, Node as ProseMirrorNode } from \"prosemirror-model\";\nimport type { NodeViewConstructor } from \"prosemirror-view\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { SyntaxExtension } from \"./SyntaxExtension\";\n\n/**\n * @public\n */\nexport abstract class NodeExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends SyntaxExtension<UNode, UnistToProseMirrorContext> {\n  public abstract proseMirrorNodeName(): string | null;\n\n  public abstract proseMirrorNodeSpec(): NodeSpec | null;\n\n  public abstract proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<UnistNode>,\n  ): Array<UNode>;\n\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inalid for an interface\n  public proseMirrorNodeView(): NodeViewConstructor | null {\n    return null;\n  }\n\n  public proseMirrorToUnistTest(node: ProseMirrorNode): boolean {\n    return this.proseMirrorNodeName() === node.type.name;\n  }\n}\n","import type { Node as UnistNode } from \"unist\";\n\nimport type { Extension } from \"./Extension\";\nimport type { SyntaxExtension } from \"./SyntaxExtension\";\n\nimport { MarkExtension } from \"./MarkExtension\";\nimport { NodeExtension } from \"./NodeExtension\";\n\nfunction isNodeExtension(\n  extension: Extension,\n): extension is NodeExtension<UnistNode> {\n  return extension instanceof NodeExtension;\n}\n\nfunction isMarkExtension(\n  extension: Extension,\n): extension is MarkExtension<UnistNode> {\n  return extension instanceof MarkExtension;\n}\n\nexport class ExtensionManager {\n  private readonly markExtensionList: Map<string, MarkExtension<UnistNode>>;\n  private readonly nodeExtensionList: Map<string, NodeExtension<UnistNode>>;\n  private readonly otherExtensionList: Map<string, Extension>;\n\n  public constructor(extensions: Array<Extension>) {\n    this.markExtensionList = new Map();\n    this.nodeExtensionList = new Map();\n    this.otherExtensionList = new Map();\n\n    for (const extension of extensions) {\n      this.add(extension);\n    }\n  }\n\n  private add(extension: Extension): void {\n    for (const dependency of extension.dependencies()) {\n      this.add(dependency);\n    }\n\n    if (isMarkExtension(extension)) {\n      this.markExtensionList.set(extension.constructor.name, extension);\n      return;\n    }\n    if (isNodeExtension(extension)) {\n      this.nodeExtensionList.set(extension.constructor.name, extension);\n      return;\n    }\n    this.otherExtensionList.set(extension.constructor.name, extension);\n  }\n\n  public extensions(): Array<Extension> {\n    return (this.syntaxExtensions() as Array<Extension>).concat(\n      Array.from(this.otherExtensionList.values()),\n    );\n  }\n\n  public markExtensions(): Array<MarkExtension<UnistNode>> {\n    return Array.from(this.markExtensionList.values());\n  }\n\n  public nodeExtensions(): Array<NodeExtension<UnistNode>> {\n    return Array.from(this.nodeExtensionList.values());\n  }\n\n  public syntaxExtensions(): Array<SyntaxExtension<UnistNode>> {\n    return (this.nodeExtensions() as Array<SyntaxExtension<UnistNode>>).concat(\n      this.markExtensions(),\n    );\n  }\n}\n","import type { Schema } from \"prosemirror-model\";\nimport type { Plugin } from \"prosemirror-state\";\n\nimport { type InputRule, inputRules } from \"prosemirror-inputrules\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class InputRulesBuilder {\n  private readonly rules: Array<InputRule>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.rules = ([] as Array<InputRule>).concat.apply(\n      [],\n      extensionManager\n        .syntaxExtensions()\n        .map((extension) => extension.proseMirrorInputRules(proseMirrorSchema)),\n    );\n  }\n\n  public build(): Plugin {\n    return inputRules({ rules: this.rules });\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"baseKeymap\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.baseKeymap), [\"chainCommands\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.chainCommands) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"keymap\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_keymap_62566a86__.keymap) });","import type { Schema } from \"prosemirror-model\";\nimport type { Command, Plugin } from \"prosemirror-state\";\n\nimport { baseKeymap, chainCommands } from \"prosemirror-commands\";\nimport { keymap } from \"prosemirror-keymap\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class KeymapBuilder {\n  private readonly keymap: Map<string, Array<Command>>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.keymap = new Map();\n    for (const extension of extensionManager.syntaxExtensions()) {\n      this.addKeymap(extension.proseMirrorKeymap(proseMirrorSchema));\n    }\n    this.addKeymap(baseKeymap);\n  }\n\n  private addKeymap(map: Record<string, Command>): void {\n    for (const key in map) {\n      if (!Object.prototype.hasOwnProperty.call(map, key)) {\n        continue;\n      }\n      if (!this.keymap.get(key)) {\n        this.keymap.set(key, []);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Set above.\n      this.keymap.get(key)!.push(map[key]);\n    }\n  }\n\n  public build(): Plugin {\n    const chainedKeymap: Record<string, Command> = {};\n    this.keymap.forEach((commands, key) => {\n      chainedKeymap[key] = chainCommands(...commands);\n    });\n    return keymap(chainedKeymap);\n  }\n}\n","import type { NodeViewConstructor } from \"prosemirror-view\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class NodeViewBuilder {\n  private readonly nodeViews: Record<string, NodeViewConstructor>;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.nodeViews = {};\n    for (const extension of extensionManager.nodeExtensions()) {\n      const proseMirrorNodeName = extension.proseMirrorNodeName();\n      const proseMirrorNodeView = extension.proseMirrorNodeView();\n      if (proseMirrorNodeName !== null && proseMirrorNodeView !== null) {\n        this.nodeViews[proseMirrorNodeName] = proseMirrorNodeView;\n      }\n    }\n  }\n\n  public build(): Record<string, NodeViewConstructor> {\n    return this.nodeViews;\n  }\n}\n","import type { Node as ProseMirrorNode } from \"prosemirror-model\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class ProseMirrorToUnistConverter {\n  private readonly extensionManager: ExtensionManager;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.extensionManager = extensionManager;\n  }\n\n  private convertNode(node: ProseMirrorNode): Array<UnistNode> {\n    let convertedNodes: Array<UnistNode> | null = null;\n    for (const extension of this.extensionManager.nodeExtensions()) {\n      if (!extension.proseMirrorToUnistTest(node)) {\n        continue;\n      }\n      let convertedChildren: Array<UnistNode> = [];\n      for (let i = 0; i < node.childCount; ++i) {\n        convertedChildren = convertedChildren.concat(\n          this.convertNode(node.child(i)),\n        );\n      }\n      convertedNodes = extension.proseMirrorNodeToUnistNodes(\n        node,\n        convertedChildren,\n      );\n    }\n    if (convertedNodes === null) {\n      // eslint-disable-next-line no-console -- Intended console warning\n      console.warn(\n        `Couldn't find any way to convert ProseMirror node of type \"${node.type.name}\" to a unist node.`,\n      );\n      return [];\n    }\n    return convertedNodes.map((convertedNode) => {\n      let postProcessedNode = convertedNode;\n      for (const mark of node.marks) {\n        let processed = false;\n        for (const extension of this.extensionManager.markExtensions()) {\n          if (mark.type.name === extension.proseMirrorMarkName()) {\n            postProcessedNode = extension.processConvertedUnistNode(\n              postProcessedNode,\n              mark,\n            );\n            processed = true;\n          }\n        }\n        if (!processed) {\n          // eslint-disable-next-line no-console -- Intended console warning\n          console.warn(\n            `Couldn't find any way to convert ProseMirror mark of type \"${mark.type.name}\" to a unist node.`,\n          );\n        }\n      }\n      return postProcessedNode;\n    });\n  }\n\n  public convert(node: ProseMirrorNode): UnistNode {\n    const rootNode = this.convertNode(node);\n    if (rootNode.length !== 1) {\n      throw new Error(\n        \"Couldn't find any way to convert the root ProseMirror node.\",\n      );\n    }\n    return rootNode[0];\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"Schema\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_model_701384b1__.Schema) });","import { type MarkSpec, type NodeSpec, Schema } from \"prosemirror-model\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class SchemaBuilder {\n  private readonly marks: Record<string, MarkSpec> = {};\n  private readonly nodes: Record<string, NodeSpec> = {};\n\n  public constructor(extensionManager: ExtensionManager) {\n    for (const extension of extensionManager.nodeExtensions()) {\n      const name = extension.proseMirrorNodeName();\n      const spec = extension.proseMirrorNodeSpec();\n      if (name !== null && spec !== null) {\n        this.nodes[name] = spec;\n      }\n    }\n    for (const extension of extensionManager.markExtensions()) {\n      const name = extension.proseMirrorMarkName();\n      const spec = extension.proseMirrorMarkSpec();\n      if (name !== null && spec !== null) {\n        this.marks[name] = spec;\n      }\n    }\n  }\n\n  public build(): Schema<string, string> {\n    return new Schema<string, string>({\n      marks: this.marks,\n      nodes: this.nodes,\n    });\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"unified\"]: () => (__WEBPACK_EXTERNAL_MODULE_unified__.unified) });","import type { Node as UnistNode } from \"unist\";\n\nimport { type Processor, unified } from \"unified\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class UnifiedBuilder {\n  private readonly extensionManager: ExtensionManager;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.extensionManager = extensionManager;\n  }\n\n  public build(): Processor<\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    string\n  > {\n    let processor = unified() as unknown as Processor<\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      string\n    >;\n    for (const extension of this.extensionManager.extensions()) {\n      processor = extension.unifiedInitializationHook(processor);\n    }\n    return processor;\n  }\n}\n","import type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Parent, Node as UnistNode } from \"unist\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class UnistToProseMirrorConverter {\n  private readonly extensionManager: ExtensionManager;\n  private readonly proseMirrorSchema: Schema<string, string>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.extensionManager = extensionManager;\n    this.proseMirrorSchema = proseMirrorSchema;\n  }\n\n  private static unistNodeIsParent(node: UnistNode): node is Parent {\n    return \"children\" in node;\n  }\n\n  private convertNode(\n    node: UnistNode,\n    context: Partial<unknown>,\n  ): Array<ProseMirrorNode> {\n    for (const extension of this.extensionManager.syntaxExtensions()) {\n      if (!extension.unistToProseMirrorTest(node)) {\n        continue;\n      }\n      let convertedChildren: Array<ProseMirrorNode> = [];\n      if (UnistToProseMirrorConverter.unistNodeIsParent(node)) {\n        convertedChildren = ([] as Array<ProseMirrorNode>).concat.apply(\n          [],\n          node.children.map((child) => this.convertNode(child, context)),\n        );\n      }\n      return extension.unistNodeToProseMirrorNodes(\n        node,\n        this.proseMirrorSchema,\n        convertedChildren,\n        context,\n      );\n    }\n    // eslint-disable-next-line no-console -- Intended console warning\n    console.warn(\n      `Couldn't find any way to convert unist node of type \"${node.type}\" to a ProseMirror node.`,\n    );\n    return [];\n  }\n\n  public convert(unist: UnistNode): ProseMirrorNode {\n    const context: Partial<unknown> = {};\n    const rootNode = this.convertNode(unist, context);\n    for (const extension of this.extensionManager.syntaxExtensions()) {\n      extension.postUnistToProseMirrorHook(context);\n    }\n    if (rootNode.length !== 1) {\n      throw new Error(\"Couldn't find any way to convert the root unist node.\");\n    }\n    return rootNode[0];\n  }\n}\n","import type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Plugin } from \"prosemirror-state\";\nimport type { NodeViewConstructor } from \"prosemirror-view\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport type { Extension } from \"./Extension\";\n\nimport { ExtensionManager } from \"./ExtensionManager\";\nimport { InputRulesBuilder } from \"./InputRulesBuilder\";\nimport { KeymapBuilder } from \"./KeymapBuilder\";\nimport { NodeViewBuilder } from \"./NodeViewBuilder\";\nimport { ProseMirrorToUnistConverter } from \"./ProseMirrorToUnistConverter\";\nimport { SchemaBuilder } from \"./SchemaBuilder\";\nimport { UnifiedBuilder } from \"./UnifiedBuilder\";\nimport { UnistToProseMirrorConverter } from \"./UnistToProseMirrorConverter\";\n\n/**\n * @public\n */\nexport class ProseMirrorUnified {\n  private readonly builtSchema: Schema<string, string>;\n  private readonly inputRulesBuilder: InputRulesBuilder;\n  private readonly keymapBuilder: KeymapBuilder;\n  private readonly nodeViewBuilder: NodeViewBuilder;\n  private readonly proseMirrorToUnistConverter: ProseMirrorToUnistConverter;\n  private readonly unified: Processor<\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    string\n  >;\n  private readonly unistToProseMirrorConverter: UnistToProseMirrorConverter;\n\n  public constructor(extensions: Array<Extension> = []) {\n    const extensionManager = new ExtensionManager(extensions);\n    this.builtSchema = new SchemaBuilder(extensionManager).build();\n    this.inputRulesBuilder = new InputRulesBuilder(\n      extensionManager,\n      this.builtSchema,\n    );\n    this.keymapBuilder = new KeymapBuilder(extensionManager, this.builtSchema);\n    this.nodeViewBuilder = new NodeViewBuilder(extensionManager);\n    this.unistToProseMirrorConverter = new UnistToProseMirrorConverter(\n      extensionManager,\n      this.builtSchema,\n    );\n    this.proseMirrorToUnistConverter = new ProseMirrorToUnistConverter(\n      extensionManager,\n    );\n    this.unified = new UnifiedBuilder(extensionManager).build();\n  }\n\n  public inputRulesPlugin(): Plugin {\n    return this.inputRulesBuilder.build();\n  }\n\n  public keymapPlugin(): Plugin {\n    return this.keymapBuilder.build();\n  }\n\n  public nodeViews(): Record<string, NodeViewConstructor> {\n    return this.nodeViewBuilder.build();\n  }\n\n  public parse(source: string): ProseMirrorNode {\n    const unist = this.unified.runSync(this.unified.parse(source));\n    const ret = this.unistToProseMirrorConverter.convert(unist);\n    return ret;\n  }\n\n  public schema(): Schema<string, string> {\n    return this.builtSchema;\n  }\n\n  public serialize(doc: ProseMirrorNode): string {\n    const unist = this.proseMirrorToUnistConverter.convert(doc);\n    const source: string = this.unified.stringify(unist);\n    return source;\n  }\n}\n","export { createProseMirrorNode } from \"./createProseMirrorNode\";\nexport { Extension } from \"./Extension\";\nexport { MarkExtension } from \"./MarkExtension\";\nexport { MarkInputRule } from \"./MarkInputRule\";\nexport { NodeExtension } from \"./NodeExtension\";\nexport { ProseMirrorUnified } from \"./ProseMirrorUnified\";\nexport { SyntaxExtension } from \"./SyntaxExtension\";\n"],"names":[],"sourceRoot":""}
\ No newline at end of file
+{"version":3,"file":"prosemirror-unified.cjs","sources":["../src/createProseMirrorNode.ts","../src/Extension.ts","../src/SyntaxExtension.ts","../src/MarkExtension.ts","../src/MarkInputRule.ts","../src/NodeExtension.ts","../src/ExtensionManager.ts","../src/InputRulesBuilder.ts","../src/KeymapBuilder.ts","../src/NodeViewBuilder.ts","../src/ProseMirrorToUnistConverter.ts","../src/SchemaBuilder.ts","../src/UnifiedBuilder.ts","../src/UnistToProseMirrorConverter.ts","../src/ProseMirrorUnified.ts"],"sourcesContent":["import type { Attrs, Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\n/**\n * @public\n */\nexport function createProseMirrorNode(\n  nodeName: string | null,\n  schema: Schema<string, string>,\n  children: Array<ProseMirrorNode>,\n  attrs: Attrs = {},\n): Array<ProseMirrorNode> {\n  if (nodeName === null) {\n    return [];\n  }\n  const proseMirrorNode = schema.nodes[nodeName].createAndFill(attrs, children);\n  if (proseMirrorNode === null) {\n    return [];\n  }\n  return [proseMirrorNode];\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\n/**\n * @public\n */\nexport abstract class Extension {\n  /* eslint-disable @typescript-eslint/class-methods-use-this -- Invalid for interfaces */\n  public dependencies(): Array<Extension> {\n    return [];\n  }\n\n  public unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor;\n  }\n  /* eslint-enable */\n}\n","import type { InputRule } from \"prosemirror-inputrules\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { Extension } from \"./Extension\";\n\n/**\n * @public\n */\nexport abstract class SyntaxExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends Extension {\n  /* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/class-methods-use-this, @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars -- These are invalid for interfaces */\n  public postUnistToProseMirrorHook(\n    // @ts-ignore-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    context: Partial<UnistToProseMirrorContext>,\n  ): void {}\n\n  public proseMirrorInputRules(\n    // @ts-ignore-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [];\n  }\n\n  public proseMirrorKeymap(\n    // @ts-ignore-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {};\n  }\n  /* eslint-enable */\n\n  public abstract unistNodeName(): UNode[\"type\"];\n\n  public abstract unistNodeToProseMirrorNodes(\n    node: UNode,\n    schema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<UnistToProseMirrorContext>,\n  ): Array<ProseMirrorNode>;\n\n  public unistToProseMirrorTest(node: UnistNode): boolean {\n    return node.type === this.unistNodeName();\n  }\n}\n","import type { Mark, MarkSpec } from \"prosemirror-model\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { SyntaxExtension } from \"./SyntaxExtension\";\n\n/**\n * @public\n */\nexport abstract class MarkExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends SyntaxExtension<UNode, UnistToProseMirrorContext> {\n  public abstract processConvertedUnistNode(\n    convertedNode: UnistNode,\n    originalMark: Mark,\n  ): UNode;\n\n  public abstract proseMirrorMarkName(): string | null;\n\n  public abstract proseMirrorMarkSpec(): MarkSpec | null;\n}\n","import type { MarkType, Node as ProseMirrorNode } from \"prosemirror-model\";\n\nimport { InputRule } from \"prosemirror-inputrules\";\nimport {\n  type EditorState,\n  SelectionRange,\n  TextSelection,\n  type Transaction,\n} from \"prosemirror-state\";\n\n/**\n * @public\n */\nexport class MarkInputRule extends InputRule {\n  private readonly markType: MarkType;\n\n  public constructor(matcher: RegExp, markType: MarkType) {\n    super(matcher, (state, match, start, end) =>\n      this.markHandler(state, match, start, end),\n    );\n    this.markType = markType;\n  }\n\n  private static markApplies(\n    doc: ProseMirrorNode,\n    ranges: Array<SelectionRange>,\n    type: MarkType,\n  ): boolean {\n    for (const range of ranges) {\n      const { $from, $to } = range;\n      let applies = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n      doc.nodesBetween($from.pos, $to.pos, (node) => {\n        if (applies) {\n          return false;\n        }\n        applies = node.inlineContent && node.type.allowsMarkType(type);\n        return true;\n      });\n      if (applies) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private markHandler(\n    state: EditorState,\n    match: RegExpMatchArray,\n    start: number,\n    end: number,\n  ): Transaction | null {\n    if (!(state.selection instanceof TextSelection)) {\n      return null;\n    }\n\n    // Determine if mark applies to match\n    const $start = state.doc.resolve(start);\n    const $end = state.doc.resolve(end);\n    const range = [new SelectionRange($start, $end)];\n\n    if (!MarkInputRule.markApplies(state.doc, range, this.markType)) {\n      return null;\n    }\n\n    // List all existing marks and add the new one\n    const newMarks =\n      state.doc.nodeAt(start)?.marks.map((mark) => mark.type) ?? [];\n    newMarks.push(this.markType);\n\n    // Extract the inner content and the trailing part from the match result;\n    let inner = \"\";\n    let trailing = \"\";\n\n    if (match.groups) {\n      ({ i: inner, t: trailing } = match.groups);\n    } else {\n      ({ 1: inner, 2: trailing } = match);\n    }\n\n    // Replace the affected range with the matched text - this removes e.g. the asterisks around italic\n    const tr = state.tr.replaceWith(\n      start,\n      end,\n      this.markType.schema.text(inner),\n    );\n\n    // Add back all marks, including the new one\n    for (const markType of newMarks) {\n      tr.addMark(\n        tr.mapping.map(start),\n        tr.mapping.map(end),\n        markType.create(null),\n      );\n    }\n\n    // Make the text editor insert clean text with no marks on next input\n    for (const markType of newMarks) {\n      tr.removeStoredMark(markType);\n    }\n\n    // Add back the last character if it is not a newline,\n    // otherwise omit it because newline is handled out of the text node.\n    if (trailing !== \"\\n\") {\n      tr.insertText(trailing);\n    }\n\n    return tr;\n  }\n}\n","import type { NodeSpec, Node as ProseMirrorNode } from \"prosemirror-model\";\nimport type { NodeViewConstructor } from \"prosemirror-view\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { SyntaxExtension } from \"./SyntaxExtension\";\n\n/**\n * @public\n */\nexport abstract class NodeExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends SyntaxExtension<UNode, UnistToProseMirrorContext> {\n  public abstract proseMirrorNodeName(): string | null;\n\n  public abstract proseMirrorNodeSpec(): NodeSpec | null;\n\n  public abstract proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<UnistNode>,\n  ): Array<UNode>;\n\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inalid for an interface\n  public proseMirrorNodeView(): NodeViewConstructor | null {\n    return null;\n  }\n\n  public proseMirrorToUnistTest(node: ProseMirrorNode): boolean {\n    return this.proseMirrorNodeName() === node.type.name;\n  }\n}\n","import type { Node as UnistNode } from \"unist\";\n\nimport type { Extension } from \"./Extension\";\nimport type { SyntaxExtension } from \"./SyntaxExtension\";\n\nimport { MarkExtension } from \"./MarkExtension\";\nimport { NodeExtension } from \"./NodeExtension\";\n\nexport class ExtensionManager {\n  private readonly markExtensionList: Map<string, MarkExtension<UnistNode>>;\n  private readonly nodeExtensionList: Map<string, NodeExtension<UnistNode>>;\n  private readonly otherExtensionList: Map<string, Extension>;\n\n  public constructor(extensions: Array<Extension>) {\n    this.markExtensionList = new Map();\n    this.nodeExtensionList = new Map();\n    this.otherExtensionList = new Map();\n\n    for (const extension of extensions) {\n      this.add(extension);\n    }\n  }\n\n  public extensions(): Array<Extension> {\n    return (this.syntaxExtensions() as Array<Extension>).concat(\n      Array.from(this.otherExtensionList.values()),\n    );\n  }\n\n  public markExtensions(): Array<MarkExtension<UnistNode>> {\n    return Array.from(this.markExtensionList.values());\n  }\n\n  public nodeExtensions(): Array<NodeExtension<UnistNode>> {\n    return Array.from(this.nodeExtensionList.values());\n  }\n\n  public syntaxExtensions(): Array<SyntaxExtension<UnistNode>> {\n    return (this.nodeExtensions() as Array<SyntaxExtension<UnistNode>>).concat(\n      this.markExtensions(),\n    );\n  }\n\n  private add(extension: Extension): void {\n    for (const dependency of extension.dependencies()) {\n      this.add(dependency);\n    }\n\n    if (isMarkExtension(extension)) {\n      this.markExtensionList.set(extension.constructor.name, extension);\n      return;\n    }\n    if (isNodeExtension(extension)) {\n      this.nodeExtensionList.set(extension.constructor.name, extension);\n      return;\n    }\n    this.otherExtensionList.set(extension.constructor.name, extension);\n  }\n}\n\nfunction isMarkExtension(\n  extension: Extension,\n): extension is MarkExtension<UnistNode> {\n  return extension instanceof MarkExtension;\n}\n\nfunction isNodeExtension(\n  extension: Extension,\n): extension is NodeExtension<UnistNode> {\n  return extension instanceof NodeExtension;\n}\n","import type { Schema } from \"prosemirror-model\";\nimport type { Plugin } from \"prosemirror-state\";\n\nimport { type InputRule, inputRules } from \"prosemirror-inputrules\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class InputRulesBuilder {\n  private readonly rules: Array<InputRule>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.rules = ([] as Array<InputRule>).concat.apply(\n      [],\n      extensionManager\n        .syntaxExtensions()\n        .map((extension) => extension.proseMirrorInputRules(proseMirrorSchema)),\n    );\n  }\n\n  public build(): Plugin {\n    const inputRulesPlugin = inputRules({ rules: this.rules });\n    const originalHandleKeyDown =\n      inputRulesPlugin.props.handleKeyDown?.bind(inputRulesPlugin);\n    const customHandleKeyDown: Exclude<\n      typeof originalHandleKeyDown,\n      undefined\n    > = (view, event) => {\n      if (event.key === \"Enter\") {\n        const { from, to } = view.state.selection;\n        inputRulesPlugin.props.handleTextInput?.call(\n          inputRulesPlugin,\n          view,\n          from,\n          to,\n          \"\\n\",\n        );\n      }\n      return originalHandleKeyDown?.(view, event);\n    };\n    inputRulesPlugin.props.handleKeyDown = customHandleKeyDown;\n    return inputRulesPlugin;\n  }\n}\n","import type { Schema } from \"prosemirror-model\";\nimport type { Command, Plugin } from \"prosemirror-state\";\n\nimport { baseKeymap, chainCommands } from \"prosemirror-commands\";\nimport { keymap } from \"prosemirror-keymap\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class KeymapBuilder {\n  private readonly keymap: Map<string, Array<Command>>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.keymap = new Map();\n    for (const extension of extensionManager.syntaxExtensions()) {\n      this.addKeymap(extension.proseMirrorKeymap(proseMirrorSchema));\n    }\n    this.addKeymap(baseKeymap);\n  }\n\n  public build(): Plugin {\n    const chainedKeymap: Record<string, Command> = {};\n    this.keymap.forEach((commands, key) => {\n      chainedKeymap[key] = chainCommands(...commands);\n    });\n    return keymap(chainedKeymap);\n  }\n\n  private addKeymap(map: Record<string, Command>): void {\n    for (const key in map) {\n      if (!Object.prototype.hasOwnProperty.call(map, key)) {\n        continue;\n      }\n      if (!this.keymap.get(key)) {\n        this.keymap.set(key, []);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Set above.\n      this.keymap.get(key)!.push(map[key]);\n    }\n  }\n}\n","import type { NodeViewConstructor } from \"prosemirror-view\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class NodeViewBuilder {\n  private readonly nodeViews: Record<string, NodeViewConstructor>;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.nodeViews = {};\n    for (const extension of extensionManager.nodeExtensions()) {\n      const proseMirrorNodeName = extension.proseMirrorNodeName();\n      const proseMirrorNodeView = extension.proseMirrorNodeView();\n      if (proseMirrorNodeName !== null && proseMirrorNodeView !== null) {\n        this.nodeViews[proseMirrorNodeName] = proseMirrorNodeView;\n      }\n    }\n  }\n\n  public build(): Record<string, NodeViewConstructor> {\n    return this.nodeViews;\n  }\n}\n","import type { Node as ProseMirrorNode } from \"prosemirror-model\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class ProseMirrorToUnistConverter {\n  private readonly extensionManager: ExtensionManager;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.extensionManager = extensionManager;\n  }\n\n  public convert(node: ProseMirrorNode): UnistNode {\n    const rootNode = this.convertNode(node);\n    if (rootNode.length !== 1) {\n      throw new Error(\n        \"Couldn't find any way to convert the root ProseMirror node.\",\n      );\n    }\n    return rootNode[0];\n  }\n\n  private convertNode(node: ProseMirrorNode): Array<UnistNode> {\n    let convertedNodes: Array<UnistNode> | null = null;\n    for (const extension of this.extensionManager.nodeExtensions()) {\n      if (!extension.proseMirrorToUnistTest(node)) {\n        continue;\n      }\n      let convertedChildren: Array<UnistNode> = [];\n      for (let i = 0; i < node.childCount; ++i) {\n        convertedChildren = convertedChildren.concat(\n          this.convertNode(node.child(i)),\n        );\n      }\n      convertedNodes = extension.proseMirrorNodeToUnistNodes(\n        node,\n        convertedChildren,\n      );\n    }\n    if (convertedNodes === null) {\n      // eslint-disable-next-line no-console -- Intended console warning\n      console.warn(\n        `Couldn't find any way to convert ProseMirror node of type \"${node.type.name}\" to a unist node.`,\n      );\n      return [];\n    }\n    return convertedNodes.map((convertedNode) => {\n      let postProcessedNode = convertedNode;\n      for (const mark of node.marks) {\n        let processed = false;\n        for (const extension of this.extensionManager.markExtensions()) {\n          if (mark.type.name === extension.proseMirrorMarkName()) {\n            postProcessedNode = extension.processConvertedUnistNode(\n              postProcessedNode,\n              mark,\n            );\n            processed = true;\n          }\n        }\n        if (!processed) {\n          // eslint-disable-next-line no-console -- Intended console warning\n          console.warn(\n            `Couldn't find any way to convert ProseMirror mark of type \"${mark.type.name}\" to a unist node.`,\n          );\n        }\n      }\n      return postProcessedNode;\n    });\n  }\n}\n","import { type MarkSpec, type NodeSpec, Schema } from \"prosemirror-model\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class SchemaBuilder {\n  private readonly marks: Record<string, MarkSpec> = {};\n  private readonly nodes: Record<string, NodeSpec> = {};\n\n  public constructor(extensionManager: ExtensionManager) {\n    for (const extension of extensionManager.nodeExtensions()) {\n      const name = extension.proseMirrorNodeName();\n      const spec = extension.proseMirrorNodeSpec();\n      if (name !== null && spec !== null) {\n        this.nodes[name] = spec;\n      }\n    }\n    for (const extension of extensionManager.markExtensions()) {\n      const name = extension.proseMirrorMarkName();\n      const spec = extension.proseMirrorMarkSpec();\n      if (name !== null && spec !== null) {\n        this.marks[name] = spec;\n      }\n    }\n  }\n\n  public build(): Schema<string, string> {\n    return new Schema<string, string>({\n      marks: this.marks,\n      nodes: this.nodes,\n    });\n  }\n}\n","import type { Node as UnistNode } from \"unist\";\n\nimport { type Processor, unified } from \"unified\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class UnifiedBuilder {\n  private readonly extensionManager: ExtensionManager;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.extensionManager = extensionManager;\n  }\n\n  public build(): Processor<\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    string\n  > {\n    let processor = unified() as unknown as Processor<\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      string\n    >;\n    for (const extension of this.extensionManager.extensions()) {\n      processor = extension.unifiedInitializationHook(processor);\n    }\n    return processor;\n  }\n}\n","import type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Parent, Node as UnistNode } from \"unist\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class UnistToProseMirrorConverter {\n  private readonly extensionManager: ExtensionManager;\n  private readonly proseMirrorSchema: Schema<string, string>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.extensionManager = extensionManager;\n    this.proseMirrorSchema = proseMirrorSchema;\n  }\n\n  private static unistNodeIsParent(node: UnistNode): node is Parent {\n    return \"children\" in node;\n  }\n\n  public convert(unist: UnistNode): ProseMirrorNode {\n    const context: Partial<unknown> = {};\n    const rootNode = this.convertNode(unist, context);\n    for (const extension of this.extensionManager.syntaxExtensions()) {\n      extension.postUnistToProseMirrorHook(context);\n    }\n    if (rootNode.length !== 1) {\n      throw new Error(\"Couldn't find any way to convert the root unist node.\");\n    }\n    return rootNode[0];\n  }\n\n  private convertNode(\n    node: UnistNode,\n    context: Partial<unknown>,\n  ): Array<ProseMirrorNode> {\n    for (const extension of this.extensionManager.syntaxExtensions()) {\n      if (!extension.unistToProseMirrorTest(node)) {\n        continue;\n      }\n      let convertedChildren: Array<ProseMirrorNode> = [];\n      if (UnistToProseMirrorConverter.unistNodeIsParent(node)) {\n        convertedChildren = ([] as Array<ProseMirrorNode>).concat.apply(\n          [],\n          node.children.map((child) => this.convertNode(child, context)),\n        );\n      }\n      return extension.unistNodeToProseMirrorNodes(\n        node,\n        this.proseMirrorSchema,\n        convertedChildren,\n        context,\n      );\n    }\n    // eslint-disable-next-line no-console -- Intended console warning\n    console.warn(\n      `Couldn't find any way to convert unist node of type \"${node.type}\" to a ProseMirror node.`,\n    );\n    return [];\n  }\n}\n","import type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Plugin } from \"prosemirror-state\";\nimport type { NodeViewConstructor } from \"prosemirror-view\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport type { Extension } from \"./Extension\";\n\nimport { ExtensionManager } from \"./ExtensionManager\";\nimport { InputRulesBuilder } from \"./InputRulesBuilder\";\nimport { KeymapBuilder } from \"./KeymapBuilder\";\nimport { NodeViewBuilder } from \"./NodeViewBuilder\";\nimport { ProseMirrorToUnistConverter } from \"./ProseMirrorToUnistConverter\";\nimport { SchemaBuilder } from \"./SchemaBuilder\";\nimport { UnifiedBuilder } from \"./UnifiedBuilder\";\nimport { UnistToProseMirrorConverter } from \"./UnistToProseMirrorConverter\";\n\n/**\n * @public\n */\nexport class ProseMirrorUnified {\n  private readonly builtSchema: Schema<string, string>;\n  private readonly inputRulesBuilder: InputRulesBuilder;\n  private readonly keymapBuilder: KeymapBuilder;\n  private readonly nodeViewBuilder: NodeViewBuilder;\n  private readonly proseMirrorToUnistConverter: ProseMirrorToUnistConverter;\n  private readonly unified: Processor<\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    string\n  >;\n  private readonly unistToProseMirrorConverter: UnistToProseMirrorConverter;\n\n  public constructor(extensions: Array<Extension> = []) {\n    const extensionManager = new ExtensionManager(extensions);\n    this.builtSchema = new SchemaBuilder(extensionManager).build();\n    this.inputRulesBuilder = new InputRulesBuilder(\n      extensionManager,\n      this.builtSchema,\n    );\n    this.keymapBuilder = new KeymapBuilder(extensionManager, this.builtSchema);\n    this.nodeViewBuilder = new NodeViewBuilder(extensionManager);\n    this.unistToProseMirrorConverter = new UnistToProseMirrorConverter(\n      extensionManager,\n      this.builtSchema,\n    );\n    this.proseMirrorToUnistConverter = new ProseMirrorToUnistConverter(\n      extensionManager,\n    );\n    this.unified = new UnifiedBuilder(extensionManager).build();\n  }\n\n  public inputRulesPlugin(): Plugin {\n    return this.inputRulesBuilder.build();\n  }\n\n  public keymapPlugin(): Plugin {\n    return this.keymapBuilder.build();\n  }\n\n  public nodeViews(): Record<string, NodeViewConstructor> {\n    return this.nodeViewBuilder.build();\n  }\n\n  public parse(source: string): ProseMirrorNode {\n    const unist = this.unified.runSync(this.unified.parse(source));\n    const ret = this.unistToProseMirrorConverter.convert(unist);\n    return ret;\n  }\n\n  public schema(): Schema<string, string> {\n    return this.builtSchema;\n  }\n\n  public serialize(doc: ProseMirrorNode): string {\n    const unist = this.proseMirrorToUnistConverter.convert(doc);\n    const source: string = this.unified.stringify(unist);\n    return source;\n  }\n}\n"],"names":["InputRule","TextSelection","SelectionRange","inputRules","_a","baseKeymap","chainCommands","keymap","Schema","unified"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/prosemirror-unified.d.ts b/dist/prosemirror-unified.d.ts
index 67d0d14557e482abca377b30b4648d8038d8c3c3..f73cfeaa9ff37887c7a4b2887f358c5f1e22ced9 100644
--- a/dist/prosemirror-unified.d.ts
+++ b/dist/prosemirror-unified.d.ts
@@ -1,16 +1,16 @@
-import type { Attrs } from 'prosemirror-model';
-import type { Command } from 'prosemirror-state';
+import { Attrs } from 'prosemirror-model';
+import { Command } from 'prosemirror-state';
 import { InputRule } from 'prosemirror-inputrules';
-import type { Mark } from 'prosemirror-model';
-import type { MarkSpec } from 'prosemirror-model';
-import type { MarkType } from 'prosemirror-model';
-import type { Node as Node_2 } from 'prosemirror-model';
-import type { Node as Node_3 } from 'unist';
-import type { NodeSpec } from 'prosemirror-model';
-import type { NodeViewConstructor } from 'prosemirror-view';
-import type { Plugin as Plugin_2 } from 'prosemirror-state';
-import type { Processor } from 'unified';
-import type { Schema } from 'prosemirror-model';
+import { Mark } from 'prosemirror-model';
+import { MarkSpec } from 'prosemirror-model';
+import { MarkType } from 'prosemirror-model';
+import { Node as Node_2 } from 'prosemirror-model';
+import { Node as Node_3 } from 'unist';
+import { NodeSpec } from 'prosemirror-model';
+import { NodeViewConstructor } from 'prosemirror-view';
+import { Plugin as Plugin_2 } from 'prosemirror-state';
+import { Processor } from 'unified';
+import { Schema } from 'prosemirror-model';
 
 /**
  * @public
diff --git a/dist/prosemirror-unified.js b/dist/prosemirror-unified.js
index 57b870066491534d982917c29f5a8c3645b53de2..aed2a174a601f8433ffdaeef35e13cd92559bb1a 100644
--- a/dist/prosemirror-unified.js
+++ b/dist/prosemirror-unified.js
@@ -1,516 +1,427 @@
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__ from "prosemirror-inputrules";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__ from "prosemirror-state";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__ from "prosemirror-commands";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_keymap_62566a86__ from "prosemirror-keymap";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_model_701384b1__ from "prosemirror-model";
-import * as __WEBPACK_EXTERNAL_MODULE_unified__ from "unified";
-/******/ // The require scope
-/******/ var __webpack_require__ = {};
-/******/ 
-/************************************************************************/
-/******/ /* webpack/runtime/define property getters */
-/******/ (() => {
-/******/ 	// define getter functions for harmony exports
-/******/ 	__webpack_require__.d = (exports, definition) => {
-/******/ 		for(var key in definition) {
-/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
-/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
-/******/ 			}
-/******/ 		}
-/******/ 	};
-/******/ })();
-/******/ 
-/******/ /* webpack/runtime/hasOwnProperty shorthand */
-/******/ (() => {
-/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
-/******/ })();
-/******/ 
-/************************************************************************/
-var __webpack_exports__ = {};
-
-// EXPORTS
-__webpack_require__.d(__webpack_exports__, {
-  YY: () => (/* reexport */ Extension),
-  z1: () => (/* reexport */ MarkExtension),
-  mR: () => (/* reexport */ MarkInputRule),
-  ud: () => (/* reexport */ NodeExtension),
-  pJ: () => (/* reexport */ ProseMirrorUnified),
-  vU: () => (/* reexport */ SyntaxExtension),
-  lp: () => (/* reexport */ createProseMirrorNode)
-});
-
-;// CONCATENATED MODULE: ./src/createProseMirrorNode.ts
-/**
- * @public
- */
+import { InputRule, inputRules } from "prosemirror-inputrules";
+import { TextSelection, SelectionRange } from "prosemirror-state";
+import { baseKeymap, chainCommands } from "prosemirror-commands";
+import { keymap } from "prosemirror-keymap";
+import { Schema } from "prosemirror-model";
+import { unified } from "unified";
 function createProseMirrorNode(nodeName, schema, children, attrs = {}) {
-    if (nodeName === null) {
-        return [];
-    }
-    const proseMirrorNode = schema.nodes[nodeName].createAndFill(attrs, children);
-    if (proseMirrorNode === null) {
-        return [];
-    }
-    return [proseMirrorNode];
+  if (nodeName === null) {
+    return [];
+  }
+  const proseMirrorNode = schema.nodes[nodeName].createAndFill(attrs, children);
+  if (proseMirrorNode === null) {
+    return [];
+  }
+  return [proseMirrorNode];
 }
-
-;// CONCATENATED MODULE: ./src/Extension.ts
-/**
- * @public
- */
 class Extension {
-    /* eslint-disable @typescript-eslint/class-methods-use-this -- Invalid for interfaces */
-    dependencies() {
-        return [];
-    }
-    unifiedInitializationHook(processor) {
-        return processor;
-    }
+  /* eslint-disable @typescript-eslint/class-methods-use-this -- Invalid for interfaces */
+  dependencies() {
+    return [];
+  }
+  unifiedInitializationHook(processor) {
+    return processor;
+  }
+  /* eslint-enable */
 }
-
-;// CONCATENATED MODULE: ./src/SyntaxExtension.ts
-
-/**
- * @public
- */
 class SyntaxExtension extends Extension {
-    /* eslint-disable @typescript-eslint/class-methods-use-this, @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars -- These are invalid for interfaces */
-    postUnistToProseMirrorHook(
-    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden
-    context) { }
-    proseMirrorInputRules(
-    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden
-    proseMirrorSchema) {
-        return [];
-    }
-    proseMirrorKeymap(
-    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden
-    proseMirrorSchema) {
-        return {};
-    }
-    unistToProseMirrorTest(node) {
-        return node.type === this.unistNodeName();
-    }
+  /* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/class-methods-use-this, @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars -- These are invalid for interfaces */
+  postUnistToProseMirrorHook(context) {
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {};
+  }
+  unistToProseMirrorTest(node) {
+    return node.type === this.unistNodeName();
+  }
 }
-
-;// CONCATENATED MODULE: ./src/MarkExtension.ts
-
-/**
- * @public
- */
 class MarkExtension extends SyntaxExtension {
 }
-
-;// CONCATENATED MODULE: external "prosemirror-inputrules"
-var x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var y = (x) => (() => (x))
-const external_prosemirror_inputrules_namespaceObject = x({ ["InputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.InputRule), ["inputRules"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.inputRules) });
-;// CONCATENATED MODULE: external "prosemirror-state"
-var external_prosemirror_state_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_state_y = (x) => (() => (x))
-const external_prosemirror_state_namespaceObject = external_prosemirror_state_x({ ["SelectionRange"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.SelectionRange), ["TextSelection"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.TextSelection) });
-;// CONCATENATED MODULE: ./src/MarkInputRule.ts
-
-
-/**
- * @public
- */
-class MarkInputRule extends external_prosemirror_inputrules_namespaceObject.InputRule {
-    constructor(matcher, markType) {
-        super(matcher, (state, match, start, end) => this.markHandler(state, match, start, end));
-        this.markType = markType;
-    }
-    static markApplies(doc, ranges, type) {
-        for (const range of ranges) {
-            const { $from, $to } = range;
-            let applies = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
-            doc.nodesBetween($from.pos, $to.pos, (node) => {
-                if (applies) {
-                    return false;
-                }
-                applies = node.inlineContent && node.type.allowsMarkType(type);
-                return true;
-            });
-            if (applies) {
-                return true;
-            }
+class MarkInputRule extends InputRule {
+  constructor(matcher, markType) {
+    super(
+      matcher,
+      (state, match, start, end) => this.markHandler(state, match, start, end)
+    );
+    this.markType = markType;
+  }
+  static markApplies(doc, ranges, type) {
+    for (const range of ranges) {
+      const { $from, $to } = range;
+      let applies = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
+      doc.nodesBetween($from.pos, $to.pos, (node) => {
+        if (applies) {
+          return false;
         }
-        return false;
-    }
-    markHandler(state, match, start, end) {
-        var _a, _b;
-        if (!(state.selection instanceof external_prosemirror_state_namespaceObject.TextSelection)) {
-            return null;
-        }
-        // Determine if mark applies to match
-        const $start = state.doc.resolve(start);
-        const $end = state.doc.resolve(end);
-        const range = [new external_prosemirror_state_namespaceObject.SelectionRange($start, $end)];
-        if (!MarkInputRule.markApplies(state.doc, range, this.markType)) {
-            return null;
-        }
-        // List all existing marks and add the new one
-        const newMarks = (_b = (_a = state.doc.nodeAt(start)) === null || _a === void 0 ? void 0 : _a.marks.map((mark) => mark.type)) !== null && _b !== void 0 ? _b : [];
-        newMarks.push(this.markType);
-        // Replace the affected range with the matched text - this removes e.g. the asterisks around italic
-        const tr = state.tr.replaceWith(start, end, this.markType.schema.text(match[1]));
-        // Add back all marks, including the new one
-        for (const markType of newMarks) {
-            tr.addMark(tr.mapping.map(start), tr.mapping.map(end), markType.create(null));
-        }
-        // Make the text editor insert clean text with no marks on next input
-        for (const markType of newMarks) {
-            tr.removeStoredMark(markType);
-        }
-        // Add back the last character
-        return tr.insertText(match[2]);
-    }
+        applies = node.inlineContent && node.type.allowsMarkType(type);
+        return true;
+      });
+      if (applies) {
+        return true;
+      }
+    }
+    return false;
+  }
+  markHandler(state, match, start, end) {
+    var _a;
+    if (!(state.selection instanceof TextSelection)) {
+      return null;
+    }
+    const $start = state.doc.resolve(start);
+    const $end = state.doc.resolve(end);
+    const range = [new SelectionRange($start, $end)];
+    if (!MarkInputRule.markApplies(state.doc, range, this.markType)) {
+      return null;
+    }
+    const newMarks = ((_a = state.doc.nodeAt(start)) == null ? void 0 : _a.marks.map((mark) => mark.type)) ?? [];
+    newMarks.push(this.markType);
+    let inner = "";
+    let trailing = "";
+    if (match.groups) {
+      ({ i: inner, t: trailing } = match.groups);
+    } else {
+      ({ 1: inner, 2: trailing } = match);
+    }
+    const tr = state.tr.replaceWith(
+      start,
+      end,
+      this.markType.schema.text(inner)
+    );
+    for (const markType of newMarks) {
+      tr.addMark(
+        tr.mapping.map(start),
+        tr.mapping.map(end),
+        markType.create(null)
+      );
+    }
+    for (const markType of newMarks) {
+      tr.removeStoredMark(markType);
+    }
+    if (trailing !== "\n") {
+      tr.insertText(trailing);
+    }
+    return tr;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/NodeExtension.ts
-
-/**
- * @public
- */
 class NodeExtension extends SyntaxExtension {
-    // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inalid for an interface
-    proseMirrorNodeView() {
-        return null;
-    }
-    proseMirrorToUnistTest(node) {
-        return this.proseMirrorNodeName() === node.type.name;
-    }
+  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inalid for an interface
+  proseMirrorNodeView() {
+    return null;
+  }
+  proseMirrorToUnistTest(node) {
+    return this.proseMirrorNodeName() === node.type.name;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/ExtensionManager.ts
-
-
-function isNodeExtension(extension) {
-    return extension instanceof NodeExtension;
+class ExtensionManager {
+  constructor(extensions) {
+    this.markExtensionList = /* @__PURE__ */ new Map();
+    this.nodeExtensionList = /* @__PURE__ */ new Map();
+    this.otherExtensionList = /* @__PURE__ */ new Map();
+    for (const extension of extensions) {
+      this.add(extension);
+    }
+  }
+  extensions() {
+    return this.syntaxExtensions().concat(
+      Array.from(this.otherExtensionList.values())
+    );
+  }
+  markExtensions() {
+    return Array.from(this.markExtensionList.values());
+  }
+  nodeExtensions() {
+    return Array.from(this.nodeExtensionList.values());
+  }
+  syntaxExtensions() {
+    return this.nodeExtensions().concat(
+      this.markExtensions()
+    );
+  }
+  add(extension) {
+    for (const dependency of extension.dependencies()) {
+      this.add(dependency);
+    }
+    if (isMarkExtension(extension)) {
+      this.markExtensionList.set(extension.constructor.name, extension);
+      return;
+    }
+    if (isNodeExtension(extension)) {
+      this.nodeExtensionList.set(extension.constructor.name, extension);
+      return;
+    }
+    this.otherExtensionList.set(extension.constructor.name, extension);
+  }
 }
 function isMarkExtension(extension) {
-    return extension instanceof MarkExtension;
+  return extension instanceof MarkExtension;
 }
-class ExtensionManager {
-    constructor(extensions) {
-        this.markExtensionList = new Map();
-        this.nodeExtensionList = new Map();
-        this.otherExtensionList = new Map();
-        for (const extension of extensions) {
-            this.add(extension);
-        }
-    }
-    add(extension) {
-        for (const dependency of extension.dependencies()) {
-            this.add(dependency);
-        }
-        if (isMarkExtension(extension)) {
-            this.markExtensionList.set(extension.constructor.name, extension);
-            return;
-        }
-        if (isNodeExtension(extension)) {
-            this.nodeExtensionList.set(extension.constructor.name, extension);
-            return;
-        }
-        this.otherExtensionList.set(extension.constructor.name, extension);
-    }
-    extensions() {
-        return this.syntaxExtensions().concat(Array.from(this.otherExtensionList.values()));
-    }
-    markExtensions() {
-        return Array.from(this.markExtensionList.values());
-    }
-    nodeExtensions() {
-        return Array.from(this.nodeExtensionList.values());
-    }
-    syntaxExtensions() {
-        return this.nodeExtensions().concat(this.markExtensions());
-    }
+function isNodeExtension(extension) {
+  return extension instanceof NodeExtension;
 }
-
-;// CONCATENATED MODULE: ./src/InputRulesBuilder.ts
-
 class InputRulesBuilder {
-    constructor(extensionManager, proseMirrorSchema) {
-        this.rules = [].concat.apply([], extensionManager
-            .syntaxExtensions()
-            .map((extension) => extension.proseMirrorInputRules(proseMirrorSchema)));
-    }
-    build() {
-        return (0,external_prosemirror_inputrules_namespaceObject.inputRules)({ rules: this.rules });
-    }
+  constructor(extensionManager, proseMirrorSchema) {
+    this.rules = [].concat.apply(
+      [],
+      extensionManager.syntaxExtensions().map((extension) => extension.proseMirrorInputRules(proseMirrorSchema))
+    );
+  }
+  build() {
+    var _a;
+    const inputRulesPlugin = inputRules({ rules: this.rules });
+    const originalHandleKeyDown = (_a = inputRulesPlugin.props.handleKeyDown) == null ? void 0 : _a.bind(inputRulesPlugin);
+    const customHandleKeyDown = (view, event) => {
+      var _a2;
+      if (event.key === "Enter") {
+        const { from, to } = view.state.selection;
+        (_a2 = inputRulesPlugin.props.handleTextInput) == null ? void 0 : _a2.call(
+          inputRulesPlugin,
+          view,
+          from,
+          to,
+          "\n"
+        );
+      }
+      return originalHandleKeyDown == null ? void 0 : originalHandleKeyDown(view, event);
+    };
+    inputRulesPlugin.props.handleKeyDown = customHandleKeyDown;
+    return inputRulesPlugin;
+  }
 }
-
-;// CONCATENATED MODULE: external "prosemirror-commands"
-var external_prosemirror_commands_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_commands_y = (x) => (() => (x))
-const external_prosemirror_commands_namespaceObject = external_prosemirror_commands_x({ ["baseKeymap"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.baseKeymap), ["chainCommands"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.chainCommands) });
-;// CONCATENATED MODULE: external "prosemirror-keymap"
-var external_prosemirror_keymap_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_keymap_y = (x) => (() => (x))
-const external_prosemirror_keymap_namespaceObject = external_prosemirror_keymap_x({ ["keymap"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_keymap_62566a86__.keymap) });
-;// CONCATENATED MODULE: ./src/KeymapBuilder.ts
-
-
 class KeymapBuilder {
-    constructor(extensionManager, proseMirrorSchema) {
-        this.keymap = new Map();
-        for (const extension of extensionManager.syntaxExtensions()) {
-            this.addKeymap(extension.proseMirrorKeymap(proseMirrorSchema));
-        }
-        this.addKeymap(external_prosemirror_commands_namespaceObject.baseKeymap);
-    }
-    addKeymap(map) {
-        for (const key in map) {
-            if (!Object.prototype.hasOwnProperty.call(map, key)) {
-                continue;
-            }
-            if (!this.keymap.get(key)) {
-                this.keymap.set(key, []);
-            }
-            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Set above.
-            this.keymap.get(key).push(map[key]);
-        }
-    }
-    build() {
-        const chainedKeymap = {};
-        this.keymap.forEach((commands, key) => {
-            chainedKeymap[key] = (0,external_prosemirror_commands_namespaceObject.chainCommands)(...commands);
-        });
-        return (0,external_prosemirror_keymap_namespaceObject.keymap)(chainedKeymap);
-    }
+  constructor(extensionManager, proseMirrorSchema) {
+    this.keymap = /* @__PURE__ */ new Map();
+    for (const extension of extensionManager.syntaxExtensions()) {
+      this.addKeymap(extension.proseMirrorKeymap(proseMirrorSchema));
+    }
+    this.addKeymap(baseKeymap);
+  }
+  build() {
+    const chainedKeymap = {};
+    this.keymap.forEach((commands, key) => {
+      chainedKeymap[key] = chainCommands(...commands);
+    });
+    return keymap(chainedKeymap);
+  }
+  addKeymap(map) {
+    for (const key in map) {
+      if (!Object.prototype.hasOwnProperty.call(map, key)) {
+        continue;
+      }
+      if (!this.keymap.get(key)) {
+        this.keymap.set(key, []);
+      }
+      this.keymap.get(key).push(map[key]);
+    }
+  }
 }
-
-;// CONCATENATED MODULE: ./src/NodeViewBuilder.ts
 class NodeViewBuilder {
-    constructor(extensionManager) {
-        this.nodeViews = {};
-        for (const extension of extensionManager.nodeExtensions()) {
-            const proseMirrorNodeName = extension.proseMirrorNodeName();
-            const proseMirrorNodeView = extension.proseMirrorNodeView();
-            if (proseMirrorNodeName !== null && proseMirrorNodeView !== null) {
-                this.nodeViews[proseMirrorNodeName] = proseMirrorNodeView;
-            }
-        }
-    }
-    build() {
-        return this.nodeViews;
-    }
+  constructor(extensionManager) {
+    this.nodeViews = {};
+    for (const extension of extensionManager.nodeExtensions()) {
+      const proseMirrorNodeName = extension.proseMirrorNodeName();
+      const proseMirrorNodeView = extension.proseMirrorNodeView();
+      if (proseMirrorNodeName !== null && proseMirrorNodeView !== null) {
+        this.nodeViews[proseMirrorNodeName] = proseMirrorNodeView;
+      }
+    }
+  }
+  build() {
+    return this.nodeViews;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/ProseMirrorToUnistConverter.ts
 class ProseMirrorToUnistConverter {
-    constructor(extensionManager) {
-        this.extensionManager = extensionManager;
-    }
-    convertNode(node) {
-        let convertedNodes = null;
-        for (const extension of this.extensionManager.nodeExtensions()) {
-            if (!extension.proseMirrorToUnistTest(node)) {
-                continue;
-            }
-            let convertedChildren = [];
-            for (let i = 0; i < node.childCount; ++i) {
-                convertedChildren = convertedChildren.concat(this.convertNode(node.child(i)));
-            }
-            convertedNodes = extension.proseMirrorNodeToUnistNodes(node, convertedChildren);
+  constructor(extensionManager) {
+    this.extensionManager = extensionManager;
+  }
+  convert(node) {
+    const rootNode = this.convertNode(node);
+    if (rootNode.length !== 1) {
+      throw new Error(
+        "Couldn't find any way to convert the root ProseMirror node."
+      );
+    }
+    return rootNode[0];
+  }
+  convertNode(node) {
+    let convertedNodes = null;
+    for (const extension of this.extensionManager.nodeExtensions()) {
+      if (!extension.proseMirrorToUnistTest(node)) {
+        continue;
+      }
+      let convertedChildren = [];
+      for (let i = 0; i < node.childCount; ++i) {
+        convertedChildren = convertedChildren.concat(
+          this.convertNode(node.child(i))
+        );
+      }
+      convertedNodes = extension.proseMirrorNodeToUnistNodes(
+        node,
+        convertedChildren
+      );
+    }
+    if (convertedNodes === null) {
+      console.warn(
+        `Couldn't find any way to convert ProseMirror node of type "${node.type.name}" to a unist node.`
+      );
+      return [];
+    }
+    return convertedNodes.map((convertedNode) => {
+      let postProcessedNode = convertedNode;
+      for (const mark of node.marks) {
+        let processed = false;
+        for (const extension of this.extensionManager.markExtensions()) {
+          if (mark.type.name === extension.proseMirrorMarkName()) {
+            postProcessedNode = extension.processConvertedUnistNode(
+              postProcessedNode,
+              mark
+            );
+            processed = true;
+          }
         }
-        if (convertedNodes === null) {
-            // eslint-disable-next-line no-console -- Intended console warning
-            console.warn(`Couldn't find any way to convert ProseMirror node of type "${node.type.name}" to a unist node.`);
-            return [];
+        if (!processed) {
+          console.warn(
+            `Couldn't find any way to convert ProseMirror mark of type "${mark.type.name}" to a unist node.`
+          );
         }
-        return convertedNodes.map((convertedNode) => {
-            let postProcessedNode = convertedNode;
-            for (const mark of node.marks) {
-                let processed = false;
-                for (const extension of this.extensionManager.markExtensions()) {
-                    if (mark.type.name === extension.proseMirrorMarkName()) {
-                        postProcessedNode = extension.processConvertedUnistNode(postProcessedNode, mark);
-                        processed = true;
-                    }
-                }
-                if (!processed) {
-                    // eslint-disable-next-line no-console -- Intended console warning
-                    console.warn(`Couldn't find any way to convert ProseMirror mark of type "${mark.type.name}" to a unist node.`);
-                }
-            }
-            return postProcessedNode;
-        });
-    }
-    convert(node) {
-        const rootNode = this.convertNode(node);
-        if (rootNode.length !== 1) {
-            throw new Error("Couldn't find any way to convert the root ProseMirror node.");
-        }
-        return rootNode[0];
-    }
+      }
+      return postProcessedNode;
+    });
+  }
 }
-
-;// CONCATENATED MODULE: external "prosemirror-model"
-var external_prosemirror_model_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_model_y = (x) => (() => (x))
-const external_prosemirror_model_namespaceObject = external_prosemirror_model_x({ ["Schema"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_model_701384b1__.Schema) });
-;// CONCATENATED MODULE: ./src/SchemaBuilder.ts
-
 class SchemaBuilder {
-    constructor(extensionManager) {
-        this.marks = {};
-        this.nodes = {};
-        for (const extension of extensionManager.nodeExtensions()) {
-            const name = extension.proseMirrorNodeName();
-            const spec = extension.proseMirrorNodeSpec();
-            if (name !== null && spec !== null) {
-                this.nodes[name] = spec;
-            }
-        }
-        for (const extension of extensionManager.markExtensions()) {
-            const name = extension.proseMirrorMarkName();
-            const spec = extension.proseMirrorMarkSpec();
-            if (name !== null && spec !== null) {
-                this.marks[name] = spec;
-            }
-        }
-    }
-    build() {
-        return new external_prosemirror_model_namespaceObject.Schema({
-            marks: this.marks,
-            nodes: this.nodes,
-        });
-    }
+  constructor(extensionManager) {
+    this.marks = {};
+    this.nodes = {};
+    for (const extension of extensionManager.nodeExtensions()) {
+      const name = extension.proseMirrorNodeName();
+      const spec = extension.proseMirrorNodeSpec();
+      if (name !== null && spec !== null) {
+        this.nodes[name] = spec;
+      }
+    }
+    for (const extension of extensionManager.markExtensions()) {
+      const name = extension.proseMirrorMarkName();
+      const spec = extension.proseMirrorMarkSpec();
+      if (name !== null && spec !== null) {
+        this.marks[name] = spec;
+      }
+    }
+  }
+  build() {
+    return new Schema({
+      marks: this.marks,
+      nodes: this.nodes
+    });
+  }
 }
-
-;// CONCATENATED MODULE: external "unified"
-var external_unified_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_unified_y = (x) => (() => (x))
-const external_unified_namespaceObject = external_unified_x({ ["unified"]: () => (__WEBPACK_EXTERNAL_MODULE_unified__.unified) });
-;// CONCATENATED MODULE: ./src/UnifiedBuilder.ts
-
 class UnifiedBuilder {
-    constructor(extensionManager) {
-        this.extensionManager = extensionManager;
-    }
-    build() {
-        let processor = (0,external_unified_namespaceObject.unified)();
-        for (const extension of this.extensionManager.extensions()) {
-            processor = extension.unifiedInitializationHook(processor);
-        }
-        return processor;
-    }
+  constructor(extensionManager) {
+    this.extensionManager = extensionManager;
+  }
+  build() {
+    let processor = unified();
+    for (const extension of this.extensionManager.extensions()) {
+      processor = extension.unifiedInitializationHook(processor);
+    }
+    return processor;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/UnistToProseMirrorConverter.ts
 class UnistToProseMirrorConverter {
-    constructor(extensionManager, proseMirrorSchema) {
-        this.extensionManager = extensionManager;
-        this.proseMirrorSchema = proseMirrorSchema;
-    }
-    static unistNodeIsParent(node) {
-        return "children" in node;
-    }
-    convertNode(node, context) {
-        for (const extension of this.extensionManager.syntaxExtensions()) {
-            if (!extension.unistToProseMirrorTest(node)) {
-                continue;
-            }
-            let convertedChildren = [];
-            if (UnistToProseMirrorConverter.unistNodeIsParent(node)) {
-                convertedChildren = [].concat.apply([], node.children.map((child) => this.convertNode(child, context)));
-            }
-            return extension.unistNodeToProseMirrorNodes(node, this.proseMirrorSchema, convertedChildren, context);
-        }
-        // eslint-disable-next-line no-console -- Intended console warning
-        console.warn(`Couldn't find any way to convert unist node of type "${node.type}" to a ProseMirror node.`);
-        return [];
-    }
-    convert(unist) {
-        const context = {};
-        const rootNode = this.convertNode(unist, context);
-        for (const extension of this.extensionManager.syntaxExtensions()) {
-            extension.postUnistToProseMirrorHook(context);
-        }
-        if (rootNode.length !== 1) {
-            throw new Error("Couldn't find any way to convert the root unist node.");
-        }
-        return rootNode[0];
-    }
+  constructor(extensionManager, proseMirrorSchema) {
+    this.extensionManager = extensionManager;
+    this.proseMirrorSchema = proseMirrorSchema;
+  }
+  static unistNodeIsParent(node) {
+    return "children" in node;
+  }
+  convert(unist) {
+    const context = {};
+    const rootNode = this.convertNode(unist, context);
+    for (const extension of this.extensionManager.syntaxExtensions()) {
+      extension.postUnistToProseMirrorHook(context);
+    }
+    if (rootNode.length !== 1) {
+      throw new Error("Couldn't find any way to convert the root unist node.");
+    }
+    return rootNode[0];
+  }
+  convertNode(node, context) {
+    for (const extension of this.extensionManager.syntaxExtensions()) {
+      if (!extension.unistToProseMirrorTest(node)) {
+        continue;
+      }
+      let convertedChildren = [];
+      if (UnistToProseMirrorConverter.unistNodeIsParent(node)) {
+        convertedChildren = [].concat.apply(
+          [],
+          node.children.map((child) => this.convertNode(child, context))
+        );
+      }
+      return extension.unistNodeToProseMirrorNodes(
+        node,
+        this.proseMirrorSchema,
+        convertedChildren,
+        context
+      );
+    }
+    console.warn(
+      `Couldn't find any way to convert unist node of type "${node.type}" to a ProseMirror node.`
+    );
+    return [];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/ProseMirrorUnified.ts
-
-
-
-
-
-
-
-
-/**
- * @public
- */
 class ProseMirrorUnified {
-    constructor(extensions = []) {
-        const extensionManager = new ExtensionManager(extensions);
-        this.builtSchema = new SchemaBuilder(extensionManager).build();
-        this.inputRulesBuilder = new InputRulesBuilder(extensionManager, this.builtSchema);
-        this.keymapBuilder = new KeymapBuilder(extensionManager, this.builtSchema);
-        this.nodeViewBuilder = new NodeViewBuilder(extensionManager);
-        this.unistToProseMirrorConverter = new UnistToProseMirrorConverter(extensionManager, this.builtSchema);
-        this.proseMirrorToUnistConverter = new ProseMirrorToUnistConverter(extensionManager);
-        this.unified = new UnifiedBuilder(extensionManager).build();
-    }
-    inputRulesPlugin() {
-        return this.inputRulesBuilder.build();
-    }
-    keymapPlugin() {
-        return this.keymapBuilder.build();
-    }
-    nodeViews() {
-        return this.nodeViewBuilder.build();
-    }
-    parse(source) {
-        const unist = this.unified.runSync(this.unified.parse(source));
-        const ret = this.unistToProseMirrorConverter.convert(unist);
-        return ret;
-    }
-    schema() {
-        return this.builtSchema;
-    }
-    serialize(doc) {
-        const unist = this.proseMirrorToUnistConverter.convert(doc);
-        const source = this.unified.stringify(unist);
-        return source;
-    }
+  constructor(extensions = []) {
+    const extensionManager = new ExtensionManager(extensions);
+    this.builtSchema = new SchemaBuilder(extensionManager).build();
+    this.inputRulesBuilder = new InputRulesBuilder(
+      extensionManager,
+      this.builtSchema
+    );
+    this.keymapBuilder = new KeymapBuilder(extensionManager, this.builtSchema);
+    this.nodeViewBuilder = new NodeViewBuilder(extensionManager);
+    this.unistToProseMirrorConverter = new UnistToProseMirrorConverter(
+      extensionManager,
+      this.builtSchema
+    );
+    this.proseMirrorToUnistConverter = new ProseMirrorToUnistConverter(
+      extensionManager
+    );
+    this.unified = new UnifiedBuilder(extensionManager).build();
+  }
+  inputRulesPlugin() {
+    return this.inputRulesBuilder.build();
+  }
+  keymapPlugin() {
+    return this.keymapBuilder.build();
+  }
+  nodeViews() {
+    return this.nodeViewBuilder.build();
+  }
+  parse(source) {
+    const unist = this.unified.runSync(this.unified.parse(source));
+    const ret = this.unistToProseMirrorConverter.convert(unist);
+    return ret;
+  }
+  schema() {
+    return this.builtSchema;
+  }
+  serialize(doc) {
+    const unist = this.proseMirrorToUnistConverter.convert(doc);
+    const source = this.unified.stringify(unist);
+    return source;
+  }
 }
-
-;// CONCATENATED MODULE: ./src/index.ts
-
-
-
-
-
-
-
-
-var __webpack_exports__Extension = __webpack_exports__.YY;
-var __webpack_exports__MarkExtension = __webpack_exports__.z1;
-var __webpack_exports__MarkInputRule = __webpack_exports__.mR;
-var __webpack_exports__NodeExtension = __webpack_exports__.ud;
-var __webpack_exports__ProseMirrorUnified = __webpack_exports__.pJ;
-var __webpack_exports__SyntaxExtension = __webpack_exports__.vU;
-var __webpack_exports__createProseMirrorNode = __webpack_exports__.lp;
-export { __webpack_exports__Extension as Extension, __webpack_exports__MarkExtension as MarkExtension, __webpack_exports__MarkInputRule as MarkInputRule, __webpack_exports__NodeExtension as NodeExtension, __webpack_exports__ProseMirrorUnified as ProseMirrorUnified, __webpack_exports__SyntaxExtension as SyntaxExtension, __webpack_exports__createProseMirrorNode as createProseMirrorNode };
-
+export {
+  Extension,
+  MarkExtension,
+  MarkInputRule,
+  NodeExtension,
+  ProseMirrorUnified,
+  SyntaxExtension,
+  createProseMirrorNode
+};
 //# sourceMappingURL=prosemirror-unified.js.map
diff --git a/dist/prosemirror-unified.js.map b/dist/prosemirror-unified.js.map
index d5b30cc120c62fbf1ddd1cb8aba1c93b4048b795..b4c76cc2ba1e0449ee81ce77f1c62527cc2af256 100644
--- a/dist/prosemirror-unified.js.map
+++ b/dist/prosemirror-unified.js.map
@@ -1 +1 @@
-{"version":3,"file":"prosemirror-unified.js","mappings":"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","sources":["webpack://prosemirror-unified/webpack/bootstrap","webpack://prosemirror-unified/webpack/runtime/define property getters","webpack://prosemirror-unified/webpack/runtime/hasOwnProperty shorthand","webpack://prosemirror-unified/./src/createProseMirrorNode.ts","webpack://prosemirror-unified/./src/Extension.ts","webpack://prosemirror-unified/./src/SyntaxExtension.ts","webpack://prosemirror-unified/./src/MarkExtension.ts","webpack://prosemirror-unified/external module \"prosemirror-inputrules\"","webpack://prosemirror-unified/external module \"prosemirror-state\"","webpack://prosemirror-unified/./src/MarkInputRule.ts","webpack://prosemirror-unified/./src/NodeExtension.ts","webpack://prosemirror-unified/./src/ExtensionManager.ts","webpack://prosemirror-unified/./src/InputRulesBuilder.ts","webpack://prosemirror-unified/external module \"prosemirror-commands\"","webpack://prosemirror-unified/external module \"prosemirror-keymap\"","webpack://prosemirror-unified/./src/KeymapBuilder.ts","webpack://prosemirror-unified/./src/NodeViewBuilder.ts","webpack://prosemirror-unified/./src/ProseMirrorToUnistConverter.ts","webpack://prosemirror-unified/external module \"prosemirror-model\"","webpack://prosemirror-unified/./src/SchemaBuilder.ts","webpack://prosemirror-unified/external module \"unified\"","webpack://prosemirror-unified/./src/UnifiedBuilder.ts","webpack://prosemirror-unified/./src/UnistToProseMirrorConverter.ts","webpack://prosemirror-unified/./src/ProseMirrorUnified.ts","webpack://prosemirror-unified/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import type { Attrs, Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\n/**\n * @public\n */\nexport function createProseMirrorNode(\n  nodeName: string | null,\n  schema: Schema<string, string>,\n  children: Array<ProseMirrorNode>,\n  attrs: Attrs = {},\n): Array<ProseMirrorNode> {\n  if (nodeName === null) {\n    return [];\n  }\n  const proseMirrorNode = schema.nodes[nodeName].createAndFill(attrs, children);\n  if (proseMirrorNode === null) {\n    return [];\n  }\n  return [proseMirrorNode];\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\n/**\n * @public\n */\nexport abstract class Extension {\n  /* eslint-disable @typescript-eslint/class-methods-use-this -- Invalid for interfaces */\n  public dependencies(): Array<Extension> {\n    return [];\n  }\n\n  public unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor;\n  }\n  /* eslint-enable */\n}\n","import type { InputRule } from \"prosemirror-inputrules\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { Extension } from \"./Extension\";\n\n/**\n * @public\n */\nexport abstract class SyntaxExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends Extension {\n  /* eslint-disable @typescript-eslint/class-methods-use-this, @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars -- These are invalid for interfaces */\n  public postUnistToProseMirrorHook(\n    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    context: Partial<UnistToProseMirrorContext>,\n  ): void {}\n\n  public proseMirrorInputRules(\n    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [];\n  }\n\n  public proseMirrorKeymap(\n    // @ts-expect-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {};\n  }\n  /* eslint-enable */\n\n  public abstract unistNodeName(): UNode[\"type\"];\n\n  public abstract unistNodeToProseMirrorNodes(\n    node: UNode,\n    schema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<UnistToProseMirrorContext>,\n  ): Array<ProseMirrorNode>;\n\n  public unistToProseMirrorTest(node: UnistNode): boolean {\n    return node.type === this.unistNodeName();\n  }\n}\n","import type { Mark, MarkSpec } from \"prosemirror-model\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { SyntaxExtension } from \"./SyntaxExtension\";\n\n/**\n * @public\n */\nexport abstract class MarkExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends SyntaxExtension<UNode, UnistToProseMirrorContext> {\n  public abstract processConvertedUnistNode(\n    convertedNode: UnistNode,\n    originalMark: Mark,\n  ): UNode;\n\n  public abstract proseMirrorMarkName(): string | null;\n\n  public abstract proseMirrorMarkSpec(): MarkSpec | null;\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"InputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.InputRule), [\"inputRules\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.inputRules) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"SelectionRange\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.SelectionRange), [\"TextSelection\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.TextSelection) });","import type { MarkType, Node as ProseMirrorNode } from \"prosemirror-model\";\n\nimport { InputRule } from \"prosemirror-inputrules\";\nimport {\n  type EditorState,\n  SelectionRange,\n  TextSelection,\n  type Transaction,\n} from \"prosemirror-state\";\n\n/**\n * @public\n */\nexport class MarkInputRule extends InputRule {\n  private readonly markType: MarkType;\n\n  public constructor(matcher: RegExp, markType: MarkType) {\n    super(matcher, (state, match, start, end) =>\n      this.markHandler(state, match, start, end),\n    );\n    this.markType = markType;\n  }\n\n  private static markApplies(\n    doc: ProseMirrorNode,\n    ranges: Array<SelectionRange>,\n    type: MarkType,\n  ): boolean {\n    for (const range of ranges) {\n      const { $from, $to } = range;\n      let applies = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n      doc.nodesBetween($from.pos, $to.pos, (node) => {\n        if (applies) {\n          return false;\n        }\n        applies = node.inlineContent && node.type.allowsMarkType(type);\n        return true;\n      });\n      if (applies) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private markHandler(\n    state: EditorState,\n    match: RegExpMatchArray,\n    start: number,\n    end: number,\n  ): Transaction | null {\n    if (!(state.selection instanceof TextSelection)) {\n      return null;\n    }\n\n    // Determine if mark applies to match\n    const $start = state.doc.resolve(start);\n    const $end = state.doc.resolve(end);\n    const range = [new SelectionRange($start, $end)];\n\n    if (!MarkInputRule.markApplies(state.doc, range, this.markType)) {\n      return null;\n    }\n\n    // List all existing marks and add the new one\n    const newMarks =\n      state.doc.nodeAt(start)?.marks.map((mark) => mark.type) ?? [];\n    newMarks.push(this.markType);\n\n    // Replace the affected range with the matched text - this removes e.g. the asterisks around italic\n    const tr = state.tr.replaceWith(\n      start,\n      end,\n      this.markType.schema.text(match[1]),\n    );\n\n    // Add back all marks, including the new one\n    for (const markType of newMarks) {\n      tr.addMark(\n        tr.mapping.map(start),\n        tr.mapping.map(end),\n        markType.create(null),\n      );\n    }\n\n    // Make the text editor insert clean text with no marks on next input\n    for (const markType of newMarks) {\n      tr.removeStoredMark(markType);\n    }\n\n    // Add back the last character\n    return tr.insertText(match[2]);\n  }\n}\n","import type { NodeSpec, Node as ProseMirrorNode } from \"prosemirror-model\";\nimport type { NodeViewConstructor } from \"prosemirror-view\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { SyntaxExtension } from \"./SyntaxExtension\";\n\n/**\n * @public\n */\nexport abstract class NodeExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends SyntaxExtension<UNode, UnistToProseMirrorContext> {\n  public abstract proseMirrorNodeName(): string | null;\n\n  public abstract proseMirrorNodeSpec(): NodeSpec | null;\n\n  public abstract proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<UnistNode>,\n  ): Array<UNode>;\n\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inalid for an interface\n  public proseMirrorNodeView(): NodeViewConstructor | null {\n    return null;\n  }\n\n  public proseMirrorToUnistTest(node: ProseMirrorNode): boolean {\n    return this.proseMirrorNodeName() === node.type.name;\n  }\n}\n","import type { Node as UnistNode } from \"unist\";\n\nimport type { Extension } from \"./Extension\";\nimport type { SyntaxExtension } from \"./SyntaxExtension\";\n\nimport { MarkExtension } from \"./MarkExtension\";\nimport { NodeExtension } from \"./NodeExtension\";\n\nfunction isNodeExtension(\n  extension: Extension,\n): extension is NodeExtension<UnistNode> {\n  return extension instanceof NodeExtension;\n}\n\nfunction isMarkExtension(\n  extension: Extension,\n): extension is MarkExtension<UnistNode> {\n  return extension instanceof MarkExtension;\n}\n\nexport class ExtensionManager {\n  private readonly markExtensionList: Map<string, MarkExtension<UnistNode>>;\n  private readonly nodeExtensionList: Map<string, NodeExtension<UnistNode>>;\n  private readonly otherExtensionList: Map<string, Extension>;\n\n  public constructor(extensions: Array<Extension>) {\n    this.markExtensionList = new Map();\n    this.nodeExtensionList = new Map();\n    this.otherExtensionList = new Map();\n\n    for (const extension of extensions) {\n      this.add(extension);\n    }\n  }\n\n  private add(extension: Extension): void {\n    for (const dependency of extension.dependencies()) {\n      this.add(dependency);\n    }\n\n    if (isMarkExtension(extension)) {\n      this.markExtensionList.set(extension.constructor.name, extension);\n      return;\n    }\n    if (isNodeExtension(extension)) {\n      this.nodeExtensionList.set(extension.constructor.name, extension);\n      return;\n    }\n    this.otherExtensionList.set(extension.constructor.name, extension);\n  }\n\n  public extensions(): Array<Extension> {\n    return (this.syntaxExtensions() as Array<Extension>).concat(\n      Array.from(this.otherExtensionList.values()),\n    );\n  }\n\n  public markExtensions(): Array<MarkExtension<UnistNode>> {\n    return Array.from(this.markExtensionList.values());\n  }\n\n  public nodeExtensions(): Array<NodeExtension<UnistNode>> {\n    return Array.from(this.nodeExtensionList.values());\n  }\n\n  public syntaxExtensions(): Array<SyntaxExtension<UnistNode>> {\n    return (this.nodeExtensions() as Array<SyntaxExtension<UnistNode>>).concat(\n      this.markExtensions(),\n    );\n  }\n}\n","import type { Schema } from \"prosemirror-model\";\nimport type { Plugin } from \"prosemirror-state\";\n\nimport { type InputRule, inputRules } from \"prosemirror-inputrules\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class InputRulesBuilder {\n  private readonly rules: Array<InputRule>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.rules = ([] as Array<InputRule>).concat.apply(\n      [],\n      extensionManager\n        .syntaxExtensions()\n        .map((extension) => extension.proseMirrorInputRules(proseMirrorSchema)),\n    );\n  }\n\n  public build(): Plugin {\n    return inputRules({ rules: this.rules });\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"baseKeymap\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.baseKeymap), [\"chainCommands\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.chainCommands) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"keymap\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_keymap_62566a86__.keymap) });","import type { Schema } from \"prosemirror-model\";\nimport type { Command, Plugin } from \"prosemirror-state\";\n\nimport { baseKeymap, chainCommands } from \"prosemirror-commands\";\nimport { keymap } from \"prosemirror-keymap\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class KeymapBuilder {\n  private readonly keymap: Map<string, Array<Command>>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.keymap = new Map();\n    for (const extension of extensionManager.syntaxExtensions()) {\n      this.addKeymap(extension.proseMirrorKeymap(proseMirrorSchema));\n    }\n    this.addKeymap(baseKeymap);\n  }\n\n  private addKeymap(map: Record<string, Command>): void {\n    for (const key in map) {\n      if (!Object.prototype.hasOwnProperty.call(map, key)) {\n        continue;\n      }\n      if (!this.keymap.get(key)) {\n        this.keymap.set(key, []);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Set above.\n      this.keymap.get(key)!.push(map[key]);\n    }\n  }\n\n  public build(): Plugin {\n    const chainedKeymap: Record<string, Command> = {};\n    this.keymap.forEach((commands, key) => {\n      chainedKeymap[key] = chainCommands(...commands);\n    });\n    return keymap(chainedKeymap);\n  }\n}\n","import type { NodeViewConstructor } from \"prosemirror-view\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class NodeViewBuilder {\n  private readonly nodeViews: Record<string, NodeViewConstructor>;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.nodeViews = {};\n    for (const extension of extensionManager.nodeExtensions()) {\n      const proseMirrorNodeName = extension.proseMirrorNodeName();\n      const proseMirrorNodeView = extension.proseMirrorNodeView();\n      if (proseMirrorNodeName !== null && proseMirrorNodeView !== null) {\n        this.nodeViews[proseMirrorNodeName] = proseMirrorNodeView;\n      }\n    }\n  }\n\n  public build(): Record<string, NodeViewConstructor> {\n    return this.nodeViews;\n  }\n}\n","import type { Node as ProseMirrorNode } from \"prosemirror-model\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class ProseMirrorToUnistConverter {\n  private readonly extensionManager: ExtensionManager;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.extensionManager = extensionManager;\n  }\n\n  private convertNode(node: ProseMirrorNode): Array<UnistNode> {\n    let convertedNodes: Array<UnistNode> | null = null;\n    for (const extension of this.extensionManager.nodeExtensions()) {\n      if (!extension.proseMirrorToUnistTest(node)) {\n        continue;\n      }\n      let convertedChildren: Array<UnistNode> = [];\n      for (let i = 0; i < node.childCount; ++i) {\n        convertedChildren = convertedChildren.concat(\n          this.convertNode(node.child(i)),\n        );\n      }\n      convertedNodes = extension.proseMirrorNodeToUnistNodes(\n        node,\n        convertedChildren,\n      );\n    }\n    if (convertedNodes === null) {\n      // eslint-disable-next-line no-console -- Intended console warning\n      console.warn(\n        `Couldn't find any way to convert ProseMirror node of type \"${node.type.name}\" to a unist node.`,\n      );\n      return [];\n    }\n    return convertedNodes.map((convertedNode) => {\n      let postProcessedNode = convertedNode;\n      for (const mark of node.marks) {\n        let processed = false;\n        for (const extension of this.extensionManager.markExtensions()) {\n          if (mark.type.name === extension.proseMirrorMarkName()) {\n            postProcessedNode = extension.processConvertedUnistNode(\n              postProcessedNode,\n              mark,\n            );\n            processed = true;\n          }\n        }\n        if (!processed) {\n          // eslint-disable-next-line no-console -- Intended console warning\n          console.warn(\n            `Couldn't find any way to convert ProseMirror mark of type \"${mark.type.name}\" to a unist node.`,\n          );\n        }\n      }\n      return postProcessedNode;\n    });\n  }\n\n  public convert(node: ProseMirrorNode): UnistNode {\n    const rootNode = this.convertNode(node);\n    if (rootNode.length !== 1) {\n      throw new Error(\n        \"Couldn't find any way to convert the root ProseMirror node.\",\n      );\n    }\n    return rootNode[0];\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"Schema\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_model_701384b1__.Schema) });","import { type MarkSpec, type NodeSpec, Schema } from \"prosemirror-model\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class SchemaBuilder {\n  private readonly marks: Record<string, MarkSpec> = {};\n  private readonly nodes: Record<string, NodeSpec> = {};\n\n  public constructor(extensionManager: ExtensionManager) {\n    for (const extension of extensionManager.nodeExtensions()) {\n      const name = extension.proseMirrorNodeName();\n      const spec = extension.proseMirrorNodeSpec();\n      if (name !== null && spec !== null) {\n        this.nodes[name] = spec;\n      }\n    }\n    for (const extension of extensionManager.markExtensions()) {\n      const name = extension.proseMirrorMarkName();\n      const spec = extension.proseMirrorMarkSpec();\n      if (name !== null && spec !== null) {\n        this.marks[name] = spec;\n      }\n    }\n  }\n\n  public build(): Schema<string, string> {\n    return new Schema<string, string>({\n      marks: this.marks,\n      nodes: this.nodes,\n    });\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"unified\"]: () => (__WEBPACK_EXTERNAL_MODULE_unified__.unified) });","import type { Node as UnistNode } from \"unist\";\n\nimport { type Processor, unified } from \"unified\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class UnifiedBuilder {\n  private readonly extensionManager: ExtensionManager;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.extensionManager = extensionManager;\n  }\n\n  public build(): Processor<\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    string\n  > {\n    let processor = unified() as unknown as Processor<\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      string\n    >;\n    for (const extension of this.extensionManager.extensions()) {\n      processor = extension.unifiedInitializationHook(processor);\n    }\n    return processor;\n  }\n}\n","import type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Parent, Node as UnistNode } from \"unist\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class UnistToProseMirrorConverter {\n  private readonly extensionManager: ExtensionManager;\n  private readonly proseMirrorSchema: Schema<string, string>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.extensionManager = extensionManager;\n    this.proseMirrorSchema = proseMirrorSchema;\n  }\n\n  private static unistNodeIsParent(node: UnistNode): node is Parent {\n    return \"children\" in node;\n  }\n\n  private convertNode(\n    node: UnistNode,\n    context: Partial<unknown>,\n  ): Array<ProseMirrorNode> {\n    for (const extension of this.extensionManager.syntaxExtensions()) {\n      if (!extension.unistToProseMirrorTest(node)) {\n        continue;\n      }\n      let convertedChildren: Array<ProseMirrorNode> = [];\n      if (UnistToProseMirrorConverter.unistNodeIsParent(node)) {\n        convertedChildren = ([] as Array<ProseMirrorNode>).concat.apply(\n          [],\n          node.children.map((child) => this.convertNode(child, context)),\n        );\n      }\n      return extension.unistNodeToProseMirrorNodes(\n        node,\n        this.proseMirrorSchema,\n        convertedChildren,\n        context,\n      );\n    }\n    // eslint-disable-next-line no-console -- Intended console warning\n    console.warn(\n      `Couldn't find any way to convert unist node of type \"${node.type}\" to a ProseMirror node.`,\n    );\n    return [];\n  }\n\n  public convert(unist: UnistNode): ProseMirrorNode {\n    const context: Partial<unknown> = {};\n    const rootNode = this.convertNode(unist, context);\n    for (const extension of this.extensionManager.syntaxExtensions()) {\n      extension.postUnistToProseMirrorHook(context);\n    }\n    if (rootNode.length !== 1) {\n      throw new Error(\"Couldn't find any way to convert the root unist node.\");\n    }\n    return rootNode[0];\n  }\n}\n","import type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Plugin } from \"prosemirror-state\";\nimport type { NodeViewConstructor } from \"prosemirror-view\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport type { Extension } from \"./Extension\";\n\nimport { ExtensionManager } from \"./ExtensionManager\";\nimport { InputRulesBuilder } from \"./InputRulesBuilder\";\nimport { KeymapBuilder } from \"./KeymapBuilder\";\nimport { NodeViewBuilder } from \"./NodeViewBuilder\";\nimport { ProseMirrorToUnistConverter } from \"./ProseMirrorToUnistConverter\";\nimport { SchemaBuilder } from \"./SchemaBuilder\";\nimport { UnifiedBuilder } from \"./UnifiedBuilder\";\nimport { UnistToProseMirrorConverter } from \"./UnistToProseMirrorConverter\";\n\n/**\n * @public\n */\nexport class ProseMirrorUnified {\n  private readonly builtSchema: Schema<string, string>;\n  private readonly inputRulesBuilder: InputRulesBuilder;\n  private readonly keymapBuilder: KeymapBuilder;\n  private readonly nodeViewBuilder: NodeViewBuilder;\n  private readonly proseMirrorToUnistConverter: ProseMirrorToUnistConverter;\n  private readonly unified: Processor<\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    string\n  >;\n  private readonly unistToProseMirrorConverter: UnistToProseMirrorConverter;\n\n  public constructor(extensions: Array<Extension> = []) {\n    const extensionManager = new ExtensionManager(extensions);\n    this.builtSchema = new SchemaBuilder(extensionManager).build();\n    this.inputRulesBuilder = new InputRulesBuilder(\n      extensionManager,\n      this.builtSchema,\n    );\n    this.keymapBuilder = new KeymapBuilder(extensionManager, this.builtSchema);\n    this.nodeViewBuilder = new NodeViewBuilder(extensionManager);\n    this.unistToProseMirrorConverter = new UnistToProseMirrorConverter(\n      extensionManager,\n      this.builtSchema,\n    );\n    this.proseMirrorToUnistConverter = new ProseMirrorToUnistConverter(\n      extensionManager,\n    );\n    this.unified = new UnifiedBuilder(extensionManager).build();\n  }\n\n  public inputRulesPlugin(): Plugin {\n    return this.inputRulesBuilder.build();\n  }\n\n  public keymapPlugin(): Plugin {\n    return this.keymapBuilder.build();\n  }\n\n  public nodeViews(): Record<string, NodeViewConstructor> {\n    return this.nodeViewBuilder.build();\n  }\n\n  public parse(source: string): ProseMirrorNode {\n    const unist = this.unified.runSync(this.unified.parse(source));\n    const ret = this.unistToProseMirrorConverter.convert(unist);\n    return ret;\n  }\n\n  public schema(): Schema<string, string> {\n    return this.builtSchema;\n  }\n\n  public serialize(doc: ProseMirrorNode): string {\n    const unist = this.proseMirrorToUnistConverter.convert(doc);\n    const source: string = this.unified.stringify(unist);\n    return source;\n  }\n}\n","export { createProseMirrorNode } from \"./createProseMirrorNode\";\nexport { Extension } from \"./Extension\";\nexport { MarkExtension } from \"./MarkExtension\";\nexport { MarkInputRule } from \"./MarkInputRule\";\nexport { NodeExtension } from \"./NodeExtension\";\nexport { ProseMirrorUnified } from \"./ProseMirrorUnified\";\nexport { SyntaxExtension } from \"./SyntaxExtension\";\n"],"names":[],"sourceRoot":""}
\ No newline at end of file
+{"version":3,"file":"prosemirror-unified.js","sources":["../src/createProseMirrorNode.ts","../src/Extension.ts","../src/SyntaxExtension.ts","../src/MarkExtension.ts","../src/MarkInputRule.ts","../src/NodeExtension.ts","../src/ExtensionManager.ts","../src/InputRulesBuilder.ts","../src/KeymapBuilder.ts","../src/NodeViewBuilder.ts","../src/ProseMirrorToUnistConverter.ts","../src/SchemaBuilder.ts","../src/UnifiedBuilder.ts","../src/UnistToProseMirrorConverter.ts","../src/ProseMirrorUnified.ts"],"sourcesContent":["import type { Attrs, Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\n/**\n * @public\n */\nexport function createProseMirrorNode(\n  nodeName: string | null,\n  schema: Schema<string, string>,\n  children: Array<ProseMirrorNode>,\n  attrs: Attrs = {},\n): Array<ProseMirrorNode> {\n  if (nodeName === null) {\n    return [];\n  }\n  const proseMirrorNode = schema.nodes[nodeName].createAndFill(attrs, children);\n  if (proseMirrorNode === null) {\n    return [];\n  }\n  return [proseMirrorNode];\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\n/**\n * @public\n */\nexport abstract class Extension {\n  /* eslint-disable @typescript-eslint/class-methods-use-this -- Invalid for interfaces */\n  public dependencies(): Array<Extension> {\n    return [];\n  }\n\n  public unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor;\n  }\n  /* eslint-enable */\n}\n","import type { InputRule } from \"prosemirror-inputrules\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { Extension } from \"./Extension\";\n\n/**\n * @public\n */\nexport abstract class SyntaxExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends Extension {\n  /* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/class-methods-use-this, @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars -- These are invalid for interfaces */\n  public postUnistToProseMirrorHook(\n    // @ts-ignore-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    context: Partial<UnistToProseMirrorContext>,\n  ): void {}\n\n  public proseMirrorInputRules(\n    // @ts-ignore-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [];\n  }\n\n  public proseMirrorKeymap(\n    // @ts-ignore-error: TS6133 causes an error because of an unused parameter - however, this method is meant to be overriden\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {};\n  }\n  /* eslint-enable */\n\n  public abstract unistNodeName(): UNode[\"type\"];\n\n  public abstract unistNodeToProseMirrorNodes(\n    node: UNode,\n    schema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<UnistToProseMirrorContext>,\n  ): Array<ProseMirrorNode>;\n\n  public unistToProseMirrorTest(node: UnistNode): boolean {\n    return node.type === this.unistNodeName();\n  }\n}\n","import type { Mark, MarkSpec } from \"prosemirror-model\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { SyntaxExtension } from \"./SyntaxExtension\";\n\n/**\n * @public\n */\nexport abstract class MarkExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends SyntaxExtension<UNode, UnistToProseMirrorContext> {\n  public abstract processConvertedUnistNode(\n    convertedNode: UnistNode,\n    originalMark: Mark,\n  ): UNode;\n\n  public abstract proseMirrorMarkName(): string | null;\n\n  public abstract proseMirrorMarkSpec(): MarkSpec | null;\n}\n","import type { MarkType, Node as ProseMirrorNode } from \"prosemirror-model\";\n\nimport { InputRule } from \"prosemirror-inputrules\";\nimport {\n  type EditorState,\n  SelectionRange,\n  TextSelection,\n  type Transaction,\n} from \"prosemirror-state\";\n\n/**\n * @public\n */\nexport class MarkInputRule extends InputRule {\n  private readonly markType: MarkType;\n\n  public constructor(matcher: RegExp, markType: MarkType) {\n    super(matcher, (state, match, start, end) =>\n      this.markHandler(state, match, start, end),\n    );\n    this.markType = markType;\n  }\n\n  private static markApplies(\n    doc: ProseMirrorNode,\n    ranges: Array<SelectionRange>,\n    type: MarkType,\n  ): boolean {\n    for (const range of ranges) {\n      const { $from, $to } = range;\n      let applies = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n      doc.nodesBetween($from.pos, $to.pos, (node) => {\n        if (applies) {\n          return false;\n        }\n        applies = node.inlineContent && node.type.allowsMarkType(type);\n        return true;\n      });\n      if (applies) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private markHandler(\n    state: EditorState,\n    match: RegExpMatchArray,\n    start: number,\n    end: number,\n  ): Transaction | null {\n    if (!(state.selection instanceof TextSelection)) {\n      return null;\n    }\n\n    // Determine if mark applies to match\n    const $start = state.doc.resolve(start);\n    const $end = state.doc.resolve(end);\n    const range = [new SelectionRange($start, $end)];\n\n    if (!MarkInputRule.markApplies(state.doc, range, this.markType)) {\n      return null;\n    }\n\n    // List all existing marks and add the new one\n    const newMarks =\n      state.doc.nodeAt(start)?.marks.map((mark) => mark.type) ?? [];\n    newMarks.push(this.markType);\n\n    // Extract the inner content and the trailing part from the match result;\n    let inner = \"\";\n    let trailing = \"\";\n\n    if (match.groups) {\n      ({ i: inner, t: trailing } = match.groups);\n    } else {\n      ({ 1: inner, 2: trailing } = match);\n    }\n\n    // Replace the affected range with the matched text - this removes e.g. the asterisks around italic\n    const tr = state.tr.replaceWith(\n      start,\n      end,\n      this.markType.schema.text(inner),\n    );\n\n    // Add back all marks, including the new one\n    for (const markType of newMarks) {\n      tr.addMark(\n        tr.mapping.map(start),\n        tr.mapping.map(end),\n        markType.create(null),\n      );\n    }\n\n    // Make the text editor insert clean text with no marks on next input\n    for (const markType of newMarks) {\n      tr.removeStoredMark(markType);\n    }\n\n    // Add back the last character if it is not a newline,\n    // otherwise omit it because newline is handled out of the text node.\n    if (trailing !== \"\\n\") {\n      tr.insertText(trailing);\n    }\n\n    return tr;\n  }\n}\n","import type { NodeSpec, Node as ProseMirrorNode } from \"prosemirror-model\";\nimport type { NodeViewConstructor } from \"prosemirror-view\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { SyntaxExtension } from \"./SyntaxExtension\";\n\n/**\n * @public\n */\nexport abstract class NodeExtension<\n  UNode extends UnistNode,\n  UnistToProseMirrorContext extends Record<string, unknown> = Record<\n    string,\n    never\n  >,\n> extends SyntaxExtension<UNode, UnistToProseMirrorContext> {\n  public abstract proseMirrorNodeName(): string | null;\n\n  public abstract proseMirrorNodeSpec(): NodeSpec | null;\n\n  public abstract proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<UnistNode>,\n  ): Array<UNode>;\n\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inalid for an interface\n  public proseMirrorNodeView(): NodeViewConstructor | null {\n    return null;\n  }\n\n  public proseMirrorToUnistTest(node: ProseMirrorNode): boolean {\n    return this.proseMirrorNodeName() === node.type.name;\n  }\n}\n","import type { Node as UnistNode } from \"unist\";\n\nimport type { Extension } from \"./Extension\";\nimport type { SyntaxExtension } from \"./SyntaxExtension\";\n\nimport { MarkExtension } from \"./MarkExtension\";\nimport { NodeExtension } from \"./NodeExtension\";\n\nexport class ExtensionManager {\n  private readonly markExtensionList: Map<string, MarkExtension<UnistNode>>;\n  private readonly nodeExtensionList: Map<string, NodeExtension<UnistNode>>;\n  private readonly otherExtensionList: Map<string, Extension>;\n\n  public constructor(extensions: Array<Extension>) {\n    this.markExtensionList = new Map();\n    this.nodeExtensionList = new Map();\n    this.otherExtensionList = new Map();\n\n    for (const extension of extensions) {\n      this.add(extension);\n    }\n  }\n\n  public extensions(): Array<Extension> {\n    return (this.syntaxExtensions() as Array<Extension>).concat(\n      Array.from(this.otherExtensionList.values()),\n    );\n  }\n\n  public markExtensions(): Array<MarkExtension<UnistNode>> {\n    return Array.from(this.markExtensionList.values());\n  }\n\n  public nodeExtensions(): Array<NodeExtension<UnistNode>> {\n    return Array.from(this.nodeExtensionList.values());\n  }\n\n  public syntaxExtensions(): Array<SyntaxExtension<UnistNode>> {\n    return (this.nodeExtensions() as Array<SyntaxExtension<UnistNode>>).concat(\n      this.markExtensions(),\n    );\n  }\n\n  private add(extension: Extension): void {\n    for (const dependency of extension.dependencies()) {\n      this.add(dependency);\n    }\n\n    if (isMarkExtension(extension)) {\n      this.markExtensionList.set(extension.constructor.name, extension);\n      return;\n    }\n    if (isNodeExtension(extension)) {\n      this.nodeExtensionList.set(extension.constructor.name, extension);\n      return;\n    }\n    this.otherExtensionList.set(extension.constructor.name, extension);\n  }\n}\n\nfunction isMarkExtension(\n  extension: Extension,\n): extension is MarkExtension<UnistNode> {\n  return extension instanceof MarkExtension;\n}\n\nfunction isNodeExtension(\n  extension: Extension,\n): extension is NodeExtension<UnistNode> {\n  return extension instanceof NodeExtension;\n}\n","import type { Schema } from \"prosemirror-model\";\nimport type { Plugin } from \"prosemirror-state\";\n\nimport { type InputRule, inputRules } from \"prosemirror-inputrules\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class InputRulesBuilder {\n  private readonly rules: Array<InputRule>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.rules = ([] as Array<InputRule>).concat.apply(\n      [],\n      extensionManager\n        .syntaxExtensions()\n        .map((extension) => extension.proseMirrorInputRules(proseMirrorSchema)),\n    );\n  }\n\n  public build(): Plugin {\n    const inputRulesPlugin = inputRules({ rules: this.rules });\n    const originalHandleKeyDown =\n      inputRulesPlugin.props.handleKeyDown?.bind(inputRulesPlugin);\n    const customHandleKeyDown: Exclude<\n      typeof originalHandleKeyDown,\n      undefined\n    > = (view, event) => {\n      if (event.key === \"Enter\") {\n        const { from, to } = view.state.selection;\n        inputRulesPlugin.props.handleTextInput?.call(\n          inputRulesPlugin,\n          view,\n          from,\n          to,\n          \"\\n\",\n        );\n      }\n      return originalHandleKeyDown?.(view, event);\n    };\n    inputRulesPlugin.props.handleKeyDown = customHandleKeyDown;\n    return inputRulesPlugin;\n  }\n}\n","import type { Schema } from \"prosemirror-model\";\nimport type { Command, Plugin } from \"prosemirror-state\";\n\nimport { baseKeymap, chainCommands } from \"prosemirror-commands\";\nimport { keymap } from \"prosemirror-keymap\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class KeymapBuilder {\n  private readonly keymap: Map<string, Array<Command>>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.keymap = new Map();\n    for (const extension of extensionManager.syntaxExtensions()) {\n      this.addKeymap(extension.proseMirrorKeymap(proseMirrorSchema));\n    }\n    this.addKeymap(baseKeymap);\n  }\n\n  public build(): Plugin {\n    const chainedKeymap: Record<string, Command> = {};\n    this.keymap.forEach((commands, key) => {\n      chainedKeymap[key] = chainCommands(...commands);\n    });\n    return keymap(chainedKeymap);\n  }\n\n  private addKeymap(map: Record<string, Command>): void {\n    for (const key in map) {\n      if (!Object.prototype.hasOwnProperty.call(map, key)) {\n        continue;\n      }\n      if (!this.keymap.get(key)) {\n        this.keymap.set(key, []);\n      }\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- Set above.\n      this.keymap.get(key)!.push(map[key]);\n    }\n  }\n}\n","import type { NodeViewConstructor } from \"prosemirror-view\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class NodeViewBuilder {\n  private readonly nodeViews: Record<string, NodeViewConstructor>;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.nodeViews = {};\n    for (const extension of extensionManager.nodeExtensions()) {\n      const proseMirrorNodeName = extension.proseMirrorNodeName();\n      const proseMirrorNodeView = extension.proseMirrorNodeView();\n      if (proseMirrorNodeName !== null && proseMirrorNodeView !== null) {\n        this.nodeViews[proseMirrorNodeName] = proseMirrorNodeView;\n      }\n    }\n  }\n\n  public build(): Record<string, NodeViewConstructor> {\n    return this.nodeViews;\n  }\n}\n","import type { Node as ProseMirrorNode } from \"prosemirror-model\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class ProseMirrorToUnistConverter {\n  private readonly extensionManager: ExtensionManager;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.extensionManager = extensionManager;\n  }\n\n  public convert(node: ProseMirrorNode): UnistNode {\n    const rootNode = this.convertNode(node);\n    if (rootNode.length !== 1) {\n      throw new Error(\n        \"Couldn't find any way to convert the root ProseMirror node.\",\n      );\n    }\n    return rootNode[0];\n  }\n\n  private convertNode(node: ProseMirrorNode): Array<UnistNode> {\n    let convertedNodes: Array<UnistNode> | null = null;\n    for (const extension of this.extensionManager.nodeExtensions()) {\n      if (!extension.proseMirrorToUnistTest(node)) {\n        continue;\n      }\n      let convertedChildren: Array<UnistNode> = [];\n      for (let i = 0; i < node.childCount; ++i) {\n        convertedChildren = convertedChildren.concat(\n          this.convertNode(node.child(i)),\n        );\n      }\n      convertedNodes = extension.proseMirrorNodeToUnistNodes(\n        node,\n        convertedChildren,\n      );\n    }\n    if (convertedNodes === null) {\n      // eslint-disable-next-line no-console -- Intended console warning\n      console.warn(\n        `Couldn't find any way to convert ProseMirror node of type \"${node.type.name}\" to a unist node.`,\n      );\n      return [];\n    }\n    return convertedNodes.map((convertedNode) => {\n      let postProcessedNode = convertedNode;\n      for (const mark of node.marks) {\n        let processed = false;\n        for (const extension of this.extensionManager.markExtensions()) {\n          if (mark.type.name === extension.proseMirrorMarkName()) {\n            postProcessedNode = extension.processConvertedUnistNode(\n              postProcessedNode,\n              mark,\n            );\n            processed = true;\n          }\n        }\n        if (!processed) {\n          // eslint-disable-next-line no-console -- Intended console warning\n          console.warn(\n            `Couldn't find any way to convert ProseMirror mark of type \"${mark.type.name}\" to a unist node.`,\n          );\n        }\n      }\n      return postProcessedNode;\n    });\n  }\n}\n","import { type MarkSpec, type NodeSpec, Schema } from \"prosemirror-model\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class SchemaBuilder {\n  private readonly marks: Record<string, MarkSpec> = {};\n  private readonly nodes: Record<string, NodeSpec> = {};\n\n  public constructor(extensionManager: ExtensionManager) {\n    for (const extension of extensionManager.nodeExtensions()) {\n      const name = extension.proseMirrorNodeName();\n      const spec = extension.proseMirrorNodeSpec();\n      if (name !== null && spec !== null) {\n        this.nodes[name] = spec;\n      }\n    }\n    for (const extension of extensionManager.markExtensions()) {\n      const name = extension.proseMirrorMarkName();\n      const spec = extension.proseMirrorMarkSpec();\n      if (name !== null && spec !== null) {\n        this.marks[name] = spec;\n      }\n    }\n  }\n\n  public build(): Schema<string, string> {\n    return new Schema<string, string>({\n      marks: this.marks,\n      nodes: this.nodes,\n    });\n  }\n}\n","import type { Node as UnistNode } from \"unist\";\n\nimport { type Processor, unified } from \"unified\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class UnifiedBuilder {\n  private readonly extensionManager: ExtensionManager;\n\n  public constructor(extensionManager: ExtensionManager) {\n    this.extensionManager = extensionManager;\n  }\n\n  public build(): Processor<\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    string\n  > {\n    let processor = unified() as unknown as Processor<\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      string\n    >;\n    for (const extension of this.extensionManager.extensions()) {\n      processor = extension.unifiedInitializationHook(processor);\n    }\n    return processor;\n  }\n}\n","import type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Parent, Node as UnistNode } from \"unist\";\n\nimport type { ExtensionManager } from \"./ExtensionManager\";\n\nexport class UnistToProseMirrorConverter {\n  private readonly extensionManager: ExtensionManager;\n  private readonly proseMirrorSchema: Schema<string, string>;\n\n  public constructor(\n    extensionManager: ExtensionManager,\n    proseMirrorSchema: Schema<string, string>,\n  ) {\n    this.extensionManager = extensionManager;\n    this.proseMirrorSchema = proseMirrorSchema;\n  }\n\n  private static unistNodeIsParent(node: UnistNode): node is Parent {\n    return \"children\" in node;\n  }\n\n  public convert(unist: UnistNode): ProseMirrorNode {\n    const context: Partial<unknown> = {};\n    const rootNode = this.convertNode(unist, context);\n    for (const extension of this.extensionManager.syntaxExtensions()) {\n      extension.postUnistToProseMirrorHook(context);\n    }\n    if (rootNode.length !== 1) {\n      throw new Error(\"Couldn't find any way to convert the root unist node.\");\n    }\n    return rootNode[0];\n  }\n\n  private convertNode(\n    node: UnistNode,\n    context: Partial<unknown>,\n  ): Array<ProseMirrorNode> {\n    for (const extension of this.extensionManager.syntaxExtensions()) {\n      if (!extension.unistToProseMirrorTest(node)) {\n        continue;\n      }\n      let convertedChildren: Array<ProseMirrorNode> = [];\n      if (UnistToProseMirrorConverter.unistNodeIsParent(node)) {\n        convertedChildren = ([] as Array<ProseMirrorNode>).concat.apply(\n          [],\n          node.children.map((child) => this.convertNode(child, context)),\n        );\n      }\n      return extension.unistNodeToProseMirrorNodes(\n        node,\n        this.proseMirrorSchema,\n        convertedChildren,\n        context,\n      );\n    }\n    // eslint-disable-next-line no-console -- Intended console warning\n    console.warn(\n      `Couldn't find any way to convert unist node of type \"${node.type}\" to a ProseMirror node.`,\n    );\n    return [];\n  }\n}\n","import type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\nimport type { Plugin } from \"prosemirror-state\";\nimport type { NodeViewConstructor } from \"prosemirror-view\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport type { Extension } from \"./Extension\";\n\nimport { ExtensionManager } from \"./ExtensionManager\";\nimport { InputRulesBuilder } from \"./InputRulesBuilder\";\nimport { KeymapBuilder } from \"./KeymapBuilder\";\nimport { NodeViewBuilder } from \"./NodeViewBuilder\";\nimport { ProseMirrorToUnistConverter } from \"./ProseMirrorToUnistConverter\";\nimport { SchemaBuilder } from \"./SchemaBuilder\";\nimport { UnifiedBuilder } from \"./UnifiedBuilder\";\nimport { UnistToProseMirrorConverter } from \"./UnistToProseMirrorConverter\";\n\n/**\n * @public\n */\nexport class ProseMirrorUnified {\n  private readonly builtSchema: Schema<string, string>;\n  private readonly inputRulesBuilder: InputRulesBuilder;\n  private readonly keymapBuilder: KeymapBuilder;\n  private readonly nodeViewBuilder: NodeViewBuilder;\n  private readonly proseMirrorToUnistConverter: ProseMirrorToUnistConverter;\n  private readonly unified: Processor<\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    UnistNode,\n    string\n  >;\n  private readonly unistToProseMirrorConverter: UnistToProseMirrorConverter;\n\n  public constructor(extensions: Array<Extension> = []) {\n    const extensionManager = new ExtensionManager(extensions);\n    this.builtSchema = new SchemaBuilder(extensionManager).build();\n    this.inputRulesBuilder = new InputRulesBuilder(\n      extensionManager,\n      this.builtSchema,\n    );\n    this.keymapBuilder = new KeymapBuilder(extensionManager, this.builtSchema);\n    this.nodeViewBuilder = new NodeViewBuilder(extensionManager);\n    this.unistToProseMirrorConverter = new UnistToProseMirrorConverter(\n      extensionManager,\n      this.builtSchema,\n    );\n    this.proseMirrorToUnistConverter = new ProseMirrorToUnistConverter(\n      extensionManager,\n    );\n    this.unified = new UnifiedBuilder(extensionManager).build();\n  }\n\n  public inputRulesPlugin(): Plugin {\n    return this.inputRulesBuilder.build();\n  }\n\n  public keymapPlugin(): Plugin {\n    return this.keymapBuilder.build();\n  }\n\n  public nodeViews(): Record<string, NodeViewConstructor> {\n    return this.nodeViewBuilder.build();\n  }\n\n  public parse(source: string): ProseMirrorNode {\n    const unist = this.unified.runSync(this.unified.parse(source));\n    const ret = this.unistToProseMirrorConverter.convert(unist);\n    return ret;\n  }\n\n  public schema(): Schema<string, string> {\n    return this.builtSchema;\n  }\n\n  public serialize(doc: ProseMirrorNode): string {\n    const unist = this.proseMirrorToUnistConverter.convert(doc);\n    const source: string = this.unified.stringify(unist);\n    return source;\n  }\n}\n"],"names":["_a"],"mappings":"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"}
