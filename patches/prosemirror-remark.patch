diff --git a/dist/prosemirror-remark.cjs b/dist/prosemirror-remark.cjs
index 3c4db50665a49fde8b5561e09369cd65335d7552..11236ad2c73ac9097a35f97609fd9ed4335f606a 100644
--- a/dist/prosemirror-remark.cjs
+++ b/dist/prosemirror-remark.cjs
@@ -1,1631 +1,1112 @@
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__ from "prosemirror-unified";
-import * as __WEBPACK_EXTERNAL_MODULE_remark_parse_76724963__ from "remark-parse";
-import * as __WEBPACK_EXTERNAL_MODULE_remark_stringify_a28ae2a6__ from "remark-stringify";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__ from "prosemirror-commands";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__ from "prosemirror-inputrules";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__ from "prosemirror-state";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__ from "prosemirror-schema-list";
-/******/ // The require scope
-/******/ var __webpack_require__ = {};
-/******/ 
-/************************************************************************/
-/******/ /* webpack/runtime/define property getters */
-/******/ (() => {
-/******/ 	// define getter functions for harmony exports
-/******/ 	__webpack_require__.d = (exports, definition) => {
-/******/ 		for(var key in definition) {
-/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
-/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
-/******/ 			}
-/******/ 		}
-/******/ 	};
-/******/ })();
-/******/ 
-/******/ /* webpack/runtime/hasOwnProperty shorthand */
-/******/ (() => {
-/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
-/******/ })();
-/******/ 
-/******/ /* webpack/runtime/make namespace object */
-/******/ (() => {
-/******/ 	// define __esModule on exports
-/******/ 	__webpack_require__.r = (exports) => {
-/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
-/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
-/******/ 		}
-/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
-/******/ 	};
-/******/ })();
-/******/ 
-/************************************************************************/
-var __webpack_exports__ = {};
-// ESM COMPAT FLAG
-__webpack_require__.r(__webpack_exports__);
-
-// EXPORTS
-__webpack_require__.d(__webpack_exports__, {
-  BlockquoteExtension: () => (/* reexport */ BlockquoteExtension),
-  BoldExtension: () => (/* reexport */ BoldExtension),
-  BreakExtension: () => (/* reexport */ BreakExtension),
-  CodeBlockExtension: () => (/* reexport */ CodeBlockExtension),
-  DefinitionExtension: () => (/* reexport */ DefinitionExtension),
-  ExtendedAutolinkExtension: () => (/* reexport */ ExtendedAutolinkExtension),
-  GFMExtension: () => (/* reexport */ GFMExtension),
-  HeadingExtension: () => (/* reexport */ HeadingExtension),
-  HorizontalRuleExtension: () => (/* reexport */ HorizontalRuleExtension),
-  ImageExtension: () => (/* reexport */ ImageExtension),
-  ImageReferenceExtension: () => (/* reexport */ ImageReferenceExtension),
-  InlineCodeExtension: () => (/* reexport */ InlineCodeExtension),
-  ItalicExtension: () => (/* reexport */ ItalicExtension),
-  LinkExtension: () => (/* reexport */ LinkExtension),
-  LinkReferenceExtension: () => (/* reexport */ LinkReferenceExtension),
-  ListItemExtension: () => (/* reexport */ ListItemExtension),
-  MarkdownExtension: () => (/* reexport */ MarkdownExtension),
-  OrderedListExtension: () => (/* reexport */ OrderedListExtension),
-  ParagraphExtension: () => (/* reexport */ ParagraphExtension),
-  RootExtension: () => (/* reexport */ RootExtension),
-  StrikethroughExtension: () => (/* reexport */ StrikethroughExtension),
-  TaskListItemExtension: () => (/* reexport */ TaskListItemExtension),
-  TextExtension: () => (/* reexport */ TextExtension),
-  UnorderedListExtension: () => (/* reexport */ UnorderedListExtension)
-});
-
-;// CONCATENATED MODULE: external "prosemirror-unified"
-var x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var y = (x) => (() => (x))
-const external_prosemirror_unified_namespaceObject = x({ ["Extension"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.Extension), ["MarkExtension"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.MarkExtension), ["MarkInputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.MarkInputRule), ["NodeExtension"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.NodeExtension), ["createProseMirrorNode"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.createProseMirrorNode) });
-;// CONCATENATED MODULE: external "remark-parse"
-var external_remark_parse_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_remark_parse_y = (x) => (() => (x))
-const external_remark_parse_namespaceObject = external_remark_parse_x({ ["default"]: () => (__WEBPACK_EXTERNAL_MODULE_remark_parse_76724963__["default"]) });
-;// CONCATENATED MODULE: external "remark-stringify"
-var external_remark_stringify_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_remark_stringify_y = (x) => (() => (x))
-const external_remark_stringify_namespaceObject = external_remark_stringify_x({ ["default"]: () => (__WEBPACK_EXTERNAL_MODULE_remark_stringify_a28ae2a6__["default"]) });
-;// CONCATENATED MODULE: external "prosemirror-commands"
-var external_prosemirror_commands_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_commands_y = (x) => (() => (x))
-const external_prosemirror_commands_namespaceObject = external_prosemirror_commands_x({ ["chainCommands"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.chainCommands), ["exitCode"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.exitCode), ["setBlockType"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.setBlockType), ["toggleMark"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.toggleMark), ["wrapIn"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.wrapIn) });
-;// CONCATENATED MODULE: external "prosemirror-inputrules"
-var external_prosemirror_inputrules_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_inputrules_y = (x) => (() => (x))
-const external_prosemirror_inputrules_namespaceObject = external_prosemirror_inputrules_x({ ["InputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.InputRule), ["textblockTypeInputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.textblockTypeInputRule), ["wrappingInputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.wrappingInputRule) });
-;// CONCATENATED MODULE: ./src/syntax-extensions/BlockquoteExtension.ts
-
-
-
-/**
- * @public
- */
-class BlockquoteExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.wrappingInputRule)(/^\s{0,3}>\s$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            "Mod->": (0,external_prosemirror_commands_namespaceObject.wrapIn)(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        };
-    }
-    proseMirrorNodeName() {
-        return "blockquote";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            content: "block+",
-            group: "block",
-            parseDOM: [{ tag: "blockquote" }],
-            toDOM() {
-                return ["blockquote", 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [
-            {
-                children: convertedChildren,
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "blockquote";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/BoldExtension.ts
-
-
-/**
- * @public
- */
-class BoldExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode) {
-        return { children: [convertedNode], type: this.unistNodeName() };
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/\*\*([^\s](?:.*[^\s])?)\*\*([\s\S])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/__([^\s](?:.*[^\s])?)__([\s\S])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
-        return {
-            "Mod-b": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-            "Mod-B": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-        };
-    }
-    proseMirrorMarkName() {
-        return "strong";
-    }
-    proseMirrorMarkSpec() {
-        return {
-            parseDOM: [
-                { tag: "b" },
-                { tag: "strong" },
-                {
-                    getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/u.test(value) && null,
-                    style: "font-weight",
-                },
-            ],
-            toDOM() {
-                return ["strong"];
-            },
-        };
-    }
-    unistNodeName() {
-        return "strong";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return convertedChildren.map((child) => child.mark(child.marks.concat([
-            proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),
-        ])));
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/BreakExtension.ts
-
-
-/**
- * @public
- */
-class BreakExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorKeymap(proseMirrorSchema) {
-        const command = (0,external_prosemirror_commands_namespaceObject.chainCommands)(external_prosemirror_commands_namespaceObject.exitCode, (state, dispatch) => {
-            if (dispatch) {
-                dispatch(state.tr
-                    .replaceSelectionWith(proseMirrorSchema.nodes[this.proseMirrorNodeName()].create())
-                    .scrollIntoView());
-            }
-            return true;
-        });
-        const isMac = typeof navigator !== "undefined"
-            ? /Mac|iP(hone|[oa]d)/u.test(navigator.platform) // eslint-disable-line @typescript-eslint/no-deprecated -- In the tested systems, it will be defined
-            : false;
-        return Object.assign({ "Mod-Enter": command, "Shift-Enter": command }, (isMac && { "Ctrl-Enter": command }));
-    }
-    proseMirrorNodeName() {
-        return "hard_break";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            group: "inline",
-            inline: true,
-            parseDOM: [{ tag: "br" }],
-            selectable: false,
-            toDOM() {
-                return ["br"];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes() {
-        return [{ type: this.unistNodeName() }];
-    }
-    unistNodeName() {
-        return "break";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
+"use strict";
+Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
+const prosemirrorUnified = require("prosemirror-unified");
+const remarkParse = require("remark-parse");
+const remarkStringify = require("remark-stringify");
+const prosemirrorCommands = require("prosemirror-commands");
+const prosemirrorInputrules = require("prosemirror-inputrules");
+const prosemirrorState = require("prosemirror-state");
+const prosemirrorSchemaList = require("prosemirror-schema-list");
+class BlockquoteExtension extends prosemirrorUnified.NodeExtension {
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      prosemirrorInputrules.wrappingInputRule(
+        /^\s{0,3}>\s$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      "Mod->": prosemirrorCommands.wrapIn(proseMirrorSchema.nodes[this.proseMirrorNodeName()])
+    };
+  }
+  proseMirrorNodeName() {
+    return "blockquote";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      content: "block+",
+      group: "block",
+      parseDOM: [{ tag: "blockquote" }],
+      toDOM() {
+        return ["blockquote", 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [
+      {
+        children: convertedChildren,
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "blockquote";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
+}
+class BoldExtension extends prosemirrorUnified.MarkExtension {
+  processConvertedUnistNode(convertedNode) {
+    return { children: [convertedNode], type: this.unistNodeName() };
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new prosemirrorUnified.MarkInputRule(
+        /\*\*([^\s](?:.*[^\s])?)\*\*([\s\S])$/u,
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      ),
+      new prosemirrorUnified.MarkInputRule(
+        /__([^\s](?:.*[^\s])?)__([\s\S])$/u,
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
+    return {
+      "Mod-b": prosemirrorCommands.toggleMark(markType),
+      "Mod-B": prosemirrorCommands.toggleMark(markType)
+    };
+  }
+  proseMirrorMarkName() {
+    return "strong";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      parseDOM: [
+        { tag: "b" },
+        { tag: "strong" },
+        {
+          getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/u.test(value) && null,
+          style: "font-weight"
+        }
+      ],
+      toDOM() {
+        return ["strong", 0];
+      }
+    };
+  }
+  unistNodeName() {
+    return "strong";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return convertedChildren.map(
+      (child) => child.mark(
+        child.marks.concat([
+          proseMirrorSchema.marks[this.proseMirrorMarkName()].create()
+        ])
+      )
+    );
+  }
+}
+class BreakExtension extends prosemirrorUnified.NodeExtension {
+  proseMirrorKeymap(proseMirrorSchema) {
+    const command = prosemirrorCommands.chainCommands(prosemirrorCommands.exitCode, (state, dispatch) => {
+      if (dispatch) {
+        dispatch(
+          state.tr.replaceSelectionWith(
+            proseMirrorSchema.nodes[this.proseMirrorNodeName()].create()
+          ).scrollIntoView()
+        );
+      }
+      return true;
+    });
+    const isMac = typeof navigator !== "undefined" ? /Mac|iP(hone|[oa]d)/u.test(navigator.platform) : false;
+    return {
+      "Mod-Enter": command,
+      "Shift-Enter": command,
+      ...isMac && { "Ctrl-Enter": command }
+    };
+  }
+  proseMirrorNodeName() {
+    return "hard_break";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      group: "inline",
+      inline: true,
+      parseDOM: [{ tag: "br" }],
+      selectable: false,
+      toDOM() {
+        return ["br"];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes() {
+    return [{ type: this.unistNodeName() }];
+  }
+  unistNodeName() {
+    return "break";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
 }
-
-;// CONCATENATED MODULE: external "prosemirror-state"
-var external_prosemirror_state_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_state_y = (x) => (() => (x))
-const external_prosemirror_state_namespaceObject = external_prosemirror_state_x({ ["Selection"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.Selection) });
-;// CONCATENATED MODULE: ./src/syntax-extensions/TextExtension.ts
-
-/**
- * @public
- */
-class TextExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorNodeName() {
-        return "text";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            group: "inline",
-        };
-    }
-    proseMirrorNodeToUnistNodes(node) {
-        var _a;
-        return [{ type: this.unistNodeName(), value: (_a = node.text) !== null && _a !== void 0 ? _a : "" }];
-    }
-    unistNodeName() {
-        return "text";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema) {
-        return [proseMirrorSchema.text(node.value)];
-    }
+class TextExtension extends prosemirrorUnified.NodeExtension {
+  proseMirrorNodeName() {
+    return "text";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      group: "inline"
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2) {
+    return [{ type: this.unistNodeName(), value: node2.text ?? "" }];
+  }
+  unistNodeName() {
+    return "text";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema) {
+    return [proseMirrorSchema.text(node2.value)];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/CodeBlockExtension.ts
-
-
-
-
-
-/**
- * @public
- */
-class CodeBlockExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    static liftOutOfCodeBlock() {
-        return (state, dispatch) => {
-            const { $from, $to } = state.selection;
-            if (
-            // Mustn't be a complex selection
-            !$from.sameParent($to) ||
-                // Must be in a code block
-                $from.parent.type.name !== "code_block" ||
-                // Must be at the end of the code block
-                $from.parentOffset !== $from.parent.content.size ||
-                // There must already be a preceding empty line
-                !$from.parent.textBetween(0, $from.parentOffset).endsWith("\n\n")) {
-                return false;
-            }
-            if (dispatch) {
-                const tr = state.tr;
-                dispatch(tr
-                    // Delete the preceding empty line
-                    .deleteRange($from.pos - 2, $from.pos)
-                    // Insert empty paragraph
-                    .insert($from.pos - 1, tr.doc.type.schema.nodes["paragraph"].create())
-                    // Put the cursor into the empty paragraph
-                    .setSelection(external_prosemirror_state_namespaceObject.Selection.near(tr.doc.resolve($from.pos), 1))
-                    .scrollIntoView());
-            }
-            return true;
-        };
-    }
-    dependencies() {
-        return [new TextExtension()];
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.textblockTypeInputRule)(/^\s{0,3}```$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-            (0,external_prosemirror_inputrules_namespaceObject.textblockTypeInputRule)(/^\s{4}$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            Enter: CodeBlockExtension.liftOutOfCodeBlock(),
-            "Shift-Mod-\\": (0,external_prosemirror_commands_namespaceObject.setBlockType)(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        };
-    }
-    proseMirrorNodeName() {
-        return "code_block";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            code: true,
-            content: "text*",
-            defining: true,
-            group: "block",
-            marks: "",
-            parseDOM: [{ preserveWhitespace: "full", tag: "pre" }],
-            toDOM() {
-                return ["pre", ["code", 0]];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [
-            {
-                type: this.unistNodeName(),
-                value: convertedChildren.map((child) => child.value).join(""),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "code";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, [proseMirrorSchema.text(node.value)]);
-    }
+class CodeBlockExtension extends prosemirrorUnified.NodeExtension {
+  static liftOutOfCodeBlock() {
+    return (state, dispatch) => {
+      const { $from, $to } = state.selection;
+      if (
+        // Mustn't be a complex selection
+        !$from.sameParent($to) || // Must be in a code block
+        $from.parent.type.name !== "code_block" || // Must be at the end of the code block
+        $from.parentOffset !== $from.parent.content.size || // There must already be a preceding empty line
+        !$from.parent.textBetween(0, $from.parentOffset).endsWith("\n\n")
+      ) {
+        return false;
+      }
+      if (dispatch) {
+        const tr = state.tr;
+        dispatch(
+          tr.deleteRange($from.pos - 2, $from.pos).insert(
+            $from.pos - 1,
+            tr.doc.type.schema.nodes["paragraph"].create()
+          ).setSelection(prosemirrorState.Selection.near(tr.doc.resolve($from.pos), 1)).scrollIntoView()
+        );
+      }
+      return true;
+    };
+  }
+  dependencies() {
+    return [new TextExtension()];
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      prosemirrorInputrules.textblockTypeInputRule(
+        /^\s{0,3}```(?! )[^\n`]*\n$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      ),
+      prosemirrorInputrules.textblockTypeInputRule(
+        /^\s{4}$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      Enter: CodeBlockExtension.liftOutOfCodeBlock(),
+      "Shift-Mod-\\": prosemirrorCommands.setBlockType(
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    };
+  }
+  proseMirrorNodeName() {
+    return "code_block";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      code: true,
+      content: "text*",
+      defining: true,
+      group: "block",
+      marks: "",
+      parseDOM: [{ preserveWhitespace: "full", tag: "pre" }],
+      toDOM() {
+        return ["pre", ["code", 0]];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [
+      {
+        type: this.unistNodeName(),
+        value: convertedChildren.map((child) => child.value).join("")
+      }
+    ];
+  }
+  unistNodeName() {
+    return "code";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      [proseMirrorSchema.text(node2.value)]
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/DefinitionExtension.ts
-
-/**
- * @public
- */
-class DefinitionExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorNodeName() {
-        return null;
-    }
-    proseMirrorNodeSpec() {
-        return null;
-    }
-    proseMirrorNodeToUnistNodes() {
-        return [];
-    }
-    unistNodeName() {
-        return "definition";
-    }
-    unistNodeToProseMirrorNodes(node, _proseMirrorSchema, _convertedChildren, context) {
-        if (context.DefinitionExtension === undefined) {
-            context.DefinitionExtension = { definitions: {} };
-        }
-        context.DefinitionExtension.definitions[node.identifier] = {
-            title: node.title,
-            url: node.url,
-        };
-        return [];
+class DefinitionExtension extends prosemirrorUnified.NodeExtension {
+  proseMirrorNodeName() {
+    return null;
+  }
+  proseMirrorNodeSpec() {
+    return null;
+  }
+  proseMirrorNodeToUnistNodes() {
+    return [];
+  }
+  unistNodeName() {
+    return "definition";
+  }
+  unistNodeToProseMirrorNodes(node2, _proseMirrorSchema, _convertedChildren, context) {
+    if (context.DefinitionExtension === void 0) {
+      context.DefinitionExtension = { definitions: {} };
     }
+    context.DefinitionExtension.definitions[node2.identifier] = {
+      title: node2.title,
+      url: node2.url
+    };
+    return [];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ParagraphExtension.ts
-
-/**
- * @public
- */
-class ParagraphExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorNodeName() {
-        return "paragraph";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            content: "inline*",
-            group: "block",
-            parseDOM: [{ tag: "p" }],
-            toDOM() {
-                return ["p", 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [{ children: convertedChildren, type: this.unistNodeName() }];
-    }
-    unistNodeName() {
-        return "paragraph";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
+class ParagraphExtension extends prosemirrorUnified.NodeExtension {
+  proseMirrorNodeName() {
+    return "paragraph";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      content: "inline*",
+      group: "block",
+      parseDOM: [{ tag: "p" }],
+      toDOM() {
+        return ["p", 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [{ children: convertedChildren, type: this.unistNodeName() }];
+  }
+  unistNodeName() {
+    return "paragraph";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/HeadingExtension.ts
-
-
-
-
-
-/**
- * @public
- */
-class HeadingExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    static headingLevelCommandBuilder(proseMirrorSchema, levelUpdate, onlyAtStart) {
-        return (state, dispatch, view) => {
-            if (onlyAtStart && !HeadingExtension.isAtStart(state, view)) {
-                return false;
-            }
-            const { $anchor } = state.selection;
-            const headingNode = $anchor.parent;
-            if (headingNode.type.name !== "heading") {
-                return false;
-            }
-            const newHeadingLevel = headingNode.attrs["level"] + levelUpdate;
-            if (newHeadingLevel < 0 || newHeadingLevel > 6) {
-                return false;
-            }
-            if (dispatch === undefined) {
-                return true;
-            }
-            const headingPosition = $anchor.before($anchor.depth);
-            if (newHeadingLevel > 0) {
-                dispatch(state.tr.setNodeMarkup(headingPosition, undefined, {
-                    level: newHeadingLevel,
-                }));
-            }
-            else {
-                dispatch(state.tr.setNodeMarkup(headingPosition, proseMirrorSchema.nodes["paragraph"]));
-            }
-            return true;
-        };
-    }
-    static isAtStart(state, view) {
-        if (!state.selection.empty) {
-            return false;
-        }
-        if (view !== undefined) {
-            return view.endOfTextblock("backward", state);
-        }
-        return state.selection.$anchor.parentOffset > 0;
-    }
-    dependencies() {
-        return [new ParagraphExtension(), new TextExtension()];
+class HeadingExtension extends prosemirrorUnified.NodeExtension {
+  static headingLevelCommandBuilder(proseMirrorSchema, levelUpdate, onlyAtStart) {
+    return (state, dispatch, view) => {
+      if (onlyAtStart && !HeadingExtension.isAtStart(state, view)) {
+        return false;
+      }
+      const { $anchor } = state.selection;
+      const headingNode = $anchor.parent;
+      if (headingNode.type.name !== "heading") {
+        return false;
+      }
+      const newHeadingLevel = headingNode.attrs["level"] + levelUpdate;
+      if (newHeadingLevel < 0 || newHeadingLevel > 6) {
+        return false;
+      }
+      if (dispatch === void 0) {
+        return true;
+      }
+      const headingPosition = $anchor.before($anchor.depth);
+      if (newHeadingLevel > 0) {
+        dispatch(
+          state.tr.setNodeMarkup(headingPosition, void 0, {
+            level: newHeadingLevel
+          })
+        );
+      } else {
+        dispatch(
+          state.tr.setNodeMarkup(
+            headingPosition,
+            proseMirrorSchema.nodes["paragraph"]
+          )
+        );
+      }
+      return true;
+    };
+  }
+  static isAtStart(state, view) {
+    if (!state.selection.empty) {
+      return false;
     }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.textblockTypeInputRule)(/^\s{0,3}(#{1,6})\s$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()], (match) => ({ level: match[1].length })),
-        ];
+    if (view !== void 0) {
+      return view.endOfTextblock("backward", state);
     }
-    proseMirrorKeymap(proseMirrorSchema) {
-        const keymap = {
-            // eslint-disable-next-line @typescript-eslint/naming-convention -- This is a key
-            "#": HeadingExtension.headingLevelCommandBuilder(proseMirrorSchema, +1, true),
-            Backspace: HeadingExtension.headingLevelCommandBuilder(proseMirrorSchema, -1, true),
-            "Shift-Tab": HeadingExtension.headingLevelCommandBuilder(proseMirrorSchema, -1, false),
-            Tab: HeadingExtension.headingLevelCommandBuilder(proseMirrorSchema, +1, false),
-        };
-        for (let i = 1; i <= 6; i++) {
-            keymap[`Shift-Mod-${i.toString()}`] = (0,external_prosemirror_commands_namespaceObject.setBlockType)(proseMirrorSchema.nodes[this.proseMirrorNodeName()], { level: i });
+    return state.selection.$anchor.parentOffset > 0;
+  }
+  dependencies() {
+    return [new ParagraphExtension(), new TextExtension()];
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      prosemirrorInputrules.textblockTypeInputRule(
+        /^\s{0,3}(#{1,6})\s$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()],
+        (match) => ({ level: match[1].length })
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    const keymap = {
+      "#": HeadingExtension.headingLevelCommandBuilder(
+        proseMirrorSchema,
+        1,
+        true
+      ),
+      Backspace: HeadingExtension.headingLevelCommandBuilder(
+        proseMirrorSchema,
+        -1,
+        true
+      ),
+      "Shift-Tab": HeadingExtension.headingLevelCommandBuilder(
+        proseMirrorSchema,
+        -1,
+        false
+      ),
+      Tab: HeadingExtension.headingLevelCommandBuilder(
+        proseMirrorSchema,
+        1,
+        false
+      )
+    };
+    for (let i = 1; i <= 6; i++) {
+      keymap[`Shift-Mod-${i.toString()}`] = prosemirrorCommands.setBlockType(
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()],
+        { level: i }
+      );
+    }
+    return keymap;
+  }
+  proseMirrorNodeName() {
+    return "heading";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: { level: { default: 1 } },
+      content: "text*",
+      defining: true,
+      group: "block",
+      parseDOM: [
+        { attrs: { level: 1 }, tag: "h1" },
+        { attrs: { level: 2 }, tag: "h2" },
+        { attrs: { level: 3 }, tag: "h3" },
+        { attrs: { level: 4 }, tag: "h4" },
+        { attrs: { level: 5 }, tag: "h5" },
+        { attrs: { level: 6 }, tag: "h6" }
+      ],
+      toDOM(node2) {
+        return [`h${node2.attrs["level"].toString()}`, 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2, convertedChildren) {
+    return [
+      {
+        children: convertedChildren,
+        depth: node2.attrs["level"],
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "heading";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      {
+        level: node2.depth
+      }
+    );
+  }
+}
+class HorizontalRuleExtension extends prosemirrorUnified.NodeExtension {
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new prosemirrorInputrules.InputRule(
+        /^\s{0,3}(?:\*\*\*|---|___)\n$/u,
+        (state, _, start, end) => state.tr.replaceWith(
+          start,
+          end,
+          prosemirrorUnified.createProseMirrorNode(
+            this.proseMirrorNodeName(),
+            proseMirrorSchema,
+            []
+          )
+        )
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      "Mod-_": (state, dispatch) => {
+        if (dispatch) {
+          dispatch(
+            state.tr.replaceSelectionWith(
+              proseMirrorSchema.nodes[this.proseMirrorNodeName()].create()
+            ).scrollIntoView()
+          );
         }
-        return keymap;
-    }
-    proseMirrorNodeName() {
-        return "heading";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: { level: { default: 1 } },
-            content: "text*",
-            defining: true,
-            group: "block",
-            parseDOM: [
-                { attrs: { level: 1 }, tag: "h1" },
-                { attrs: { level: 2 }, tag: "h2" },
-                { attrs: { level: 3 }, tag: "h3" },
-                { attrs: { level: 4 }, tag: "h4" },
-                { attrs: { level: 5 }, tag: "h5" },
-                { attrs: { level: 6 }, tag: "h6" },
-            ],
-            toDOM(node) {
-                return [`h${node.attrs["level"].toString()}`, 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node, convertedChildren) {
-        return [
-            {
-                children: convertedChildren,
-                depth: node.attrs["level"],
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "heading";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, {
-            level: node.depth,
-        });
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/HorizontalRuleExtension.ts
-
-
-/**
- * @public
- */
-class HorizontalRuleExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_inputrules_namespaceObject.InputRule(/^\s{0,3}(?:\*\*\*|---|___)\n$/u, (state, _, start, end) => state.tr.replaceWith(start, end, (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, []))),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            "Mod-_": (state, dispatch) => {
-                if (dispatch) {
-                    dispatch(state.tr
-                        .replaceSelectionWith(proseMirrorSchema.nodes[this.proseMirrorNodeName()].create())
-                        .scrollIntoView());
-                }
-                return true;
-            },
-        };
-    }
-    proseMirrorNodeName() {
-        return "horizontal_rule";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            group: "block",
-            parseDOM: [{ tag: "hr" }],
-            toDOM() {
-                return ["div", ["hr"]];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes() {
-        return [
-            {
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "thematicBreak";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ImageExtension.ts
-
-
-/**
- * @public
- */
-class ImageExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    dependencies() {
-        return [new ParagraphExtension()];
-    }
-    proseMirrorNodeName() {
-        return "image";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: {
-                alt: { default: null },
-                src: {},
-                title: { default: null },
-            },
-            draggable: true,
-            group: "inline",
-            inline: true,
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        return {
-                            alt: dom.getAttribute("alt"),
-                            src: dom.getAttribute("src"),
-                            title: dom.getAttribute("title"),
-                        };
-                    },
-                    tag: "img[src]",
-                },
-            ],
-            toDOM(node) {
-                return ["img", node.attrs];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node) {
-        return [
-            Object.assign(Object.assign({ type: this.unistNodeName(), url: node.attrs["src"] }, (node.attrs["alt"] !== null && { alt: node.attrs["alt"] })), (node.attrs["title"] !== null && {
-                title: node.attrs["title"],
-            })),
-        ];
-    }
-    unistNodeName() {
-        return "image";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, {
-            alt: node.alt,
-            src: node.url,
-            title: node.title,
-        });
-    }
+        return true;
+      }
+    };
+  }
+  proseMirrorNodeName() {
+    return "horizontal_rule";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      group: "block",
+      parseDOM: [{ tag: "hr" }],
+      toDOM() {
+        return ["div", ["hr"]];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes() {
+    return [
+      {
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "thematicBreak";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ImageReferenceExtension.ts
-
-
-
-/**
- * @public
- */
-class ImageReferenceExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    dependencies() {
-        return [new DefinitionExtension(), new ImageExtension()];
-    }
-    postUnistToProseMirrorHook(context) {
-        if (context.ImageReferenceExtension === undefined ||
-            context.DefinitionExtension === undefined) {
-            return;
-        }
-        for (const id in context.ImageReferenceExtension.proseMirrorNodes) {
-            if (!(id in context.DefinitionExtension.definitions)) {
-                continue;
-            }
-            const definition = context.DefinitionExtension.definitions[id];
-            const attrs = context.ImageReferenceExtension.proseMirrorNodes[id]
-                .attrs;
-            attrs["src"] = definition.url;
-            if (definition.title !== undefined) {
-                attrs["title"] = definition.title;
-            }
-        }
-    }
-    proseMirrorNodeName() {
-        return null;
-    }
-    proseMirrorNodeSpec() {
-        return null;
-    }
-    proseMirrorNodeToUnistNodes() {
-        return [];
-    }
-    unistNodeName() {
-        return "imageReference";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren, context) {
-        const proseMirrorNode = proseMirrorSchema.nodes["image"].createAndFill({ alt: node.alt, src: "", title: node.label }, convertedChildren);
-        if (proseMirrorNode === null) {
-            return [];
+class ImageExtension extends prosemirrorUnified.NodeExtension {
+  dependencies() {
+    return [new ParagraphExtension()];
+  }
+  proseMirrorNodeName() {
+    return "image";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: {
+        alt: { default: null },
+        src: {},
+        title: { default: null }
+      },
+      draggable: true,
+      group: "inline",
+      inline: true,
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            return {
+              alt: dom.getAttribute("alt"),
+              src: dom.getAttribute("src"),
+              title: dom.getAttribute("title")
+            };
+          },
+          tag: "img[src]"
         }
-        if (context.ImageReferenceExtension === undefined) {
-            context.ImageReferenceExtension = { proseMirrorNodes: {} };
+      ],
+      toDOM(node2) {
+        return ["img", node2.attrs];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2) {
+    return [
+      {
+        type: this.unistNodeName(),
+        url: node2.attrs["src"],
+        ...node2.attrs["alt"] !== null && { alt: node2.attrs["alt"] },
+        ...node2.attrs["title"] !== null && {
+          title: node2.attrs["title"]
         }
-        context.ImageReferenceExtension.proseMirrorNodes[node.identifier] =
-            proseMirrorNode;
-        return [proseMirrorNode];
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/InlineCodeExtension.ts
-
-
-/**
- * @public
- */
-class InlineCodeExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode) {
-        return { type: this.unistNodeName(), value: convertedNode.value };
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/`([^\s](?:.*[^\s])?)`([\s\S])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
-        return {
-            "Ctrl-`": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-        };
-    }
-    proseMirrorMarkName() {
-        return "code";
-    }
-    proseMirrorMarkSpec() {
-        return {
-            inclusive: false,
-            parseDOM: [{ tag: "code" }],
-            toDOM() {
-                return ["code"];
-            },
-        };
-    }
-    unistNodeName() {
-        return "inlineCode";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema) {
-        return [
-            proseMirrorSchema
-                .text(node.value)
-                .mark([proseMirrorSchema.marks[this.proseMirrorMarkName()].create()]),
-        ];
-    }
+      }
+    ];
+  }
+  unistNodeName() {
+    return "image";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      {
+        alt: node2.alt,
+        src: node2.url,
+        title: node2.title
+      }
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ItalicExtension.ts
-
-
-/**
- * @public
- */
-class ItalicExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode) {
-        return { children: [convertedNode], type: this.unistNodeName() };
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/(?<!\*)\*([^\s*](?:.*[^\s])?)\*([^*])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/(?<!_)_([^\s_](?:.*[^\s])?)_([^_])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
-        return {
-            "Mod-i": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-            "Mod-I": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-        };
-    }
-    proseMirrorMarkName() {
-        return "em";
+class ImageReferenceExtension extends prosemirrorUnified.NodeExtension {
+  dependencies() {
+    return [new DefinitionExtension(), new ImageExtension()];
+  }
+  postUnistToProseMirrorHook(context) {
+    if (context.ImageReferenceExtension === void 0 || context.DefinitionExtension === void 0) {
+      return;
     }
-    proseMirrorMarkSpec() {
-        return {
-            parseDOM: [
-                { tag: "i" },
-                { tag: "em" },
-                {
-                    getAttrs: (value) => value === "italic" && null,
-                    style: "font-style",
-                },
-            ],
-            toDOM() {
-                return ["em"];
-            },
-        };
+    for (const id in context.ImageReferenceExtension.proseMirrorNodes) {
+      if (!(id in context.DefinitionExtension.definitions)) {
+        continue;
+      }
+      const definition2 = context.DefinitionExtension.definitions[id];
+      const attrs = context.ImageReferenceExtension.proseMirrorNodes[id].attrs;
+      attrs["src"] = definition2.url;
+      if (definition2.title !== void 0) {
+        attrs["title"] = definition2.title;
+      }
     }
-    unistNodeName() {
-        return "emphasis";
+  }
+  proseMirrorNodeName() {
+    return null;
+  }
+  proseMirrorNodeSpec() {
+    return null;
+  }
+  proseMirrorNodeToUnistNodes() {
+    return [];
+  }
+  unistNodeName() {
+    return "imageReference";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren, context) {
+    const proseMirrorNode = proseMirrorSchema.nodes["image"].createAndFill(
+      { alt: node2.alt, src: "", title: node2.label },
+      convertedChildren
+    );
+    if (proseMirrorNode === null) {
+      return [];
     }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return convertedChildren.map((child) => child.mark(child.marks.concat([
-            proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),
-        ])));
+    if (context.ImageReferenceExtension === void 0) {
+      context.ImageReferenceExtension = { proseMirrorNodes: {} };
     }
+    context.ImageReferenceExtension.proseMirrorNodes[node2.identifier] = proseMirrorNode;
+    return [proseMirrorNode];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/LinkExtension.ts
-
-/**
- * @public
- */
-class LinkExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode, originalMark) {
-        return Object.assign(Object.assign({ type: this.unistNodeName(), url: originalMark.attrs["href"] }, (originalMark.attrs["title"] !== null && {
-            title: originalMark.attrs["title"],
-        })), { children: [convertedNode] });
-    }
-    proseMirrorMarkName() {
-        return "link";
-    }
-    proseMirrorMarkSpec() {
-        return {
-            attrs: { href: {}, title: { default: null } },
-            inclusive: false,
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        return {
-                            href: dom.getAttribute("href"),
-                            title: dom.getAttribute("title"),
-                        };
-                    },
-                    tag: "a[href]",
-                },
-            ],
-            toDOM(node) {
-                return ["a", node.attrs];
-            },
-        };
-    }
-    unistNodeName() {
-        return "link";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return convertedChildren.map((child) => child.mark(child.marks.concat([
-            proseMirrorSchema.marks[this.proseMirrorMarkName()].create({
-                href: node.url,
-                title: node.title,
-            }),
-        ])));
-    }
+class InlineCodeExtension extends prosemirrorUnified.MarkExtension {
+  processConvertedUnistNode(convertedNode) {
+    return { type: this.unistNodeName(), value: convertedNode.value };
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new prosemirrorUnified.MarkInputRule(
+        new RegExp("(?<!`)(?<b>`+)(?!`)(?<s> ?)(?<i>.*)\\k<s>(?<!`)\\k<b>(?<t>[^`])$", "u"),
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
+    return {
+      "Ctrl-`": prosemirrorCommands.toggleMark(markType)
+    };
+  }
+  proseMirrorMarkName() {
+    return "code";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      inclusive: false,
+      parseDOM: [{ tag: "code" }],
+      toDOM() {
+        return ["code", 0];
+      }
+    };
+  }
+  unistNodeName() {
+    return "inlineCode";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema) {
+    return [
+      proseMirrorSchema.text(node2.value).mark([proseMirrorSchema.marks[this.proseMirrorMarkName()].create()])
+    ];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/LinkReferenceExtension.ts
-
-
-
-/**
- * @public
- */
-class LinkReferenceExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    dependencies() {
-        return [new DefinitionExtension(), new LinkExtension()];
-    }
-    postUnistToProseMirrorHook(context) {
-        if (context.LinkReferenceExtension === undefined ||
-            context.DefinitionExtension === undefined) {
-            return;
-        }
-        for (const id in context.LinkReferenceExtension.marks) {
-            if (!(id in context.DefinitionExtension.definitions)) {
-                continue;
-            }
-            const definition = context.DefinitionExtension.definitions[id];
-            const attrs = context.LinkReferenceExtension.marks[id].attrs;
-            attrs["href"] = definition.url;
-            if (definition.title !== undefined) {
-                attrs["title"] = definition.title;
-            }
-        }
-    }
-    processConvertedUnistNode(convertedNode) {
-        return convertedNode;
-    }
-    proseMirrorMarkName() {
-        return null;
-    }
-    proseMirrorMarkSpec() {
-        return null;
-    }
-    unistNodeName() {
-        return "linkReference";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren, context) {
-        const mark = proseMirrorSchema.marks["link"].create({
-            href: null,
-            title: null,
-        });
-        if (context.LinkReferenceExtension === undefined) {
-            context.LinkReferenceExtension = { marks: {} };
+class ItalicExtension extends prosemirrorUnified.MarkExtension {
+  processConvertedUnistNode(convertedNode) {
+    return { children: [convertedNode], type: this.unistNodeName() };
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new prosemirrorUnified.MarkInputRule(
+        new RegExp("(?<!\\*)\\*([^\\s*](?:.*[^\\s])?)\\*([^*])$", "u"),
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      ),
+      new prosemirrorUnified.MarkInputRule(
+        new RegExp("(?<!_)_([^\\s_](?:.*[^\\s])?)_([^_])$", "u"),
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
+    return {
+      "Mod-i": prosemirrorCommands.toggleMark(markType),
+      "Mod-I": prosemirrorCommands.toggleMark(markType)
+    };
+  }
+  proseMirrorMarkName() {
+    return "em";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      parseDOM: [
+        { tag: "i" },
+        { tag: "em" },
+        {
+          getAttrs: (value) => value === "italic" && null,
+          style: "font-style"
         }
-        context.LinkReferenceExtension.marks[node.identifier] = mark;
-        return convertedChildren.map((child) => child.mark(child.marks.concat([mark])));
-    }
-}
-
-;// CONCATENATED MODULE: external "prosemirror-schema-list"
-var external_prosemirror_schema_list_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_schema_list_y = (x) => (() => (x))
-const external_prosemirror_schema_list_namespaceObject = external_prosemirror_schema_list_x({ ["liftListItem"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.liftListItem), ["sinkListItem"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.sinkListItem), ["splitListItem"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.splitListItem), ["wrapInList"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.wrapInList) });
-;// CONCATENATED MODULE: ./src/syntax-extensions/ListItemExtension.ts
-
-
-/**
- * @public
- */
-class ListItemExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorKeymap(proseMirrorSchema) {
-        const nodeType = proseMirrorSchema.nodes[this.proseMirrorNodeName()];
-        return {
-            Enter: (0,external_prosemirror_schema_list_namespaceObject.splitListItem)(nodeType),
-            "Shift-Tab": (0,external_prosemirror_schema_list_namespaceObject.liftListItem)(nodeType),
-            Tab: (0,external_prosemirror_schema_list_namespaceObject.sinkListItem)(nodeType),
-        };
-    }
-    proseMirrorNodeName() {
-        return "regular_list_item";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            content: "paragraph block*",
-            defining: true,
-            group: "list_item",
-            parseDOM: [{ tag: "li" }],
-            toDOM() {
-                return ["li", 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [
-            {
-                children: convertedChildren,
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "listItem";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
-    unistToProseMirrorTest(node) {
-        return (node.type === this.unistNodeName() &&
-            (!("checked" in node) || typeof node.checked !== "boolean"));
-    }
+      ],
+      toDOM() {
+        return ["em", 0];
+      }
+    };
+  }
+  unistNodeName() {
+    return "emphasis";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return convertedChildren.map(
+      (child) => child.mark(
+        child.marks.concat([
+          proseMirrorSchema.marks[this.proseMirrorMarkName()].create()
+        ])
+      )
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/OrderedListExtension.ts
-
-
-
-
-/**
- * @public
- */
-class OrderedListExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    dependencies() {
-        return [new ListItemExtension()];
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.wrappingInputRule)(/^\s{0,3}(\d+)\.\s$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()], (match) => ({ start: +match[1] }), (match, node) => node.childCount + node.attrs["start"] === +match[1]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            "Shift-Mod-9": (0,external_prosemirror_schema_list_namespaceObject.wrapInList)(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        };
-    }
-    proseMirrorNodeName() {
-        return "ordered_list";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: { spread: { default: false }, start: { default: 1 } },
-            content: "list_item+",
-            group: "block",
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        const start = dom.getAttribute("start");
-                        return {
-                            spread: dom.getAttribute("data-spread") === "true",
-                            start: start !== null ? parseInt(start, 10) : 1,
-                        };
-                    },
-                    tag: "ol",
-                },
-            ],
-            toDOM(node) {
-                return [
-                    "ol",
-                    {
-                        "data-spread": node.attrs["spread"],
-                        start: node.attrs["start"],
-                    },
-                    0,
-                ];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node, convertedChildren) {
-        const spread = node.attrs["spread"];
-        return [
-            {
-                children: convertedChildren.map((child) => {
-                    child.spread = spread;
-                    return child;
-                }),
-                ordered: true,
-                spread,
-                start: node.attrs["start"],
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "list";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        var _a;
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, {
-            spread: node.spread,
-            start: (_a = node.start) !== null && _a !== void 0 ? _a : 1,
-        });
-    }
-    unistToProseMirrorTest(node) {
-        return (node.type === this.unistNodeName() && node.ordered === true);
-    }
+class LinkExtension extends prosemirrorUnified.MarkExtension {
+  processConvertedUnistNode(convertedNode, originalMark) {
+    return {
+      type: this.unistNodeName(),
+      url: originalMark.attrs["href"],
+      ...originalMark.attrs["title"] !== null && {
+        title: originalMark.attrs["title"]
+      },
+      children: [convertedNode]
+    };
+  }
+  proseMirrorMarkName() {
+    return "link";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      attrs: { href: {}, title: { default: null } },
+      inclusive: false,
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            return {
+              href: dom.getAttribute("href"),
+              title: dom.getAttribute("title")
+            };
+          },
+          tag: "a[href]"
+        }
+      ],
+      toDOM(node2) {
+        return ["a", node2.attrs, 0];
+      }
+    };
+  }
+  unistNodeName() {
+    return "link";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return convertedChildren.map(
+      (child) => child.mark(
+        child.marks.concat([
+          proseMirrorSchema.marks[this.proseMirrorMarkName()].create({
+            href: node2.url,
+            title: node2.title
+          })
+        ])
+      )
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/RootExtension.ts
-
-/**
- * @public
- */
-class RootExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorNodeName() {
-        return "doc";
-    }
-    proseMirrorNodeSpec() {
-        return { content: "block+" };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [{ children: convertedChildren, type: this.unistNodeName() }];
+class LinkReferenceExtension extends prosemirrorUnified.MarkExtension {
+  dependencies() {
+    return [new DefinitionExtension(), new LinkExtension()];
+  }
+  postUnistToProseMirrorHook(context) {
+    if (context.LinkReferenceExtension === void 0 || context.DefinitionExtension === void 0) {
+      return;
     }
-    unistNodeName() {
-        return "root";
+    for (const id in context.LinkReferenceExtension.marks) {
+      if (!(id in context.DefinitionExtension.definitions)) {
+        continue;
+      }
+      const definition2 = context.DefinitionExtension.definitions[id];
+      const attrs = context.LinkReferenceExtension.marks[id].attrs;
+      attrs["href"] = definition2.url;
+      if (definition2.title !== void 0) {
+        attrs["title"] = definition2.title;
+      }
     }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
+  }
+  processConvertedUnistNode(convertedNode) {
+    return convertedNode;
+  }
+  proseMirrorMarkName() {
+    return null;
+  }
+  proseMirrorMarkSpec() {
+    return null;
+  }
+  unistNodeName() {
+    return "linkReference";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren, context) {
+    const mark = proseMirrorSchema.marks["link"].create({
+      href: null,
+      title: null
+    });
+    if (context.LinkReferenceExtension === void 0) {
+      context.LinkReferenceExtension = { marks: {} };
     }
+    context.LinkReferenceExtension.marks[node2.identifier] = mark;
+    return convertedChildren.map(
+      (child) => child.mark(child.marks.concat([mark]))
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/UnorderedListExtension.ts
-
-
-
-
-/**
- * @public
- */
-class UnorderedListExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    dependencies() {
-        return [new ListItemExtension()];
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.wrappingInputRule)(/^\s{0,3}([-+*])\s$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            "Shift-Mod-8": (0,external_prosemirror_schema_list_namespaceObject.wrapInList)(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        };
-    }
-    proseMirrorNodeName() {
-        return "bullet_list";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: { spread: { default: false } },
-            content: "list_item+",
-            group: "block",
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        return {
-                            spread: dom.getAttribute("data-spread") === "true",
-                        };
-                    },
-                    tag: "ul",
-                },
-            ],
-            toDOM(node) {
-                return ["ul", { "data-spread": node.attrs["spread"] }, 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node, convertedChildren) {
-        const spread = node.attrs["spread"];
-        return [
-            {
-                children: convertedChildren.map((child) => {
-                    child.spread = spread;
-                    return child;
-                }),
-                ordered: false,
-                spread,
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "list";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, {
-            spread: node.spread,
-        });
-    }
-    unistToProseMirrorTest(node) {
-        return (node.type === this.unistNodeName() && node.ordered !== true);
-    }
+class ListItemExtension extends prosemirrorUnified.NodeExtension {
+  proseMirrorKeymap(proseMirrorSchema) {
+    const nodeType = proseMirrorSchema.nodes[this.proseMirrorNodeName()];
+    return {
+      Enter: prosemirrorSchemaList.splitListItem(nodeType),
+      "Shift-Tab": prosemirrorSchemaList.liftListItem(nodeType),
+      Tab: prosemirrorSchemaList.sinkListItem(nodeType)
+    };
+  }
+  proseMirrorNodeName() {
+    return "regular_list_item";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      content: "paragraph block*",
+      defining: true,
+      group: "list_item",
+      parseDOM: [{ tag: "li" }],
+      toDOM() {
+        return ["li", 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [
+      {
+        children: convertedChildren,
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "listItem";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
+  unistToProseMirrorTest(node2) {
+    return node2.type === this.unistNodeName() && (!("checked" in node2) || typeof node2.checked !== "boolean");
+  }
 }
-
-;// CONCATENATED MODULE: ./src/MarkdownExtension.ts
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-/**
- * @public
- */
-class MarkdownExtension extends external_prosemirror_unified_namespaceObject.Extension {
-    dependencies() {
+class OrderedListExtension extends prosemirrorUnified.NodeExtension {
+  dependencies() {
+    return [new ListItemExtension()];
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      prosemirrorInputrules.wrappingInputRule(
+        /^\s{0,3}(\d+)\.\s$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()],
+        (match) => ({ start: +match[1] }),
+        (match, node2) => node2.childCount + node2.attrs["start"] === +match[1]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      "Shift-Mod-9": prosemirrorSchemaList.wrapInList(
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    };
+  }
+  proseMirrorNodeName() {
+    return "ordered_list";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: { spread: { default: false }, start: { default: 1 } },
+      content: "list_item+",
+      group: "block",
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            const start = dom.getAttribute("start");
+            return {
+              spread: dom.getAttribute("data-spread") === "true",
+              start: start !== null ? parseInt(start, 10) : 1
+            };
+          },
+          tag: "ol"
+        }
+      ],
+      toDOM(node2) {
         return [
-            // ParagraphExtension needs to be first so that it is the default block.
-            new ParagraphExtension(),
-            new BlockquoteExtension(),
-            new BoldExtension(),
-            new BreakExtension(),
-            new CodeBlockExtension(),
-            new DefinitionExtension(),
-            new HeadingExtension(),
-            new HorizontalRuleExtension(),
-            new ImageExtension(),
-            new ImageReferenceExtension(),
-            new InlineCodeExtension(),
-            new ItalicExtension(),
-            new LinkExtension(),
-            new LinkReferenceExtension(),
-            new ListItemExtension(),
-            new OrderedListExtension(),
-            new RootExtension(),
-            new TextExtension(),
-            new UnorderedListExtension(),
+          "ol",
+          {
+            "data-spread": node2.attrs["spread"],
+            start: node2.attrs["start"]
+          },
+          0
         ];
-    }
-    unifiedInitializationHook(processor) {
-        return processor.use(external_remark_parse_namespaceObject["default"]).use(external_remark_stringify_namespaceObject["default"], {
-            fences: true,
-            listItemIndent: "one",
-            resourceLink: true,
-            rule: "-",
-        });
-    }
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2, convertedChildren) {
+    const spread = node2.attrs["spread"];
+    return [
+      {
+        children: convertedChildren.map((child) => {
+          child.spread = spread;
+          return child;
+        }),
+        ordered: true,
+        spread,
+        start: node2.attrs["start"],
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "list";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      {
+        spread: node2.spread,
+        start: node2.start ?? 1
+      }
+    );
+  }
+  unistToProseMirrorTest(node2) {
+    return node2.type === this.unistNodeName() && node2.ordered === true;
+  }
+}
+class RootExtension extends prosemirrorUnified.NodeExtension {
+  proseMirrorNodeName() {
+    return "doc";
+  }
+  proseMirrorNodeSpec() {
+    return { content: "block+" };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [{ children: convertedChildren, type: this.unistNodeName() }];
+  }
+  unistNodeName() {
+    return "root";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
+}
+class UnorderedListExtension extends prosemirrorUnified.NodeExtension {
+  dependencies() {
+    return [new ListItemExtension()];
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      prosemirrorInputrules.wrappingInputRule(
+        /^\s{0,3}([-+*])\s$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      "Shift-Mod-8": prosemirrorSchemaList.wrapInList(
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    };
+  }
+  proseMirrorNodeName() {
+    return "bullet_list";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: { spread: { default: false } },
+      content: "list_item+",
+      group: "block",
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            return {
+              spread: dom.getAttribute("data-spread") === "true"
+            };
+          },
+          tag: "ul"
+        }
+      ],
+      toDOM(node2) {
+        return ["ul", { "data-spread": node2.attrs["spread"] }, 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2, convertedChildren) {
+    const spread = node2.attrs["spread"];
+    return [
+      {
+        children: convertedChildren.map((child) => {
+          child.spread = spread;
+          return child;
+        }),
+        ordered: false,
+        spread,
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "list";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      {
+        spread: node2.spread
+      }
+    );
+  }
+  unistToProseMirrorTest(node2) {
+    return node2.type === this.unistNodeName() && node2.ordered !== true;
+  }
+}
+class MarkdownExtension extends prosemirrorUnified.Extension {
+  dependencies() {
+    return [
+      // ParagraphExtension needs to be first so that it is the default block.
+      new ParagraphExtension(),
+      new BlockquoteExtension(),
+      new BoldExtension(),
+      new BreakExtension(),
+      new CodeBlockExtension(),
+      new DefinitionExtension(),
+      new HeadingExtension(),
+      new HorizontalRuleExtension(),
+      new ImageExtension(),
+      new ImageReferenceExtension(),
+      new InlineCodeExtension(),
+      new ItalicExtension(),
+      new LinkExtension(),
+      new LinkReferenceExtension(),
+      new ListItemExtension(),
+      new OrderedListExtension(),
+      new RootExtension(),
+      new TextExtension(),
+      new UnorderedListExtension()
+    ];
+  }
+  unifiedInitializationHook(processor) {
+    return processor.use(remarkParse).use(remarkStringify, {
+      fences: true,
+      listItemIndent: "one",
+      resourceLink: true,
+      rule: "-"
+    });
+  }
 }
-
-;// CONCATENATED MODULE: ./node_modules/ccount/index.js
-/**
- * Count how often a character (or substring) is used in a string.
- *
- * @param {string} value
- *   Value to search in.
- * @param {string} character
- *   Character (or substring) to look for.
- * @return {number}
- *   Number of times `character` occurred in `value`.
- */
 function ccount(value, character) {
-  const source = String(value)
-
-  if (typeof character !== 'string') {
-    throw new TypeError('Expected character')
-  }
-
-  let count = 0
-  let index = source.indexOf(character)
-
+  const source = String(value);
+  if (typeof character !== "string") {
+    throw new TypeError("Expected character");
+  }
+  let count = 0;
+  let index = source.indexOf(character);
   while (index !== -1) {
-    count++
-    index = source.indexOf(character, index + character.length)
-  }
-
-  return count
-}
-
-;// CONCATENATED MODULE: ./node_modules/devlop/lib/default.js
-function deprecate(fn) {
-  return fn
-}
-
-function equal() {}
-
-function ok() {}
-
-function unreachable() {}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-util-character/index.js
-/**
- * @typedef {import('micromark-util-types').Code} Code
- */
-
-/**
- * Check whether the character code represents an ASCII alpha (`a` through `z`,
- * case insensitive).
- *
- * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.
- *
- * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)
- * to U+005A (`Z`).
- *
- * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)
- * to U+007A (`z`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
+    count++;
+    index = source.indexOf(character, index + character.length);
+  }
+  return count;
+}
+function ok$1() {
+}
 const asciiAlpha = regexCheck(/[A-Za-z]/);
-
-/**
- * Check whether the character code represents an ASCII alphanumeric (`a`
- * through `z`, case insensitive, or `0` through `9`).
- *
- * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha
- * (see `asciiAlpha`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
 const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
-
-/**
- * Check whether the character code represents an ASCII atext.
- *
- * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in
- * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),
- * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F
- * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E
- * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE
- * (`{`) to U+007E TILDE (`~`).
- *
- * See:
- * **\[RFC5322]**:
- * [Internet Message Format](https://tools.ietf.org/html/rfc5322).
- * P. Resnick.
- * IETF.
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
-
-/**
- * Check whether a character code is an ASCII control character.
- *
- * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)
- * to U+001F (US), or U+007F (DEL).
- *
- * @param {Code} code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-function asciiControl(code) {
+function asciiControl(code2) {
   return (
     // Special whitespace codes (which have negative values), C0 and Control
     // character DEL
-    code !== null && (code < 32 || code === 127)
+    code2 !== null && (code2 < 32 || code2 === 127)
   );
 }
-
-/**
- * Check whether the character code represents an ASCII digit (`0` through `9`).
- *
- * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to
- * U+0039 (`9`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-const asciiDigit = regexCheck(/\d/);
-
-/**
- * Check whether the character code represents an ASCII hex digit (`a` through
- * `f`, case insensitive, or `0` through `9`).
- *
- * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex
- * digit, or an ASCII lower hex digit.
- *
- * An **ASCII upper hex digit** is a character in the inclusive range U+0041
- * (`A`) to U+0046 (`F`).
- *
- * An **ASCII lower hex digit** is a character in the inclusive range U+0061
- * (`a`) to U+0066 (`f`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
-
-/**
- * Check whether the character code represents ASCII punctuation.
- *
- * An **ASCII punctuation** is a character in the inclusive ranges U+0021
- * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT
- * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT
- * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
-
-/**
- * Check whether a character code is a markdown line ending.
- *
- * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN
- * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).
- *
- * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE
- * RETURN (CR) are replaced by these virtual characters depending on whether
- * they occurred together.
- *
- * @param {Code} code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-function markdownLineEnding(code) {
-  return code !== null && code < -2;
-}
-
-/**
- * Check whether a character code is a markdown line ending (see
- * `markdownLineEnding`) or markdown space (see `markdownSpace`).
- *
- * @param {Code} code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-function markdownLineEndingOrSpace(code) {
-  return code !== null && (code < 0 || code === 32);
-}
-
-/**
- * Check whether a character code is a markdown space.
- *
- * A **markdown space** is the concrete character U+0020 SPACE (SP) and the
- * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).
- *
- * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is
- * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL
- * SPACE (VS) characters, depending on the column at which the tab occurred.
- *
- * @param {Code} code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-function markdownSpace(code) {
-  return code === -2 || code === -1 || code === 32;
-}
-
-// Size note: removing ASCII from the regex and using `asciiPunctuation` here
-// In fact adds to the bundle size.
-/**
- * Check whether the character code represents Unicode punctuation.
- *
- * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,
- * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`
- * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`
- * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII
- * punctuation (see `asciiPunctuation`).
- *
- * See:
- * **\[UNICODE]**:
- * [The Unicode Standard](https://www.unicode.org/versions/).
- * Unicode Consortium.
- *
- * @param code
- *   Code.
- * @returns
- *   Whether it matches.
- */
-const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
-
-/**
- * Check whether the character code represents Unicode whitespace.
- *
- * Note that this does handle micromark specific markdown whitespace characters.
- * See `markdownLineEndingOrSpace` to check that.
- *
- * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,
- * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),
- * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\[UNICODE]**).
- *
- * See:
- * **\[UNICODE]**:
- * [The Unicode Standard](https://www.unicode.org/versions/).
- * Unicode Consortium.
- *
- * @param code
- *   Code.
- * @returns
- *   Whether it matches.
- */
+function markdownLineEnding(code2) {
+  return code2 !== null && code2 < -2;
+}
+function markdownLineEndingOrSpace(code2) {
+  return code2 !== null && (code2 < 0 || code2 === 32);
+}
+function markdownSpace(code2) {
+  return code2 === -2 || code2 === -1 || code2 === 32;
+}
+const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
 const unicodeWhitespace = regexCheck(/\s/);
-
-/**
- * Create a code check from a regex.
- *
- * @param {RegExp} regex
- * @returns {(code: Code) => boolean}
- */
 function regexCheck(regex) {
   return check;
-
-  /**
-   * Check whether a code matches the bound regex.
-   *
-   * @param {Code} code
-   *   Character code.
-   * @returns {boolean}
-   *   Whether the character code matches the bound regex.
-   */
-  function check(code) {
-    return code !== null && code > -1 && regex.test(String.fromCharCode(code));
+  function check(code2) {
+    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
   }
 }
-;// CONCATENATED MODULE: ./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
 function escapeStringRegexp(string) {
-	if (typeof string !== 'string') {
-		throw new TypeError('Expected a string');
-	}
-
-	// Escape characters with special meaning either inside or outside character sets.
-	// Use a simple backslash escape when its always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
-	return string
-		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
-		.replace(/-/g, '\\x2d');
-}
-
-;// CONCATENATED MODULE: ./node_modules/unist-util-is/lib/index.js
-/**
- * @typedef {import('unist').Node} Node
- * @typedef {import('unist').Parent} Parent
- */
-
-/**
- * @template Fn
- * @template Fallback
- * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate
- */
-
-/**
- * @callback Check
- *   Check that an arbitrary value is a node.
- * @param {unknown} this
- *   The given context.
- * @param {unknown} [node]
- *   Anything (typically a node).
- * @param {number | null | undefined} [index]
- *   The nodes position in its parent.
- * @param {Parent | null | undefined} [parent]
- *   The nodes parent.
- * @returns {boolean}
- *   Whether this is a node and passes a test.
- *
- * @typedef {Record<string, unknown> | Node} Props
- *   Object to check for equivalence.
- *
- *   Note: `Node` is included as it is common but is not indexable.
- *
- * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test
- *   Check for an arbitrary node.
- *
- * @callback TestFunction
- *   Check if a node passes a test.
- * @param {unknown} this
- *   The given context.
- * @param {Node} node
- *   A node.
- * @param {number | undefined} [index]
- *   The nodes position in its parent.
- * @param {Parent | undefined} [parent]
- *   The nodes parent.
- * @returns {boolean | undefined | void}
- *   Whether this node passes the test.
- *
- *   Note: `void` is included until TS sees no return as `undefined`.
- */
-
-/**
- * Check if `node` is a `Node` and whether it passes the given test.
- *
- * @param {unknown} node
- *   Thing to check, typically `Node`.
- * @param {Test} test
- *   A check for a specific node.
- * @param {number | null | undefined} index
- *   The nodes position in its parent.
- * @param {Parent | null | undefined} parent
- *   The nodes parent.
- * @param {unknown} context
- *   Context object (`this`) to pass to `test` functions.
- * @returns {boolean}
- *   Whether `node` is a node and passes a test.
- */
-const is =
-  // Note: overloads in JSDoc cant yet use different `@template`s.
-  /**
-   * @type {(
-   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
-   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
-   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
-   *   ((node?: null | undefined) => false) &
-   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
-   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)
-   * )}
-   */
-  (
-    /**
-     * @param {unknown} [node]
-     * @param {Test} [test]
-     * @param {number | null | undefined} [index]
-     * @param {Parent | null | undefined} [parent]
-     * @param {unknown} [context]
-     * @returns {boolean}
-     */
-    // eslint-disable-next-line max-params
-    function (node, test, index, parent, context) {
-      const check = convert(test)
-
-      if (
-        index !== undefined &&
-        index !== null &&
-        (typeof index !== 'number' ||
-          index < 0 ||
-          index === Number.POSITIVE_INFINITY)
-      ) {
-        throw new Error('Expected positive finite index')
-      }
-
-      if (
-        parent !== undefined &&
-        parent !== null &&
-        (!is(parent) || !parent.children)
-      ) {
-        throw new Error('Expected parent node')
-      }
-
-      if (
-        (parent === undefined || parent === null) !==
-        (index === undefined || index === null)
-      ) {
-        throw new Error('Expected both parent and index')
-      }
-
-      return looksLikeANode(node)
-        ? check.call(context, node, index, parent)
-        : false
-    }
-  )
-
-/**
- * Generate an assertion from a test.
- *
- * Useful if youre going to test many nodes, for example when creating a
- * utility where something else passes a compatible test.
- *
- * The created function is a bit faster because it expects valid input only:
- * a `node`, `index`, and `parent`.
- *
- * @param {Test} test
- *   *   when nullish, checks if `node` is a `Node`.
- *   *   when `string`, works like passing `(node) => node.type === test`.
- *   *   when `function` checks if function passed the node is true.
- *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
- *   *   when `array`, checks if any one of the subtests pass.
- * @returns {Check}
- *   An assertion.
- */
-const convert =
+  if (typeof string !== "string") {
+    throw new TypeError("Expected a string");
+  }
+  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
+}
+const convert = (
   // Note: overloads in JSDoc cant yet use different `@template`s.
   /**
    * @type {(
@@ -1636,850 +1117,268 @@ const convert =
    *   ((test?: Test) => Check)
    * )}
    */
-  (
-    /**
-     * @param {Test} [test]
-     * @returns {Check}
-     */
-    function (test) {
-      if (test === null || test === undefined) {
-        return lib_ok
-      }
-
-      if (typeof test === 'function') {
-        return castFactory(test)
-      }
-
-      if (typeof test === 'object') {
-        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
-      }
-
-      if (typeof test === 'string') {
-        return typeFactory(test)
-      }
-
-      throw new Error('Expected function, string, or object as test')
+  /**
+   * @param {Test} [test]
+   * @returns {Check}
+   */
+  function(test) {
+    if (test === null || test === void 0) {
+      return ok;
+    }
+    if (typeof test === "function") {
+      return castFactory(test);
+    }
+    if (typeof test === "object") {
+      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
+    }
+    if (typeof test === "string") {
+      return typeFactory(test);
     }
-  )
-
-/**
- * @param {Array<Props | TestFunction | string>} tests
- * @returns {Check}
- */
+    throw new Error("Expected function, string, or object as test");
+  }
+);
 function anyFactory(tests) {
-  /** @type {Array<Check>} */
-  const checks = []
-  let index = -1
-
+  const checks = [];
+  let index = -1;
   while (++index < tests.length) {
-    checks[index] = convert(tests[index])
+    checks[index] = convert(tests[index]);
   }
-
-  return castFactory(any)
-
-  /**
-   * @this {unknown}
-   * @type {TestFunction}
-   */
+  return castFactory(any);
   function any(...parameters) {
-    let index = -1
-
-    while (++index < checks.length) {
-      if (checks[index].apply(this, parameters)) return true
+    let index2 = -1;
+    while (++index2 < checks.length) {
+      if (checks[index2].apply(this, parameters)) return true;
     }
-
-    return false
+    return false;
   }
 }
-
-/**
- * Turn an object into a test for a node with a certain fields.
- *
- * @param {Props} check
- * @returns {Check}
- */
 function propsFactory(check) {
-  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)
-
-  return castFactory(all)
-
-  /**
-   * @param {Node} node
-   * @returns {boolean}
-   */
-  function all(node) {
-    const nodeAsRecord = /** @type {Record<string, unknown>} */ (
-      /** @type {unknown} */ (node)
-    )
-
-    /** @type {string} */
-    let key
-
+  const checkAsRecord = (
+    /** @type {Record<string, unknown>} */
+    check
+  );
+  return castFactory(all2);
+  function all2(node2) {
+    const nodeAsRecord = (
+      /** @type {Record<string, unknown>} */
+      /** @type {unknown} */
+      node2
+    );
+    let key;
     for (key in check) {
-      if (nodeAsRecord[key] !== checkAsRecord[key]) return false
+      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
     }
-
-    return true
+    return true;
   }
 }
-
-/**
- * Turn a string into a test for a node with a certain type.
- *
- * @param {string} check
- * @returns {Check}
- */
 function typeFactory(check) {
-  return castFactory(type)
-
-  /**
-   * @param {Node} node
-   */
-  function type(node) {
-    return node && node.type === check
+  return castFactory(type);
+  function type(node2) {
+    return node2 && node2.type === check;
   }
 }
-
-/**
- * Turn a custom test into a test for a node that passes that test.
- *
- * @param {TestFunction} testFunction
- * @returns {Check}
- */
 function castFactory(testFunction) {
-  return check
-
-  /**
-   * @this {unknown}
-   * @type {Check}
-   */
+  return check;
   function check(value, index, parent) {
     return Boolean(
-      looksLikeANode(value) &&
-        testFunction.call(
-          this,
-          value,
-          typeof index === 'number' ? index : undefined,
-          parent || undefined
-        )
-    )
+      looksLikeANode(value) && testFunction.call(
+        this,
+        value,
+        typeof index === "number" ? index : void 0,
+        parent || void 0
+      )
+    );
   }
 }
-
-function lib_ok() {
-  return true
+function ok() {
+  return true;
 }
-
-/**
- * @param {unknown} value
- * @returns {value is Node}
- */
 function looksLikeANode(value) {
-  return value !== null && typeof value === 'object' && 'type' in value
-}
-
-;// CONCATENATED MODULE: ./node_modules/unist-util-visit-parents/lib/color.js
-/**
- * @param {string} d
- * @returns {string}
- */
+  return value !== null && typeof value === "object" && "type" in value;
+}
 function color(d) {
-  return d
-}
-
-;// CONCATENATED MODULE: ./node_modules/unist-util-visit-parents/lib/index.js
-/**
- * @typedef {import('unist').Node} UnistNode
- * @typedef {import('unist').Parent} UnistParent
- */
-
-/**
- * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test
- *   Test from `unist-util-is`.
- *
- *   Note: we have remove and add `undefined`, because otherwise when generating
- *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,
- *   which doesnt work when publishing on npm.
- */
-
-/**
- * @typedef {(
- *   Fn extends (value: any) => value is infer Thing
- *   ? Thing
- *   : Fallback
- * )} Predicate
- *   Get the value of a type guard `Fn`.
- * @template Fn
- *   Value; typically function that is a type guard (such as `(x): x is Y`).
- * @template Fallback
- *   Value to yield if `Fn` is not a type guard.
- */
-
-/**
- * @typedef {(
- *   Check extends null | undefined // No test.
- *   ? Value
- *   : Value extends {type: Check} // String (type) test.
- *   ? Value
- *   : Value extends Check // Partial test.
- *   ? Value
- *   : Check extends Function // Function test.
- *   ? Predicate<Check, Value> extends Value
- *     ? Predicate<Check, Value>
- *     : never
- *   : never // Some other test?
- * )} MatchesOne
- *   Check whether a node matches a primitive check in the type system.
- * @template Value
- *   Value; typically unist `Node`.
- * @template Check
- *   Value; typically `unist-util-is`-compatible test, but not arrays.
- */
-
-/**
- * @typedef {(
- *   Check extends Array<any>
- *   ? MatchesOne<Value, Check[keyof Check]>
- *   : MatchesOne<Value, Check>
- * )} Matches
- *   Check whether a node matches a check in the type system.
- * @template Value
- *   Value; typically unist `Node`.
- * @template Check
- *   Value; typically `unist-util-is`-compatible test.
- */
-
-/**
- * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint
- *   Number; capped reasonably.
- */
-
-/**
- * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment
- *   Increment a number in the type system.
- * @template {Uint} [I=0]
- *   Index.
- */
-
-/**
- * @typedef {(
- *   Node extends UnistParent
- *   ? Node extends {children: Array<infer Children>}
- *     ? Child extends Children ? Node : never
- *     : never
- *   : never
- * )} InternalParent
- *   Collect nodes that can be parents of `Child`.
- * @template {UnistNode} Node
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent
- *   Collect nodes in `Tree` that can be parents of `Child`.
- * @template {UnistNode} Tree
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {(
- *   Depth extends Max
- *   ? never
- *   :
- *     | InternalParent<Node, Child>
- *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>
- * )} InternalAncestor
- *   Collect nodes in `Tree` that can be ancestors of `Child`.
- * @template {UnistNode} Node
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- * @template {Uint} [Max=10]
- *   Max; searches up to this depth.
- * @template {Uint} [Depth=0]
- *   Current depth.
- */
-
-/**
- * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor
- *   Collect nodes in `Tree` that can be ancestors of `Child`.
- * @template {UnistNode} Tree
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {(
- *   Tree extends UnistParent
- *     ? Depth extends Max
- *       ? Tree
- *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>
- *     : Tree
- * )} InclusiveDescendant
- *   Collect all (inclusive) descendants of `Tree`.
- *
- *   >  **Note**: for performance reasons, this seems to be the fastest way to
- *   > recurse without actually running into an infinite loop, which the
- *   > previous version did.
- *   >
- *   > Practically, a max of `2` is typically enough assuming a `Root` is
- *   > passed, but it doesnt improve performance.
- *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.
- *   > Using up to `10` doesnt hurt or help either.
- * @template {UnistNode} Tree
- *   Tree type.
- * @template {Uint} [Max=10]
- *   Max; searches up to this depth.
- * @template {Uint} [Depth=0]
- *   Current depth.
- */
-
-/**
- * @typedef {'skip' | boolean} Action
- *   Union of the action types.
- *
- * @typedef {number} Index
- *   Move to the sibling at `index` next (after node itself is completely
- *   traversed).
- *
- *   Useful if mutating the tree, such as removing the node the visitor is
- *   currently on, or any of its previous siblings.
- *   Results less than 0 or greater than or equal to `children.length` stop
- *   traversing the parent.
- *
- * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple
- *   List with one or two values, the first an action, the second an index.
- *
- * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult
- *   Any value that can be returned from a visitor.
- */
-
-/**
- * @callback Visitor
- *   Handle a node (matching `test`, if given).
- *
- *   Visitors are free to transform `node`.
- *   They can also transform the parent of node (the last of `ancestors`).
- *
- *   Replacing `node` itself, if `SKIP` is not returned, still causes its
- *   descendants to be walked (which is a bug).
- *
- *   When adding or removing previous siblings of `node` (or next siblings, in
- *   case of reverse), the `Visitor` should return a new `Index` to specify the
- *   sibling to traverse after `node` is traversed.
- *   Adding or removing next siblings of `node` (or previous siblings, in case
- *   of reverse) is handled as expected without needing to return a new `Index`.
- *
- *   Removing the children property of an ancestor still results in them being
- *   traversed.
- * @param {Visited} node
- *   Found node.
- * @param {Array<VisitedParents>} ancestors
- *   Ancestors of `node`.
- * @returns {VisitorResult}
- *   What to do next.
- *
- *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
- *   An `Action` is treated as a tuple of `[Action]`.
- *
- *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
- *   When the `Action` is `EXIT`, that action can be returned.
- *   When the `Action` is `CONTINUE`, `Index` can be returned.
- * @template {UnistNode} [Visited=UnistNode]
- *   Visited node type.
- * @template {UnistParent} [VisitedParents=UnistParent]
- *   Ancestor type.
- */
-
-/**
- * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor
- *   Build a typed `Visitor` function from a tree and a test.
- *
- *   It will infer which values are passed as `node` and which as `parents`.
- * @template {UnistNode} [Tree=UnistNode]
- *   Tree type.
- * @template {Test} [Check=Test]
- *   Test type.
- */
-
-
-
-
-/** @type {Readonly<ActionTuple>} */
-const empty = []
-
-/**
- * Continue traversing as normal.
- */
-const CONTINUE = true
-
-/**
- * Stop traversing immediately.
- */
-const EXIT = false
-
-/**
- * Do not traverse this nodes children.
- */
-const SKIP = 'skip'
-
-/**
- * Visit nodes, with ancestral information.
- *
- * This algorithm performs *depth-first* *tree traversal* in *preorder*
- * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
- *
- * You can choose for which nodes `visitor` is called by passing a `test`.
- * For complex tests, you should test yourself in `visitor`, as it will be
- * faster and will have improved type information.
- *
- * Walking the tree is an intensive task.
- * Make use of the return values of the visitor when possible.
- * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
- * to check if a node matches, and then perform different operations.
- *
- * You can change the tree.
- * See `Visitor` for more info.
- *
- * @overload
- * @param {Tree} tree
- * @param {Check} check
- * @param {BuildVisitor<Tree, Check>} visitor
- * @param {boolean | null | undefined} [reverse]
- * @returns {undefined}
- *
- * @overload
- * @param {Tree} tree
- * @param {BuildVisitor<Tree>} visitor
- * @param {boolean | null | undefined} [reverse]
- * @returns {undefined}
- *
- * @param {UnistNode} tree
- *   Tree to traverse.
- * @param {Visitor | Test} test
- *   `unist-util-is`-compatible test
- * @param {Visitor | boolean | null | undefined} [visitor]
- *   Handle each node.
- * @param {boolean | null | undefined} [reverse]
- *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
- * @returns {undefined}
- *   Nothing.
- *
- * @template {UnistNode} Tree
- *   Node type.
- * @template {Test} Check
- *   `unist-util-is`-compatible test.
- */
+  return d;
+}
+const empty = [];
+const CONTINUE = true;
+const EXIT = false;
+const SKIP = "skip";
 function visitParents(tree, test, visitor, reverse) {
-  /** @type {Test} */
-  let check
-
-  if (typeof test === 'function' && typeof visitor !== 'function') {
-    reverse = visitor
-    // @ts-expect-error no visitor given, so `visitor` is test.
-    visitor = test
+  let check;
+  if (typeof test === "function" && typeof visitor !== "function") {
+    reverse = visitor;
+    visitor = test;
   } else {
-    // @ts-expect-error visitor given, so `test` isnt a visitor.
-    check = test
-  }
-
-  const is = convert(check)
-  const step = reverse ? -1 : 1
-
-  factory(tree, undefined, [])()
-
-  /**
-   * @param {UnistNode} node
-   * @param {number | undefined} index
-   * @param {Array<UnistParent>} parents
-   */
-  function factory(node, index, parents) {
-    const value = /** @type {Record<string, unknown>} */ (
-      node && typeof node === 'object' ? node : {}
-    )
-
-    if (typeof value.type === 'string') {
-      const name =
+    check = test;
+  }
+  const is = convert(check);
+  const step = reverse ? -1 : 1;
+  factory(tree, void 0, [])();
+  function factory(node2, index, parents) {
+    const value = (
+      /** @type {Record<string, unknown>} */
+      node2 && typeof node2 === "object" ? node2 : {}
+    );
+    if (typeof value.type === "string") {
+      const name = (
         // `hast`
-        typeof value.tagName === 'string'
-          ? value.tagName
-          : // `xast`
-          typeof value.name === 'string'
-          ? value.name
-          : undefined
-
-      Object.defineProperty(visit, 'name', {
-        value:
-          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'
-      })
-    }
-
-    return visit
-
-    function visit() {
-      /** @type {Readonly<ActionTuple>} */
-      let result = empty
-      /** @type {Readonly<ActionTuple>} */
-      let subresult
-      /** @type {number} */
-      let offset
-      /** @type {Array<UnistParent>} */
-      let grandparents
-
-      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {
-        // @ts-expect-error: `visitor` is now a visitor.
-        result = toResult(visitor(node, parents))
-
+        typeof value.tagName === "string" ? value.tagName : (
+          // `xast`
+          typeof value.name === "string" ? value.name : void 0
+        )
+      );
+      Object.defineProperty(visit2, "name", {
+        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
+      });
+    }
+    return visit2;
+    function visit2() {
+      let result = empty;
+      let subresult;
+      let offset;
+      let grandparents;
+      if (!test || is(node2, index, parents[parents.length - 1] || void 0)) {
+        result = toResult(visitor(node2, parents));
         if (result[0] === EXIT) {
-          return result
+          return result;
         }
       }
-
-      if ('children' in node && node.children) {
-        const nodeAsParent = /** @type {UnistParent} */ (node)
-
+      if ("children" in node2 && node2.children) {
+        const nodeAsParent = (
+          /** @type {UnistParent} */
+          node2
+        );
         if (nodeAsParent.children && result[0] !== SKIP) {
-          offset = (reverse ? nodeAsParent.children.length : -1) + step
-          grandparents = parents.concat(nodeAsParent)
-
+          offset = (reverse ? nodeAsParent.children.length : -1) + step;
+          grandparents = parents.concat(nodeAsParent);
           while (offset > -1 && offset < nodeAsParent.children.length) {
-            const child = nodeAsParent.children[offset]
-
-            subresult = factory(child, offset, grandparents)()
-
+            const child = nodeAsParent.children[offset];
+            subresult = factory(child, offset, grandparents)();
             if (subresult[0] === EXIT) {
-              return subresult
+              return subresult;
             }
-
-            offset =
-              typeof subresult[1] === 'number' ? subresult[1] : offset + step
+            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
           }
         }
       }
-
-      return result
+      return result;
     }
   }
 }
-
-/**
- * Turn a return value into a clean result.
- *
- * @param {VisitorResult} value
- *   Valid return values from visitors.
- * @returns {Readonly<ActionTuple>}
- *   Clean result.
- */
 function toResult(value) {
   if (Array.isArray(value)) {
-    return value
-  }
-
-  if (typeof value === 'number') {
-    return [CONTINUE, value]
-  }
-
-  return value === null || value === undefined ? empty : [value]
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-find-and-replace/lib/index.js
-/**
- * @typedef {import('mdast').Nodes} Nodes
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').PhrasingContent} PhrasingContent
- * @typedef {import('mdast').Root} Root
- * @typedef {import('mdast').Text} Text
- * @typedef {import('unist-util-visit-parents').Test} Test
- * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
- */
-
-/**
- * @typedef RegExpMatchObject
- *   Info on the match.
- * @property {number} index
- *   The index of the search at which the result was found.
- * @property {string} input
- *   A copy of the search string in the text node.
- * @property {[...Array<Parents>, Text]} stack
- *   All ancestors of the text node, where the last node is the text itself.
- *
- * @typedef {RegExp | string} Find
- *   Pattern to find.
- *
- *   Strings are escaped and then turned into global expressions.
- *
- * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList
- *   Several find and replaces, in array form.
- *
- * @typedef {[Find, Replace?]} FindAndReplaceTuple
- *   Find and replace in tuple form.
- *
- * @typedef {ReplaceFunction | string | null | undefined} Replace
- *   Thing to replace with.
- *
- * @callback ReplaceFunction
- *   Callback called when a search matches.
- * @param {...any} parameters
- *   The parameters are the result of corresponding search expression:
- *
- *   * `value` (`string`)  whole match
- *   * `...capture` (`Array<string>`)  matches from regex capture groups
- *   * `match` (`RegExpMatchObject`)  info on the match
- * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}
- *   Thing to replace with.
- *
- *   * when `null`, `undefined`, `''`, remove the match
- *   * or when `false`, do not replace at all
- *   * or when `string`, replace with a text node of that value
- *   * or when `Node` or `Array<Node>`, replace with those nodes
- *
- * @typedef {[RegExp, ReplaceFunction]} Pair
- *   Normalized find and replace.
- *
- * @typedef {Array<Pair>} Pairs
- *   All find and replaced.
- *
- * @typedef Options
- *   Configuration.
- * @property {Test | null | undefined} [ignore]
- *   Test for which nodes to ignore (optional).
- */
-
-
-
-
-
-/**
- * Find patterns in a tree and replace them.
- *
- * The algorithm searches the tree in *preorder* for complete values in `Text`
- * nodes.
- * Partial matches are not supported.
- *
- * @param {Nodes} tree
- *   Tree to change.
- * @param {FindAndReplaceList | FindAndReplaceTuple} list
- *   Patterns to find.
- * @param {Options | null | undefined} [options]
- *   Configuration (when `find` is not `Find`).
- * @returns {undefined}
- *   Nothing.
- */
-function findAndReplace(tree, list, options) {
-  const settings = options || {}
-  const ignored = convert(settings.ignore || [])
-  const pairs = toPairs(list)
-  let pairIndex = -1
-
+    return value;
+  }
+  if (typeof value === "number") {
+    return [CONTINUE, value];
+  }
+  return value === null || value === void 0 ? empty : [value];
+}
+function findAndReplace(tree, list2, options) {
+  const settings = options;
+  const ignored = convert(settings.ignore || []);
+  const pairs = toPairs(list2);
+  let pairIndex = -1;
   while (++pairIndex < pairs.length) {
-    visitParents(tree, 'text', visitor)
-  }
-
-  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */
-  function visitor(node, parents) {
-    let index = -1
-    /** @type {Parents | undefined} */
-    let grandparent
-
+    visitParents(tree, "text", visitor);
+  }
+  function visitor(node2, parents) {
+    let index = -1;
+    let grandparent;
     while (++index < parents.length) {
-      const parent = parents[index]
-      /** @type {Array<Nodes> | undefined} */
-      const siblings = grandparent ? grandparent.children : undefined
-
-      if (
-        ignored(
-          parent,
-          siblings ? siblings.indexOf(parent) : undefined,
-          grandparent
-        )
-      ) {
-        return
+      const parent = parents[index];
+      const siblings = grandparent ? grandparent.children : void 0;
+      if (ignored(
+        parent,
+        siblings ? siblings.indexOf(parent) : void 0,
+        grandparent
+      )) {
+        return;
       }
-
-      grandparent = parent
+      grandparent = parent;
     }
-
     if (grandparent) {
-      return handler(node, parents)
-    }
-  }
-
-  /**
-   * Handle a text node which is not in an ignored parent.
-   *
-   * @param {Text} node
-   *   Text node.
-   * @param {Array<Parents>} parents
-   *   Parents.
-   * @returns {VisitorResult}
-   *   Result.
-   */
-  function handler(node, parents) {
-    const parent = parents[parents.length - 1]
-    const find = pairs[pairIndex][0]
-    const replace = pairs[pairIndex][1]
-    let start = 0
-    /** @type {Array<Nodes>} */
-    const siblings = parent.children
-    const index = siblings.indexOf(node)
-    let change = false
-    /** @type {Array<PhrasingContent>} */
-    let nodes = []
-
-    find.lastIndex = 0
-
-    let match = find.exec(node.value)
-
+      return handler(node2, parents);
+    }
+  }
+  function handler(node2, parents) {
+    const parent = parents[parents.length - 1];
+    const find = pairs[pairIndex][0];
+    const replace = pairs[pairIndex][1];
+    let start = 0;
+    const siblings = parent.children;
+    const index = siblings.indexOf(node2);
+    let change = false;
+    let nodes = [];
+    find.lastIndex = 0;
+    let match = find.exec(node2.value);
     while (match) {
-      const position = match.index
-      /** @type {RegExpMatchObject} */
+      const position = match.index;
       const matchObject = {
         index: match.index,
         input: match.input,
-        stack: [...parents, node]
+        stack: [...parents, node2]
+      };
+      let value = replace(...match, matchObject);
+      if (typeof value === "string") {
+        value = value.length > 0 ? { type: "text", value } : void 0;
       }
-      let value = replace(...match, matchObject)
-
-      if (typeof value === 'string') {
-        value = value.length > 0 ? {type: 'text', value} : undefined
-      }
-
-      // It wasnt a match after all.
       if (value === false) {
-        // False acts as if there was no match.
-        // So we need to reset `lastIndex`, which currently being at the end of
-        // the current match, to the beginning.
-        find.lastIndex = position + 1
+        find.lastIndex = position + 1;
       } else {
         if (start !== position) {
           nodes.push({
-            type: 'text',
-            value: node.value.slice(start, position)
-          })
+            type: "text",
+            value: node2.value.slice(start, position)
+          });
         }
-
         if (Array.isArray(value)) {
-          nodes.push(...value)
+          nodes.push(...value);
         } else if (value) {
-          nodes.push(value)
+          nodes.push(value);
         }
-
-        start = position + match[0].length
-        change = true
+        start = position + match[0].length;
+        change = true;
       }
-
       if (!find.global) {
-        break
+        break;
       }
-
-      match = find.exec(node.value)
+      match = find.exec(node2.value);
     }
-
     if (change) {
-      if (start < node.value.length) {
-        nodes.push({type: 'text', value: node.value.slice(start)})
+      if (start < node2.value.length) {
+        nodes.push({ type: "text", value: node2.value.slice(start) });
       }
-
-      parent.children.splice(index, 1, ...nodes)
+      parent.children.splice(index, 1, ...nodes);
     } else {
-      nodes = [node]
+      nodes = [node2];
     }
-
-    return index + nodes.length
-  }
-}
-
-/**
- * Turn a tuple or a list of tuples into pairs.
- *
- * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList
- *   Schema.
- * @returns {Pairs}
- *   Clean pairs.
- */
+    return index + nodes.length;
+  }
+}
 function toPairs(tupleOrList) {
-  /** @type {Pairs} */
-  const result = []
-
+  const result = [];
   if (!Array.isArray(tupleOrList)) {
-    throw new TypeError('Expected find and replace tuple or list of tuples')
-  }
-
-  /** @type {FindAndReplaceList} */
-  // @ts-expect-error: correct.
-  const list =
-    !tupleOrList[0] || Array.isArray(tupleOrList[0])
-      ? tupleOrList
-      : [tupleOrList]
-
-  let index = -1
-
-  while (++index < list.length) {
-    const tuple = list[index]
-    result.push([toExpression(tuple[0]), toFunction(tuple[1])])
-  }
-
-  return result
-}
-
-/**
- * Turn a find into an expression.
- *
- * @param {Find} find
- *   Find.
- * @returns {RegExp}
- *   Expression.
- */
+    throw new TypeError("Expected find and replace tuple or list of tuples");
+  }
+  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
+  let index = -1;
+  while (++index < list2.length) {
+    const tuple = list2[index];
+    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
+  }
+  return result;
+}
 function toExpression(find) {
-  return typeof find === 'string' ? new RegExp(escapeStringRegexp(find), 'g') : find
-}
-
-/**
- * Turn a replace into a function.
- *
- * @param {Replace} replace
- *   Replace.
- * @returns {ReplaceFunction}
- *   Function.
- */
+  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
+}
 function toFunction(replace) {
-  return typeof replace === 'function'
-    ? replace
-    : function () {
-        return replace
-      }
+  return typeof replace === "function" ? replace : function() {
+    return replace;
+  };
 }
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-gfm-autolink-literal/lib/index.js
-/**
- * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'
- * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'
- * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'
- * @import {Link, PhrasingContent} from 'mdast'
- */
-
-
-
-
-
-
-/** @type {ConstructName} */
-const inConstruct = 'phrasing'
-/** @type {Array<ConstructName>} */
-const notInConstruct = ['autolink', 'link', 'image', 'label']
-
-/**
- * Create an extension for `mdast-util-from-markdown` to enable GFM autolink
- * literals in markdown.
- *
- * @returns {FromMarkdownExtension}
- *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.
- */
+const inConstruct = "phrasing";
+const notInConstruct = ["autolink", "link", "image", "label"];
 function gfmAutolinkLiteralFromMarkdown() {
   return {
     transforms: [transformGfmAutolinkLiterals],
@@ -2495,254 +1394,137 @@ function gfmAutolinkLiteralFromMarkdown() {
       literalAutolinkHttp: exitLiteralAutolinkHttp,
       literalAutolinkWww: exitLiteralAutolinkWww
     }
-  }
+  };
 }
-
-/**
- * Create an extension for `mdast-util-to-markdown` to enable GFM autolink
- * literals in markdown.
- *
- * @returns {ToMarkdownExtension}
- *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.
- */
 function gfmAutolinkLiteralToMarkdown() {
   return {
     unsafe: [
       {
-        character: '@',
-        before: '[+\\-.\\w]',
-        after: '[\\-.\\w]',
+        character: "@",
+        before: "[+\\-.\\w]",
+        after: "[\\-.\\w]",
         inConstruct,
         notInConstruct
       },
       {
-        character: '.',
-        before: '[Ww]',
-        after: '[\\-.\\w]',
+        character: ".",
+        before: "[Ww]",
+        after: "[\\-.\\w]",
         inConstruct,
         notInConstruct
       },
       {
-        character: ':',
-        before: '[ps]',
-        after: '\\/',
+        character: ":",
+        before: "[ps]",
+        after: "\\/",
         inConstruct,
         notInConstruct
       }
     ]
-  }
+  };
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function enterLiteralAutolink(token) {
-  this.enter({type: 'link', title: null, url: '', children: []}, token)
+  this.enter({ type: "link", title: null, url: "", children: [] }, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function enterLiteralAutolinkValue(token) {
-  this.config.enter.autolinkProtocol.call(this, token)
+  this.config.enter.autolinkProtocol.call(this, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitLiteralAutolinkHttp(token) {
-  this.config.exit.autolinkProtocol.call(this, token)
+  this.config.exit.autolinkProtocol.call(this, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitLiteralAutolinkWww(token) {
-  this.config.exit.data.call(this, token)
-  const node = this.stack[this.stack.length - 1]
-  ok(node.type === 'link')
-  node.url = 'http://' + this.sliceSerialize(token)
-}
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
+  this.config.exit.data.call(this, token);
+  const node2 = this.stack[this.stack.length - 1];
+  ok$1(node2.type === "link");
+  node2.url = "http://" + this.sliceSerialize(token);
+}
 function exitLiteralAutolinkEmail(token) {
-  this.config.exit.autolinkEmail.call(this, token)
+  this.config.exit.autolinkEmail.call(this, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitLiteralAutolink(token) {
-  this.exit(token)
+  this.exit(token);
 }
-
-/** @type {FromMarkdownTransform} */
 function transformGfmAutolinkLiterals(tree) {
   findAndReplace(
     tree,
     [
       [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
-      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, findEmail]
+      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]
     ],
-    {ignore: ['link', 'linkReference']}
-  )
-}
-
-/**
- * @type {ReplaceFunction}
- * @param {string} _
- * @param {string} protocol
- * @param {string} domain
- * @param {string} path
- * @param {RegExpMatchObject} match
- * @returns {Array<PhrasingContent> | Link | false}
- */
-// eslint-disable-next-line max-params
-function findUrl(_, protocol, domain, path, match) {
-  let prefix = ''
-
-  // Not an expected previous character.
+    { ignore: ["link", "linkReference"] }
+  );
+}
+function findUrl(_, protocol, domain2, path2, match) {
+  let prefix = "";
   if (!previous(match)) {
-    return false
+    return false;
   }
-
-  // Treat `www` as part of the domain.
   if (/^w/i.test(protocol)) {
-    domain = protocol + domain
-    protocol = ''
-    prefix = 'http://'
-  }
-
-  if (!isCorrectDomain(domain)) {
-    return false
-  }
-
-  const parts = splitUrl(domain + path)
-
-  if (!parts[0]) return false
-
-  /** @type {Link} */
+    domain2 = protocol + domain2;
+    protocol = "";
+    prefix = "http://";
+  }
+  if (!isCorrectDomain(domain2)) {
+    return false;
+  }
+  const parts = splitUrl(domain2 + path2);
+  if (!parts[0]) return false;
   const result = {
-    type: 'link',
+    type: "link",
     title: null,
     url: prefix + protocol + parts[0],
-    children: [{type: 'text', value: protocol + parts[0]}]
-  }
-
+    children: [{ type: "text", value: protocol + parts[0] }]
+  };
   if (parts[1]) {
-    return [result, {type: 'text', value: parts[1]}]
-  }
-
-  return result
-}
-
-/**
- * @type {ReplaceFunction}
- * @param {string} _
- * @param {string} atext
- * @param {string} label
- * @param {RegExpMatchObject} match
- * @returns {Link | false}
- */
+    return [result, { type: "text", value: parts[1] }];
+  }
+  return result;
+}
 function findEmail(_, atext, label, match) {
   if (
     // Not an expected previous character.
-    !previous(match, true) ||
-    // Label ends in not allowed character.
+    !previous(match, true) || // Label ends in not allowed character.
     /[-\d_]$/.test(label)
   ) {
-    return false
+    return false;
   }
-
   return {
-    type: 'link',
+    type: "link",
     title: null,
-    url: 'mailto:' + atext + '@' + label,
-    children: [{type: 'text', value: atext + '@' + label}]
-  }
-}
-
-/**
- * @param {string} domain
- * @returns {boolean}
- */
-function isCorrectDomain(domain) {
-  const parts = domain.split('.')
-
-  if (
-    parts.length < 2 ||
-    (parts[parts.length - 1] &&
-      (/_/.test(parts[parts.length - 1]) ||
-        !/[a-zA-Z\d]/.test(parts[parts.length - 1]))) ||
-    (parts[parts.length - 2] &&
-      (/_/.test(parts[parts.length - 2]) ||
-        !/[a-zA-Z\d]/.test(parts[parts.length - 2])))
-  ) {
-    return false
+    url: "mailto:" + atext + "@" + label,
+    children: [{ type: "text", value: atext + "@" + label }]
+  };
+}
+function isCorrectDomain(domain2) {
+  const parts = domain2.split(".");
+  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
+    return false;
   }
-
-  return true
+  return true;
 }
-
-/**
- * @param {string} url
- * @returns {[string, string | undefined]}
- */
 function splitUrl(url) {
-  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url)
-
+  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
   if (!trailExec) {
-    return [url, undefined]
-  }
-
-  url = url.slice(0, trailExec.index)
-
-  let trail = trailExec[0]
-  let closingParenIndex = trail.indexOf(')')
-  const openingParens = ccount(url, '(')
-  let closingParens = ccount(url, ')')
-
+    return [url, void 0];
+  }
+  url = url.slice(0, trailExec.index);
+  let trail2 = trailExec[0];
+  let closingParenIndex = trail2.indexOf(")");
+  const openingParens = ccount(url, "(");
+  let closingParens = ccount(url, ")");
   while (closingParenIndex !== -1 && openingParens > closingParens) {
-    url += trail.slice(0, closingParenIndex + 1)
-    trail = trail.slice(closingParenIndex + 1)
-    closingParenIndex = trail.indexOf(')')
-    closingParens++
-  }
-
-  return [url, trail]
-}
-
-/**
- * @param {RegExpMatchObject} match
- * @param {boolean | null | undefined} [email=false]
- * @returns {boolean}
- */
+    url += trail2.slice(0, closingParenIndex + 1);
+    trail2 = trail2.slice(closingParenIndex + 1);
+    closingParenIndex = trail2.indexOf(")");
+    closingParens++;
+  }
+  return [url, trail2];
+}
 function previous(match, email) {
-  const code = match.input.charCodeAt(match.index - 1)
-
-  return (
-    (match.index === 0 ||
-      unicodeWhitespace(code) ||
-      unicodePunctuation(code)) &&
-    // If its an email, the previous character should not be a slash.
-    (!email || code !== 47)
-  )
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
-/**
- * @import {Code, ConstructRecord, Event, Extension, Previous, State, TokenizeContext, Tokenizer} from 'micromark-util-types'
- */
-
-
+  const code2 = match.input.charCodeAt(match.index - 1);
+  return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && // If its an email, the previous character should not be a slash.
+  (!email || code2 !== 47);
+}
 const wwwPrefix = {
   tokenize: tokenizeWwwPrefix,
   partial: true
@@ -2764,1150 +1546,451 @@ const emailDomainDotTrail = {
   partial: true
 };
 const wwwAutolink = {
-  name: 'wwwAutolink',
+  name: "wwwAutolink",
   tokenize: tokenizeWwwAutolink,
   previous: previousWww
 };
 const protocolAutolink = {
-  name: 'protocolAutolink',
+  name: "protocolAutolink",
   tokenize: tokenizeProtocolAutolink,
   previous: previousProtocol
 };
 const emailAutolink = {
-  name: 'emailAutolink',
+  name: "emailAutolink",
   tokenize: tokenizeEmailAutolink,
   previous: previousEmail
 };
-
-/** @type {ConstructRecord} */
-const syntax_text = {};
-
-/**
- * Create an extension for `micromark` to support GitHub autolink literal
- * syntax.
- *
- * @returns {Extension}
- *   Extension for `micromark` that can be passed in `extensions` to enable GFM
- *   autolink literal syntax.
- */
+const text$1 = {};
 function gfmAutolinkLiteral() {
   return {
-    text: syntax_text
+    text: text$1
   };
 }
-
-/** @type {Code} */
-let code = 48;
-
-// Add alphanumerics.
-while (code < 123) {
-  syntax_text[code] = emailAutolink;
-  code++;
-  if (code === 58) code = 65;else if (code === 91) code = 97;
-}
-syntax_text[43] = emailAutolink;
-syntax_text[45] = emailAutolink;
-syntax_text[46] = emailAutolink;
-syntax_text[95] = emailAutolink;
-syntax_text[72] = [emailAutolink, protocolAutolink];
-syntax_text[104] = [emailAutolink, protocolAutolink];
-syntax_text[87] = [emailAutolink, wwwAutolink];
-syntax_text[119] = [emailAutolink, wwwAutolink];
-
-// To do: perform email autolink literals on events, afterwards.
-// Thats where `markdown-rs` and `cmark-gfm` perform it.
-// It should look for `@`, then for atext backwards, and then for a label
-// forwards.
-// To do: `mailto:`, `xmpp:` protocol as prefix.
-
-/**
- * Email autolink literal.
- *
- * ```markdown
- * > | a contact@example.org b
- *       ^^^^^^^^^^^^^^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeEmailAutolink(effects, ok, nok) {
+let code$1 = 48;
+while (code$1 < 123) {
+  text$1[code$1] = emailAutolink;
+  code$1++;
+  if (code$1 === 58) code$1 = 65;
+  else if (code$1 === 91) code$1 = 97;
+}
+text$1[43] = emailAutolink;
+text$1[45] = emailAutolink;
+text$1[46] = emailAutolink;
+text$1[95] = emailAutolink;
+text$1[72] = [emailAutolink, protocolAutolink];
+text$1[104] = [emailAutolink, protocolAutolink];
+text$1[87] = [emailAutolink, wwwAutolink];
+text$1[119] = [emailAutolink, wwwAutolink];
+function tokenizeEmailAutolink(effects, ok2, nok) {
   const self = this;
-  /** @type {boolean | undefined} */
   let dot;
-  /** @type {boolean} */
   let data;
   return start;
-
-  /**
-   * Start of email autolink literal.
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *       ^
-   * ```
-   *
-   * @type {State}
-   */
-  function start(code) {
-    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {
-      return nok(code);
+  function start(code2) {
+    if (!gfmAtext(code2) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {
+      return nok(code2);
     }
-    effects.enter('literalAutolink');
-    effects.enter('literalAutolinkEmail');
-    return atext(code);
+    effects.enter("literalAutolink");
+    effects.enter("literalAutolinkEmail");
+    return atext(code2);
   }
-
-  /**
-   * In email atext.
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *       ^
-   * ```
-   *
-   * @type {State}
-   */
-  function atext(code) {
-    if (gfmAtext(code)) {
-      effects.consume(code);
+  function atext(code2) {
+    if (gfmAtext(code2)) {
+      effects.consume(code2);
       return atext;
     }
-    if (code === 64) {
-      effects.consume(code);
+    if (code2 === 64) {
+      effects.consume(code2);
       return emailDomain;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * In email domain.
-   *
-   * The reference code is a bit overly complex as it handles the `@`, of which
-   * there may be just one.
-   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *               ^
-   * ```
-   *
-   * @type {State}
-   */
-  function emailDomain(code) {
-    // Dot followed by alphanumerical (not `-` or `_`).
-    if (code === 46) {
-      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);
+  function emailDomain(code2) {
+    if (code2 === 46) {
+      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code2);
     }
-
-    // Alphanumerical, `-`, and `_`.
-    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {
+    if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
       data = true;
-      effects.consume(code);
+      effects.consume(code2);
       return emailDomain;
     }
-
-    // To do: `/` if xmpp.
-
-    // Note: normally wed truncate trailing punctuation from the link.
-    // However, email autolink literals cannot contain any of those markers,
-    // except for `.`, but that can only occur if it isnt trailing.
-    // So we can ignore truncating!
-    return emailDomainAfter(code);
-  }
-
-  /**
-   * In email domain, on dot that is not a trail.
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *                      ^
-   * ```
-   *
-   * @type {State}
-   */
-  function emailDomainDot(code) {
-    effects.consume(code);
+    return emailDomainAfter(code2);
+  }
+  function emailDomainDot(code2) {
+    effects.consume(code2);
     dot = true;
     return emailDomain;
   }
-
-  /**
-   * After email domain.
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *                          ^
-   * ```
-   *
-   * @type {State}
-   */
-  function emailDomainAfter(code) {
-    // Domain must not be empty, must include a dot, and must end in alphabetical.
-    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.
+  function emailDomainAfter(code2) {
     if (data && dot && asciiAlpha(self.previous)) {
-      effects.exit('literalAutolinkEmail');
-      effects.exit('literalAutolink');
-      return ok(code);
+      effects.exit("literalAutolinkEmail");
+      effects.exit("literalAutolink");
+      return ok2(code2);
     }
-    return nok(code);
-  }
-}
-
-/**
- * `www` autolink literal.
- *
- * ```markdown
- * > | a www.example.org b
- *       ^^^^^^^^^^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeWwwAutolink(effects, ok, nok) {
+    return nok(code2);
+  }
+}
+function tokenizeWwwAutolink(effects, ok2, nok) {
   const self = this;
   return wwwStart;
-
-  /**
-   * Start of www autolink literal.
-   *
-   * ```markdown
-   * > | www.example.com/a?b#c
-   *     ^
-   * ```
-   *
-   * @type {State}
-   */
-  function wwwStart(code) {
-    if (code !== 87 && code !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {
-      return nok(code);
+  function wwwStart(code2) {
+    if (code2 !== 87 && code2 !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {
+      return nok(code2);
     }
-    effects.enter('literalAutolink');
-    effects.enter('literalAutolinkWww');
-    // Note: we *check*, so we can discard the `www.` we parsed.
-    // If it worked, we consider it as a part of the domain.
-    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);
+    effects.enter("literalAutolink");
+    effects.enter("literalAutolinkWww");
+    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code2);
   }
-
-  /**
-   * After a www autolink literal.
-   *
-   * ```markdown
-   * > | www.example.com/a?b#c
-   *                          ^
-   * ```
-   *
-   * @type {State}
-   */
-  function wwwAfter(code) {
-    effects.exit('literalAutolinkWww');
-    effects.exit('literalAutolink');
-    return ok(code);
-  }
-}
-
-/**
- * Protocol autolink literal.
- *
- * ```markdown
- * > | a https://example.org b
- *       ^^^^^^^^^^^^^^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeProtocolAutolink(effects, ok, nok) {
+  function wwwAfter(code2) {
+    effects.exit("literalAutolinkWww");
+    effects.exit("literalAutolink");
+    return ok2(code2);
+  }
+}
+function tokenizeProtocolAutolink(effects, ok2, nok) {
   const self = this;
-  let buffer = '';
+  let buffer = "";
   let seen = false;
   return protocolStart;
-
-  /**
-   * Start of protocol autolink literal.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *     ^
-   * ```
-   *
-   * @type {State}
-   */
-  function protocolStart(code) {
-    if ((code === 72 || code === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {
-      effects.enter('literalAutolink');
-      effects.enter('literalAutolinkHttp');
-      buffer += String.fromCodePoint(code);
-      effects.consume(code);
+  function protocolStart(code2) {
+    if ((code2 === 72 || code2 === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {
+      effects.enter("literalAutolink");
+      effects.enter("literalAutolinkHttp");
+      buffer += String.fromCodePoint(code2);
+      effects.consume(code2);
       return protocolPrefixInside;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * In protocol.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *     ^^^^^
-   * ```
-   *
-   * @type {State}
-   */
-  function protocolPrefixInside(code) {
-    // `5` is size of `https`
-    if (asciiAlpha(code) && buffer.length < 5) {
-      // @ts-expect-error: definitely number.
-      buffer += String.fromCodePoint(code);
-      effects.consume(code);
+  function protocolPrefixInside(code2) {
+    if (asciiAlpha(code2) && buffer.length < 5) {
+      buffer += String.fromCodePoint(code2);
+      effects.consume(code2);
       return protocolPrefixInside;
     }
-    if (code === 58) {
+    if (code2 === 58) {
       const protocol = buffer.toLowerCase();
-      if (protocol === 'http' || protocol === 'https') {
-        effects.consume(code);
+      if (protocol === "http" || protocol === "https") {
+        effects.consume(code2);
         return protocolSlashesInside;
       }
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * In slashes.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *           ^^
-   * ```
-   *
-   * @type {State}
-   */
-  function protocolSlashesInside(code) {
-    if (code === 47) {
-      effects.consume(code);
+  function protocolSlashesInside(code2) {
+    if (code2 === 47) {
+      effects.consume(code2);
       if (seen) {
         return afterProtocol;
       }
       seen = true;
       return protocolSlashesInside;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * After protocol, before domain.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *             ^
-   * ```
-   *
-   * @type {State}
-   */
-  function afterProtocol(code) {
-    // To do: this is different from `markdown-rs`:
-    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182
-    return code === null || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);
+  function afterProtocol(code2) {
+    return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code2);
   }
-
-  /**
-   * After a protocol autolink literal.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *                              ^
-   * ```
-   *
-   * @type {State}
-   */
-  function protocolAfter(code) {
-    effects.exit('literalAutolinkHttp');
-    effects.exit('literalAutolink');
-    return ok(code);
-  }
-}
-
-/**
- * `www` prefix.
- *
- * ```markdown
- * > | a www.example.org b
- *       ^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeWwwPrefix(effects, ok, nok) {
+  function protocolAfter(code2) {
+    effects.exit("literalAutolinkHttp");
+    effects.exit("literalAutolink");
+    return ok2(code2);
+  }
+}
+function tokenizeWwwPrefix(effects, ok2, nok) {
   let size = 0;
   return wwwPrefixInside;
-
-  /**
-   * In www prefix.
-   *
-   * ```markdown
-   * > | www.example.com
-   *     ^^^^
-   * ```
-   *
-   * @type {State}
-   */
-  function wwwPrefixInside(code) {
-    if ((code === 87 || code === 119) && size < 3) {
+  function wwwPrefixInside(code2) {
+    if ((code2 === 87 || code2 === 119) && size < 3) {
       size++;
-      effects.consume(code);
+      effects.consume(code2);
       return wwwPrefixInside;
     }
-    if (code === 46 && size === 3) {
-      effects.consume(code);
+    if (code2 === 46 && size === 3) {
+      effects.consume(code2);
       return wwwPrefixAfter;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * After www prefix.
-   *
-   * ```markdown
-   * > | www.example.com
-   *         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function wwwPrefixAfter(code) {
-    // If there is *anything*, we can link.
-    return code === null ? nok(code) : ok(code);
-  }
-}
-
-/**
- * Domain.
- *
- * ```markdown
- * > | a https://example.org b
- *               ^^^^^^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeDomain(effects, ok, nok) {
-  /** @type {boolean | undefined} */
+  function wwwPrefixAfter(code2) {
+    return code2 === null ? nok(code2) : ok2(code2);
+  }
+}
+function tokenizeDomain(effects, ok2, nok) {
   let underscoreInLastSegment;
-  /** @type {boolean | undefined} */
   let underscoreInLastLastSegment;
-  /** @type {boolean | undefined} */
   let seen;
   return domainInside;
-
-  /**
-   * In domain.
-   *
-   * ```markdown
-   * > | https://example.com/a
-   *             ^^^^^^^^^^^
-   * ```
-   *
-   * @type {State}
-   */
-  function domainInside(code) {
-    // Check whether this marker, which is a trailing punctuation
-    // marker, optionally followed by more trailing markers, and then
-    // followed by an end.
-    if (code === 46 || code === 95) {
-      return effects.check(trail, domainAfter, domainAtPunctuation)(code);
+  function domainInside(code2) {
+    if (code2 === 46 || code2 === 95) {
+      return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
     }
-
-    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can
-    // occur, which sounds like ASCII only, but they also support `www..com`,
-    // so thats Unicode.
-    // Instead of some new production for Unicode alphanumerics, markdown
-    // already has that for Unicode punctuation and whitespace, so use those.
-    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.
-    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {
-      return domainAfter(code);
+    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
+      return domainAfter(code2);
     }
     seen = true;
-    effects.consume(code);
+    effects.consume(code2);
     return domainInside;
-  }
-
-  /**
-   * In domain, at potential trailing punctuation, that was not trailing.
-   *
-   * ```markdown
-   * > | https://example.com
-   *                    ^
-   * ```
-   *
-   * @type {State}
-   */
-  function domainAtPunctuation(code) {
-    // There is an underscore in the last segment of the domain
-    if (code === 95) {
+  }
+  function domainAtPunctuation(code2) {
+    if (code2 === 95) {
       underscoreInLastSegment = true;
-    }
-    // Otherwise, its a `.`: save the last segment underscore in the
-    // penultimate segment slot.
-    else {
+    } else {
       underscoreInLastLastSegment = underscoreInLastSegment;
-      underscoreInLastSegment = undefined;
+      underscoreInLastSegment = void 0;
     }
-    effects.consume(code);
+    effects.consume(code2);
     return domainInside;
   }
-
-  /**
-   * After domain.
-   *
-   * ```markdown
-   * > | https://example.com/a
-   *                        ^
-   * ```
-   *
-   * @type {State} */
-  function domainAfter(code) {
-    // Note: thats GH says a dot is needed, but its not true:
-    // <https://github.com/github/cmark-gfm/issues/279>
+  function domainAfter(code2) {
     if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
-      return nok(code);
+      return nok(code2);
     }
-    return ok(code);
-  }
-}
-
-/**
- * Path.
- *
- * ```markdown
- * > | a https://example.org/stuff b
- *                          ^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizePath(effects, ok) {
+    return ok2(code2);
+  }
+}
+function tokenizePath(effects, ok2) {
   let sizeOpen = 0;
   let sizeClose = 0;
   return pathInside;
-
-  /**
-   * In path.
-   *
-   * ```markdown
-   * > | https://example.com/a
-   *                        ^^
-   * ```
-   *
-   * @type {State}
-   */
-  function pathInside(code) {
-    if (code === 40) {
+  function pathInside(code2) {
+    if (code2 === 40) {
       sizeOpen++;
-      effects.consume(code);
+      effects.consume(code2);
       return pathInside;
     }
-
-    // To do: `markdown-rs` also needs this.
-    // If this is a paren, and there are less closings than openings,
-    // we dont check for a trail.
-    if (code === 41 && sizeClose < sizeOpen) {
-      return pathAtPunctuation(code);
+    if (code2 === 41 && sizeClose < sizeOpen) {
+      return pathAtPunctuation(code2);
     }
-
-    // Check whether this trailing punctuation marker is optionally
-    // followed by more trailing markers, and then followed
-    // by an end.
-    if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {
-      return effects.check(trail, ok, pathAtPunctuation)(code);
+    if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
+      return effects.check(trail, ok2, pathAtPunctuation)(code2);
     }
-    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
-      return ok(code);
+    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+      return ok2(code2);
     }
-    effects.consume(code);
+    effects.consume(code2);
     return pathInside;
   }
-
-  /**
-   * In path, at potential trailing punctuation, that was not trailing.
-   *
-   * ```markdown
-   * > | https://example.com/a"b
-   *                          ^
-   * ```
-   *
-   * @type {State}
-   */
-  function pathAtPunctuation(code) {
-    // Count closing parens.
-    if (code === 41) {
+  function pathAtPunctuation(code2) {
+    if (code2 === 41) {
       sizeClose++;
     }
-    effects.consume(code);
+    effects.consume(code2);
     return pathInside;
   }
 }
-
-/**
- * Trail.
- *
- * This calls `ok` if this *is* the trail, followed by an end, which means
- * the entire trail is not part of the link.
- * It calls `nok` if this *is* part of the link.
- *
- * ```markdown
- * > | https://example.com").
- *                        ^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeTrail(effects, ok, nok) {
-  return trail;
-
-  /**
-   * In trail of domain or path.
-   *
-   * ```markdown
-   * > | https://example.com").
-   *                        ^
-   * ```
-   *
-   * @type {State}
-   */
-  function trail(code) {
-    // Regular trailing punctuation.
-    if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {
-      effects.consume(code);
-      return trail;
+function tokenizeTrail(effects, ok2, nok) {
+  return trail2;
+  function trail2(code2) {
+    if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
+      effects.consume(code2);
+      return trail2;
     }
-
-    // `&` followed by one or more alphabeticals and then a `;`, is
-    // as a whole considered as trailing punctuation.
-    // In all other cases, it is considered as continuation of the URL.
-    if (code === 38) {
-      effects.consume(code);
+    if (code2 === 38) {
+      effects.consume(code2);
       return trailCharacterReferenceStart;
     }
-
-    // Needed because we allow literals after `[`, as we fix:
-    // <https://github.com/github/cmark-gfm/issues/278>.
-    // Check that it is not followed by `(` or `[`.
-    if (code === 93) {
-      effects.consume(code);
+    if (code2 === 93) {
+      effects.consume(code2);
       return trailBracketAfter;
     }
     if (
-    // `<` is an end.
-    code === 60 ||
-    // So is whitespace.
-    code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
-      return ok(code);
+      // `<` is an end.
+      code2 === 60 || // So is whitespace.
+      code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)
+    ) {
+      return ok2(code2);
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * In trail, after `]`.
-   *
-   * >  **Note**: this deviates from `cmark-gfm` to fix a bug.
-   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.
-   *
-   * ```markdown
-   * > | https://example.com](
-   *                         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function trailBracketAfter(code) {
-    // Whitespace or something that could start a resource or reference is the end.
-    // Switch back to trail otherwise.
-    if (code === null || code === 40 || code === 91 || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
-      return ok(code);
+  function trailBracketAfter(code2) {
+    if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+      return ok2(code2);
     }
-    return trail(code);
+    return trail2(code2);
   }
-
-  /**
-   * In character-reference like trail, after `&`.
-   *
-   * ```markdown
-   * > | https://example.com&amp;).
-   *                         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function trailCharacterReferenceStart(code) {
-    // When non-alpha, its not a trail.
-    return asciiAlpha(code) ? trailCharacterReferenceInside(code) : nok(code);
+  function trailCharacterReferenceStart(code2) {
+    return asciiAlpha(code2) ? trailCharacterReferenceInside(code2) : nok(code2);
   }
-
-  /**
-   * In character-reference like trail.
-   *
-   * ```markdown
-   * > | https://example.com&amp;).
-   *                         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function trailCharacterReferenceInside(code) {
-    // Switch back to trail if this is well-formed.
-    if (code === 59) {
-      effects.consume(code);
-      return trail;
+  function trailCharacterReferenceInside(code2) {
+    if (code2 === 59) {
+      effects.consume(code2);
+      return trail2;
     }
-    if (asciiAlpha(code)) {
-      effects.consume(code);
+    if (asciiAlpha(code2)) {
+      effects.consume(code2);
       return trailCharacterReferenceInside;
     }
-
-    // Its not a trail.
-    return nok(code);
-  }
-}
-
-/**
- * Dot in email domain trail.
- *
- * This calls `ok` if this *is* the trail, followed by an end, which means
- * the trail is not part of the link.
- * It calls `nok` if this *is* part of the link.
- *
- * ```markdown
- * > | contact@example.org.
- *                        ^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeEmailDomainDotTrail(effects, ok, nok) {
+    return nok(code2);
+  }
+}
+function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
   return start;
-
-  /**
-   * Dot.
-   *
-   * ```markdown
-   * > | contact@example.org.
-   *                    ^   ^
-   * ```
-   *
-   * @type {State}
-   */
-  function start(code) {
-    // Must be dot.
-    effects.consume(code);
+  function start(code2) {
+    effects.consume(code2);
     return after;
   }
-
-  /**
-   * After dot.
-   *
-   * ```markdown
-   * > | contact@example.org.
-   *                     ^   ^
-   * ```
-   *
-   * @type {State}
-   */
-  function after(code) {
-    // Not a trail if alphanumeric.
-    return asciiAlphanumeric(code) ? nok(code) : ok(code);
-  }
-}
-
-/**
- * See:
- * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.
- *
- * @type {Previous}
- */
-function previousWww(code) {
-  return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || markdownLineEndingOrSpace(code);
-}
-
-/**
- * See:
- * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.
- *
- * @type {Previous}
- */
-function previousProtocol(code) {
-  return !asciiAlpha(code);
-}
-
-/**
- * @this {TokenizeContext}
- * @type {Previous}
- */
-function previousEmail(code) {
-  // Do not allow a slash inside atext.
-  // The reference code is a bit weird, but thats what it results in.
-  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.
-  // Other than slash, every preceding character is allowed.
-  return !(code === 47 || gfmAtext(code));
-}
-
-/**
- * @param {Code} code
- * @returns {boolean}
- */
-function gfmAtext(code) {
-  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);
-}
-
-/**
- * @param {Array<Event>} events
- * @returns {boolean}
- */
+  function after(code2) {
+    return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
+  }
+}
+function previousWww(code2) {
+  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
+}
+function previousProtocol(code2) {
+  return !asciiAlpha(code2);
+}
+function previousEmail(code2) {
+  return !(code2 === 47 || gfmAtext(code2));
+}
+function gfmAtext(code2) {
+  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
+}
 function previousUnbalanced(events) {
   let index = events.length;
   let result = false;
   while (index--) {
     const token = events[index][1];
-    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {
+    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
       result = true;
       break;
     }
-
-    // If weve seen this token, and it was marked as not having any unbalanced
-    // bracket before it, we can exit.
     if (token._gfmAutolinkLiteralWalkedInto) {
       result = false;
       break;
     }
   }
   if (events.length > 0 && !result) {
-    // Mark the last token as walked into w/o finding
-    // anything.
     events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
   }
   return result;
 }
-;// CONCATENATED MODULE: ./src/utils/buildUnifiedExtension.ts
 function buildUnifiedExtension(micromarkExtensions, fromMarkdownExtensions, toMarkdownExtensions) {
-    return function () {
-        var _a, _b, _c;
-        // eslint-disable-next-line no-invalid-this -- this provided by unified
-        const data = this.data();
-        (_a = data.micromarkExtensions) !== null && _a !== void 0 ? _a : (data.micromarkExtensions = []);
-        (_b = data.fromMarkdownExtensions) !== null && _b !== void 0 ? _b : (data.fromMarkdownExtensions = []);
-        (_c = data.toMarkdownExtensions) !== null && _c !== void 0 ? _c : (data.toMarkdownExtensions = []);
-        data.micromarkExtensions.push(...micromarkExtensions);
-        data.fromMarkdownExtensions.push(...fromMarkdownExtensions);
-        data.toMarkdownExtensions.push(...toMarkdownExtensions);
-    };
+  return function() {
+    const data = this.data();
+    data.micromarkExtensions ?? (data.micromarkExtensions = []);
+    data.fromMarkdownExtensions ?? (data.fromMarkdownExtensions = []);
+    data.toMarkdownExtensions ?? (data.toMarkdownExtensions = []);
+    data.micromarkExtensions.push(...micromarkExtensions);
+    data.fromMarkdownExtensions.push(...fromMarkdownExtensions);
+    data.toMarkdownExtensions.push(...toMarkdownExtensions);
+  };
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ExtendedAutolinkExtension.ts
-
-
-
-
-/**
- * @public
- */
-class ExtendedAutolinkExtension extends external_prosemirror_unified_namespaceObject.Extension {
-    unifiedInitializationHook(processor) {
-        return processor.use(buildUnifiedExtension([gfmAutolinkLiteral()], [gfmAutolinkLiteralFromMarkdown()], [gfmAutolinkLiteralToMarkdown()]));
-    }
+class ExtendedAutolinkExtension extends prosemirrorUnified.Extension {
+  unifiedInitializationHook(processor) {
+    return processor.use(
+      buildUnifiedExtension(
+        [gfmAutolinkLiteral()],
+        [gfmAutolinkLiteralFromMarkdown()],
+        [gfmAutolinkLiteralToMarkdown()]
+      )
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-gfm-strikethrough/lib/index.js
-/**
- * @typedef {import('mdast').Delete} Delete
- *
- * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
- * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
- * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
- *
- * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName
- * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
- * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
- */
-
-/**
- * List of constructs that occur in phrasing (paragraphs, headings), but cannot
- * contain strikethrough.
- * So they sort of cancel each other out.
- * Note: could use a better name.
- *
- * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>
- *
- * @type {Array<ConstructName>}
- */
 const constructsWithoutStrikethrough = [
-  'autolink',
-  'destinationLiteral',
-  'destinationRaw',
-  'reference',
-  'titleQuote',
-  'titleApostrophe'
-]
-
-handleDelete.peek = peekDelete
-
-/**
- * Create an extension for `mdast-util-from-markdown` to enable GFM
- * strikethrough in markdown.
- *
- * @returns {FromMarkdownExtension}
- *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.
- */
+  "autolink",
+  "destinationLiteral",
+  "destinationRaw",
+  "reference",
+  "titleQuote",
+  "titleApostrophe"
+];
+handleDelete.peek = peekDelete;
 function gfmStrikethroughFromMarkdown() {
   return {
-    canContainEols: ['delete'],
-    enter: {strikethrough: enterStrikethrough},
-    exit: {strikethrough: exitStrikethrough}
-  }
-}
-
-/**
- * Create an extension for `mdast-util-to-markdown` to enable GFM
- * strikethrough in markdown.
- *
- * @returns {ToMarkdownExtension}
- *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.
- */
+    canContainEols: ["delete"],
+    enter: { strikethrough: enterStrikethrough },
+    exit: { strikethrough: exitStrikethrough }
+  };
+}
 function gfmStrikethroughToMarkdown() {
   return {
     unsafe: [
       {
-        character: '~',
-        inConstruct: 'phrasing',
+        character: "~",
+        inConstruct: "phrasing",
         notInConstruct: constructsWithoutStrikethrough
       }
     ],
-    handlers: {delete: handleDelete}
-  }
+    handlers: { delete: handleDelete }
+  };
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function enterStrikethrough(token) {
-  this.enter({type: 'delete', children: []}, token)
+  this.enter({ type: "delete", children: [] }, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitStrikethrough(token) {
-  this.exit(token)
-}
-
-/**
- * @type {ToMarkdownHandle}
- * @param {Delete} node
- */
-function handleDelete(node, _, state, info) {
-  const tracker = state.createTracker(info)
-  const exit = state.enter('strikethrough')
-  let value = tracker.move('~~')
-  value += state.containerPhrasing(node, {
+  this.exit(token);
+}
+function handleDelete(node2, _, state, info) {
+  const tracker = state.createTracker(info);
+  const exit = state.enter("strikethrough");
+  let value = tracker.move("~~");
+  value += state.containerPhrasing(node2, {
     ...tracker.current(),
     before: value,
-    after: '~'
-  })
-  value += tracker.move('~~')
-  exit()
-  return value
-}
-
-/** @type {ToMarkdownHandle} */
+    after: "~"
+  });
+  value += tracker.move("~~");
+  exit();
+  return value;
+}
 function peekDelete() {
-  return '~'
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-util-chunked/index.js
-/**
- * Like `Array#splice`, but smarter for giant arrays.
- *
- * `Array#splice` takes all items to be inserted as individual argument which
- * causes a stack overflow in V8 when trying to insert 100k items for instance.
- *
- * Otherwise, this does not return the removed items, and takes `items` as an
- * array instead of rest parameters.
- *
- * @template {unknown} T
- *   Item type.
- * @param {Array<T>} list
- *   List to operate on.
- * @param {number} start
- *   Index to remove/insert at (can be negative).
- * @param {number} remove
- *   Number of items to remove.
- * @param {Array<T>} items
- *   Items to inject into `list`.
- * @returns {undefined}
- *   Nothing.
- */
-function splice(list, start, remove, items) {
-  const end = list.length
-  let chunkStart = 0
-  /** @type {Array<unknown>} */
-  let parameters
-
-  // Make start between zero and `end` (included).
+  return "~";
+}
+function splice(list2, start, remove, items) {
+  const end = list2.length;
+  let chunkStart = 0;
+  let parameters;
   if (start < 0) {
-    start = -start > end ? 0 : end + start
+    start = -start > end ? 0 : end + start;
   } else {
-    start = start > end ? end : start
-  }
-  remove = remove > 0 ? remove : 0
-
-  // No need to chunk the items if theres only a couple (10k) items.
-  if (items.length < 10000) {
-    parameters = Array.from(items)
-    parameters.unshift(start, remove)
-    // @ts-expect-error Hush, its fine.
-    list.splice(...parameters)
+    start = start > end ? end : start;
+  }
+  remove = remove > 0 ? remove : 0;
+  if (items.length < 1e4) {
+    parameters = Array.from(items);
+    parameters.unshift(start, remove);
+    list2.splice(...parameters);
   } else {
-    // Delete `remove` items starting from `start`
-    if (remove) list.splice(start, remove)
-
-    // Insert the items in chunks to not cause stack overflows.
+    if (remove) list2.splice(start, remove);
     while (chunkStart < items.length) {
-      parameters = items.slice(chunkStart, chunkStart + 10000)
-      parameters.unshift(start, 0)
-      // @ts-expect-error Hush, its fine.
-      list.splice(...parameters)
-      chunkStart += 10000
-      start += 10000
+      parameters = items.slice(chunkStart, chunkStart + 1e4);
+      parameters.unshift(start, 0);
+      list2.splice(...parameters);
+      chunkStart += 1e4;
+      start += 1e4;
     }
   }
 }
-
-/**
- * Append `items` (an array) at the end of `list` (another array).
- * When `list` was empty, returns `items` instead.
- *
- * This prevents a potentially expensive operation when `list` is empty,
- * and adds items in batches to prevent V8 from hanging.
- *
- * @template {unknown} T
- *   Item type.
- * @param {Array<T>} list
- *   List to operate on.
- * @param {Array<T>} items
- *   Items to add to `list`.
- * @returns {Array<T>}
- *   Either `list` or `items`.
- */
-function push(list, items) {
-  if (list.length > 0) {
-    splice(list, list.length, 0, items)
-    return list
-  }
-  return items
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-util-classify-character/index.js
-/**
- * @typedef {import('micromark-util-types').Code} Code
- */
-
-
-/**
- * Classify whether a code represents whitespace, punctuation, or something
- * else.
- *
- * Used for attention (emphasis, strong), whose sequences can open or close
- * based on the class of surrounding characters.
- *
- * >  **Note**: eof (`null`) is seen as whitespace.
- *
- * @param {Code} code
- *   Code.
- * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}
- *   Group.
- */
-function classifyCharacter(code) {
-  if (
-    code === null ||
-    markdownLineEndingOrSpace(code) ||
-    unicodeWhitespace(code)
-  ) {
-    return 1
-  }
-  if (unicodePunctuation(code)) {
-    return 2
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-util-resolve-all/index.js
-/**
- * @typedef {import('micromark-util-types').Event} Event
- * @typedef {import('micromark-util-types').Resolver} Resolver
- * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
- */
-
-/**
- * Call all `resolveAll`s.
- *
- * @param {Array<{resolveAll?: Resolver | undefined}>} constructs
- *   List of constructs, optionally with `resolveAll`s.
- * @param {Array<Event>} events
- *   List of events.
- * @param {TokenizeContext} context
- *   Context used by `tokenize`.
- * @returns {Array<Event>}
- *   Changed events.
- */
+function classifyCharacter(code2) {
+  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+    return 1;
+  }
+  if (unicodePunctuation(code2)) {
+    return 2;
+  }
+}
 function resolveAll(constructs, events, context) {
-  /** @type {Array<Resolver>} */
-  const called = []
-  let index = -1
-
+  const called = [];
+  let index = -1;
   while (++index < constructs.length) {
-    const resolve = constructs[index].resolveAll
-
+    const resolve = constructs[index].resolveAll;
     if (resolve && !called.includes(resolve)) {
-      events = resolve(events, context)
-      called.push(resolve)
+      events = resolve(events, context);
+      called.push(resolve);
     }
   }
-
-  return events
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
-/**
- * @import {Options} from 'micromark-extension-gfm-strikethrough'
- * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'
- */
-
-
-
-
-/**
- * Create an extension for `micromark` to enable GFM strikethrough syntax.
- *
- * @param {Options | null | undefined} [options={}]
- *   Configuration.
- * @returns {Extension}
- *   Extension for `micromark` that can be passed in `extensions`, to
- *   enable GFM strikethrough syntax.
- */
+  return events;
+}
 function gfmStrikethrough(options) {
-  const options_ = options || {};
+  const options_ = {};
   let single = options_.singleTilde;
   const tokenizer = {
-    name: 'strikethrough',
+    name: "strikethrough",
     tokenize: tokenizeStrikethrough,
     resolveAll: resolveAllStrikethrough
   };
-  if (single === null || single === undefined) {
+  if (single === null || single === void 0) {
     single = true;
   }
   return {
@@ -3921,55 +2004,32 @@ function gfmStrikethrough(options) {
       null: [126]
     }
   };
-
-  /**
-   * Take events and resolve strikethrough.
-   *
-   * @type {Resolver}
-   */
   function resolveAllStrikethrough(events, context) {
     let index = -1;
-
-    // Walk through all events.
     while (++index < events.length) {
-      // Find a token that can close.
-      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {
+      if (events[index][0] === "enter" && events[index][1].type === "strikethroughSequenceTemporary" && events[index][1]._close) {
         let open = index;
-
-        // Now walk back to find an opener.
         while (open--) {
-          // Find a token that can open the closer.
-          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&
-          // If the sizes are the same:
+          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
           events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
-            events[index][1].type = 'strikethroughSequence';
-            events[open][1].type = 'strikethroughSequence';
-
-            /** @type {Token} */
+            events[index][1].type = "strikethroughSequence";
+            events[open][1].type = "strikethroughSequence";
             const strikethrough = {
-              type: 'strikethrough',
+              type: "strikethrough",
               start: Object.assign({}, events[open][1].start),
               end: Object.assign({}, events[index][1].end)
             };
-
-            /** @type {Token} */
-            const text = {
-              type: 'strikethroughText',
+            const text2 = {
+              type: "strikethroughText",
               start: Object.assign({}, events[open][1].end),
               end: Object.assign({}, events[index][1].start)
             };
-
-            // Opening.
-            /** @type {Array<Event>} */
-            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];
+            const nextEvents = [["enter", strikethrough, context], ["enter", events[open][1], context], ["exit", events[open][1], context], ["enter", text2, context]];
             const insideSpan = context.parser.constructs.insideSpan.null;
             if (insideSpan) {
-              // Between.
               splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan, events.slice(open + 1, index), context));
             }
-
-            // Closing.
-            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);
+            splice(nextEvents, nextEvents.length, 0, [["exit", text2, context], ["enter", events[index][1], context], ["exit", events[index][1], context], ["exit", strikethrough, context]]);
             splice(events, open - 1, index - open + 3, nextEvents);
             index = open + nextEvents.length - 2;
             break;
@@ -3979,2188 +2039,989 @@ function gfmStrikethrough(options) {
     }
     index = -1;
     while (++index < events.length) {
-      if (events[index][1].type === 'strikethroughSequenceTemporary') {
+      if (events[index][1].type === "strikethroughSequenceTemporary") {
         events[index][1].type = "data";
       }
     }
     return events;
   }
-
-  /**
-   * @this {TokenizeContext}
-   * @type {Tokenizer}
-   */
-  function tokenizeStrikethrough(effects, ok, nok) {
-    const previous = this.previous;
+  function tokenizeStrikethrough(effects, ok2, nok) {
+    const previous2 = this.previous;
     const events = this.events;
     let size = 0;
     return start;
-
-    /** @type {State} */
-    function start(code) {
-      if (previous === 126 && events[events.length - 1][1].type !== "characterEscape") {
-        return nok(code);
+    function start(code2) {
+      if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
+        return nok(code2);
       }
-      effects.enter('strikethroughSequenceTemporary');
-      return more(code);
-    }
-
-    /** @type {State} */
-    function more(code) {
-      const before = classifyCharacter(previous);
-      if (code === 126) {
-        // If this is the third marker, exit.
-        if (size > 1) return nok(code);
-        effects.consume(code);
+      effects.enter("strikethroughSequenceTemporary");
+      return more(code2);
+    }
+    function more(code2) {
+      const before = classifyCharacter(previous2);
+      if (code2 === 126) {
+        if (size > 1) return nok(code2);
+        effects.consume(code2);
         size++;
         return more;
       }
-      if (size < 2 && !single) return nok(code);
-      const token = effects.exit('strikethroughSequenceTemporary');
-      const after = classifyCharacter(code);
+      if (size < 2 && !single) return nok(code2);
+      const token = effects.exit("strikethroughSequenceTemporary");
+      const after = classifyCharacter(code2);
       token._open = !after || after === 2 && Boolean(before);
       token._close = !before || before === 2 && Boolean(after);
-      return ok(code);
+      return ok2(code2);
     }
   }
 }
-;// CONCATENATED MODULE: ./src/syntax-extensions/StrikethroughExtension.ts
-
-
-
-
-/**
- * @public
- */
-class StrikethroughExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode) {
-        return { children: [convertedNode], type: this.unistNodeName() };
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/~([^\s](?:.*[^\s~])?)~([^~])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/~~([^\s](?:.*[^\s])?)~~([\s\S])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-        ];
-    }
-    proseMirrorMarkName() {
-        return "strikethrough";
-    }
-    proseMirrorMarkSpec() {
-        return {
-            parseDOM: [
-                { tag: "s" },
-                { tag: "del" },
-                {
-                    getAttrs: (value) => /(^|[\s])line-through([\s]|$)/u.test(value) && null,
-                    style: "text-decoration",
-                },
-            ],
-            toDOM() {
-                return ["s"];
-            },
-        };
-    }
-    unifiedInitializationHook(processor) {
-        return processor.use(buildUnifiedExtension([gfmStrikethrough()], [gfmStrikethroughFromMarkdown()], [gfmStrikethroughToMarkdown()]));
-    }
-    unistNodeName() {
-        return "delete";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return convertedChildren.map((child) => child.mark(child.marks.concat([
-            proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),
-        ])));
-    }
+class StrikethroughExtension extends prosemirrorUnified.MarkExtension {
+  processConvertedUnistNode(convertedNode) {
+    return { children: [convertedNode], type: this.unistNodeName() };
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new prosemirrorUnified.MarkInputRule(
+        /~([^\s](?:.*[^\s~])?)~([^~])$/u,
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      ),
+      new prosemirrorUnified.MarkInputRule(
+        /~~([^\s](?:.*[^\s])?)~~([\s\S])$/u,
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      )
+    ];
+  }
+  proseMirrorMarkName() {
+    return "strikethrough";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      parseDOM: [
+        { tag: "s" },
+        { tag: "del" },
+        {
+          getAttrs: (value) => /(^|[\s])line-through([\s]|$)/u.test(value) && null,
+          style: "text-decoration"
+        }
+      ],
+      toDOM() {
+        return ["s", 0];
+      }
+    };
+  }
+  unifiedInitializationHook(processor) {
+    return processor.use(
+      buildUnifiedExtension(
+        [gfmStrikethrough()],
+        [gfmStrikethroughFromMarkdown()],
+        [gfmStrikethroughToMarkdown()]
+      )
+    );
+  }
+  unistNodeName() {
+    return "delete";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return convertedChildren.map(
+      (child) => child.mark(
+        child.marks.concat([
+          proseMirrorSchema.marks[this.proseMirrorMarkName()].create()
+        ])
+      )
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
-/**
- * @typedef {import('mdast').Blockquote} Blockquote
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').Map} Map
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {Blockquote} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function blockquote(node, _, state, info) {
-  const exit = state.enter('blockquote')
-  const tracker = state.createTracker(info)
-  tracker.move('> ')
-  tracker.shift(2)
+function blockquote(node2, _, state, info) {
+  const exit = state.enter("blockquote");
+  const tracker = state.createTracker(info);
+  tracker.move("> ");
+  tracker.shift(2);
   const value = state.indentLines(
-    state.containerFlow(node, tracker.current()),
-    map
-  )
-  exit()
-  return value
-}
-
-/** @type {Map} */
-function map(line, _, blank) {
-  return '>' + (blank ? '' : ' ') + line
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
-/**
- * @typedef {import('../types.js').ConstructName} ConstructName
- * @typedef {import('../types.js').Unsafe} Unsafe
- */
-
-/**
- * @param {Array<ConstructName>} stack
- * @param {Unsafe} pattern
- * @returns {boolean}
- */
+    state.containerFlow(node2, tracker.current()),
+    map$1
+  );
+  exit();
+  return value;
+}
+function map$1(line, _, blank) {
+  return ">" + (blank ? "" : " ") + line;
+}
 function patternInScope(stack, pattern) {
-  return (
-    listInScope(stack, pattern.inConstruct, true) &&
-    !listInScope(stack, pattern.notInConstruct, false)
-  )
-}
-
-/**
- * @param {Array<ConstructName>} stack
- * @param {Unsafe['inConstruct']} list
- * @param {boolean} none
- * @returns {boolean}
- */
-function listInScope(stack, list, none) {
-  if (typeof list === 'string') {
-    list = [list]
-  }
-
-  if (!list || list.length === 0) {
-    return none
-  }
-
-  let index = -1
-
-  while (++index < list.length) {
-    if (stack.includes(list[index])) {
-      return true
+  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
+}
+function listInScope(stack, list2, none) {
+  if (typeof list2 === "string") {
+    list2 = [list2];
+  }
+  if (!list2 || list2.length === 0) {
+    return none;
+  }
+  let index = -1;
+  while (++index < list2.length) {
+    if (stack.includes(list2[index])) {
+      return true;
     }
   }
-
-  return false
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/break.js
-/**
- * @typedef {import('mdast').Break} Break
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Break} _
- * @param {Parents | undefined} _1
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
+  return false;
+}
 function hardBreak(_, _1, state, info) {
-  let index = -1
-
+  let index = -1;
   while (++index < state.unsafe.length) {
-    // If we cant put eols in this construct (setext headings, tables), use a
-    // space instead.
-    if (
-      state.unsafe[index].character === '\n' &&
-      patternInScope(state.stack, state.unsafe[index])
-    ) {
-      return /[ \t]/.test(info.before) ? '' : ' '
+    if (state.unsafe[index].character === "\n" && patternInScope(state.stack, state.unsafe[index])) {
+      return /[ \t]/.test(info.before) ? "" : " ";
     }
   }
-
-  return '\\\n'
-}
-
-;// CONCATENATED MODULE: ./node_modules/longest-streak/index.js
-/**
- * Get the count of the longest repeating streak of `substring` in `value`.
- *
- * @param {string} value
- *   Content to search in.
- * @param {string} substring
- *   Substring to look for, typically one character.
- * @returns {number}
- *   Count of most frequent adjacent `substring`s in `value`.
- */
+  return "\\\n";
+}
 function longestStreak(value, substring) {
-  const source = String(value)
-  let index = source.indexOf(substring)
-  let expected = index
-  let count = 0
-  let max = 0
-
-  if (typeof substring !== 'string') {
-    throw new TypeError('Expected substring')
-  }
-
+  const source = String(value);
+  let index = source.indexOf(substring);
+  let expected = index;
+  let count = 0;
+  let max = 0;
+  if (typeof substring !== "string") {
+    throw new TypeError("Expected substring");
+  }
   while (index !== -1) {
     if (index === expected) {
       if (++count > max) {
-        max = count
+        max = count;
       }
     } else {
-      count = 1
+      count = 1;
     }
-
-    expected = index + substring.length
-    index = source.indexOf(substring, expected)
-  }
-
-  return max
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
-/**
- * @typedef {import('mdast').Code} Code
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {Code} node
- * @param {State} state
- * @returns {boolean}
- */
-function formatCodeAsIndented(node, state) {
+    expected = index + substring.length;
+    index = source.indexOf(substring, expected);
+  }
+  return max;
+}
+function formatCodeAsIndented(node2, state) {
   return Boolean(
-    state.options.fences === false &&
-      node.value &&
-      // If theres no info
-      !node.lang &&
-      // And theres a non-whitespace character
-      /[^ \r\n]/.test(node.value) &&
-      // And the value doesnt start or end in a blank
-      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node.value)
-  )
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-fence.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['fence'], null | undefined>}
- */
+    state.options.fences === false && node2.value && // If theres no info
+    !node2.lang && // And theres a non-whitespace character
+    /[^ \r\n]/.test(node2.value) && // And the value doesnt start or end in a blank
+    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
+  );
+}
 function checkFence(state) {
-  const marker = state.options.fence || '`'
-
-  if (marker !== '`' && marker !== '~') {
+  const marker = state.options.fence || "`";
+  if (marker !== "`" && marker !== "~") {
     throw new Error(
-      'Cannot serialize code with `' +
-        marker +
-        '` for `options.fence`, expected `` ` `` or `~`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/code.js
-/**
- * @typedef {import('mdast').Code} Code
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').Map} Map
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-
-/**
- * @param {Code} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function code_code(node, _, state, info) {
-  const marker = checkFence(state)
-  const raw = node.value || ''
-  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'
-
-  if (formatCodeAsIndented(node, state)) {
-    const exit = state.enter('codeIndented')
-    const value = state.indentLines(raw, code_map)
-    exit()
-    return value
-  }
-
-  const tracker = state.createTracker(info)
-  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))
-  const exit = state.enter('codeFenced')
-  let value = tracker.move(sequence)
-
-  if (node.lang) {
-    const subexit = state.enter(`codeFencedLang${suffix}`)
+      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
+    );
+  }
+  return marker;
+}
+function code(node2, _, state, info) {
+  const marker = checkFence(state);
+  const raw = node2.value || "";
+  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
+  if (formatCodeAsIndented(node2, state)) {
+    const exit2 = state.enter("codeIndented");
+    const value2 = state.indentLines(raw, map);
+    exit2();
+    return value2;
+  }
+  const tracker = state.createTracker(info);
+  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
+  const exit = state.enter("codeFenced");
+  let value = tracker.move(sequence);
+  if (node2.lang) {
+    const subexit = state.enter(`codeFencedLang${suffix}`);
     value += tracker.move(
-      state.safe(node.lang, {
+      state.safe(node2.lang, {
         before: value,
-        after: ' ',
-        encode: ['`'],
+        after: " ",
+        encode: ["`"],
         ...tracker.current()
       })
-    )
-    subexit()
+    );
+    subexit();
   }
-
-  if (node.lang && node.meta) {
-    const subexit = state.enter(`codeFencedMeta${suffix}`)
-    value += tracker.move(' ')
+  if (node2.lang && node2.meta) {
+    const subexit = state.enter(`codeFencedMeta${suffix}`);
+    value += tracker.move(" ");
     value += tracker.move(
-      state.safe(node.meta, {
+      state.safe(node2.meta, {
         before: value,
-        after: '\n',
-        encode: ['`'],
+        after: "\n",
+        encode: ["`"],
         ...tracker.current()
       })
-    )
-    subexit()
+    );
+    subexit();
   }
-
-  value += tracker.move('\n')
-
+  value += tracker.move("\n");
   if (raw) {
-    value += tracker.move(raw + '\n')
-  }
-
-  value += tracker.move(sequence)
-  exit()
-  return value
-}
-
-/** @type {Map} */
-function code_map(line, _, blank) {
-  return (blank ? '' : '    ') + line
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-quote.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['quote'], null | undefined>}
- */
+    value += tracker.move(raw + "\n");
+  }
+  value += tracker.move(sequence);
+  exit();
+  return value;
+}
+function map(line, _, blank) {
+  return (blank ? "" : "    ") + line;
+}
 function checkQuote(state) {
-  const marker = state.options.quote || '"'
-
+  const marker = state.options.quote || '"';
   if (marker !== '"' && marker !== "'") {
     throw new Error(
-      'Cannot serialize title with `' +
-        marker +
-        '` for `options.quote`, expected `"`, or `\'`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/definition.js
-/**
- * @typedef {import('mdast').Definition} Definition
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Definition} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function definition(node, _, state, info) {
-  const quote = checkQuote(state)
-  const suffix = quote === '"' ? 'Quote' : 'Apostrophe'
-  const exit = state.enter('definition')
-  let subexit = state.enter('label')
-  const tracker = state.createTracker(info)
-  let value = tracker.move('[')
+      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
+    );
+  }
+  return marker;
+}
+function definition(node2, _, state, info) {
+  const quote = checkQuote(state);
+  const suffix = quote === '"' ? "Quote" : "Apostrophe";
+  const exit = state.enter("definition");
+  let subexit = state.enter("label");
+  const tracker = state.createTracker(info);
+  let value = tracker.move("[");
   value += tracker.move(
-    state.safe(state.associationId(node), {
+    state.safe(state.associationId(node2), {
       before: value,
-      after: ']',
+      after: "]",
       ...tracker.current()
     })
-  )
-  value += tracker.move(']: ')
-
-  subexit()
-
+  );
+  value += tracker.move("]: ");
+  subexit();
   if (
     // If theres no url, or
-    !node.url ||
-    // If there are control characters or whitespace.
-    /[\0- \u007F]/.test(node.url)
+    !node2.url || // If there are control characters or whitespace.
+    /[\0- \u007F]/.test(node2.url)
   ) {
-    subexit = state.enter('destinationLiteral')
-    value += tracker.move('<')
+    subexit = state.enter("destinationLiteral");
+    value += tracker.move("<");
     value += tracker.move(
-      state.safe(node.url, {before: value, after: '>', ...tracker.current()})
-    )
-    value += tracker.move('>')
+      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
+    );
+    value += tracker.move(">");
   } else {
-    // No whitespace, raw is prettier.
-    subexit = state.enter('destinationRaw')
+    subexit = state.enter("destinationRaw");
     value += tracker.move(
-      state.safe(node.url, {
+      state.safe(node2.url, {
         before: value,
-        after: node.title ? ' ' : '\n',
+        after: node2.title ? " " : "\n",
         ...tracker.current()
       })
-    )
-  }
-
-  subexit()
-
-  if (node.title) {
-    subexit = state.enter(`title${suffix}`)
-    value += tracker.move(' ' + quote)
+    );
+  }
+  subexit();
+  if (node2.title) {
+    subexit = state.enter(`title${suffix}`);
+    value += tracker.move(" " + quote);
     value += tracker.move(
-      state.safe(node.title, {
+      state.safe(node2.title, {
         before: value,
         after: quote,
         ...tracker.current()
       })
-    )
-    value += tracker.move(quote)
-    subexit()
-  }
-
-  exit()
-
-  return value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['emphasis'], null | undefined>}
- */
+    );
+    value += tracker.move(quote);
+    subexit();
+  }
+  exit();
+  return value;
+}
 function checkEmphasis(state) {
-  const marker = state.options.emphasis || '*'
-
-  if (marker !== '*' && marker !== '_') {
+  const marker = state.options.emphasis || "*";
+  if (marker !== "*" && marker !== "_") {
     throw new Error(
-      'Cannot serialize emphasis with `' +
-        marker +
-        '` for `options.emphasis`, expected `*`, or `_`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
-/**
- * @typedef {import('mdast').Emphasis} Emphasis
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-emphasis.peek = emphasisPeek
-
-// To do: there are cases where emphasis cannot form depending on the
-// previous or next character of sequences.
-// Theres no way around that though, except for injecting zero-width stuff.
-// Do we need to safeguard against that?
-/**
- * @param {Emphasis} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function emphasis(node, _, state, info) {
-  const marker = checkEmphasis(state)
-  const exit = state.enter('emphasis')
-  const tracker = state.createTracker(info)
-  let value = tracker.move(marker)
-  value += tracker.move(
-    state.containerPhrasing(node, {
-      before: value,
+      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
+    );
+  }
+  return marker;
+}
+function encodeCharacterReference(code2) {
+  return "&#x" + code2.toString(16).toUpperCase() + ";";
+}
+function encodeInfo(outside, inside, marker) {
+  const outsideKind = classifyCharacter(outside);
+  const insideKind = classifyCharacter(inside);
+  if (outsideKind === void 0) {
+    return insideKind === void 0 ? (
+      // Letter inside:
+      // we have to encode *both* letters for `_` as it is looser.
+      // it already forms for `*` (and GFMs `~`).
+      marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
+    ) : insideKind === 1 ? (
+      // Whitespace inside: encode both (letter, whitespace).
+      { inside: true, outside: true }
+    ) : (
+      // Punctuation inside: encode outer (letter)
+      { inside: false, outside: true }
+    );
+  }
+  if (outsideKind === 1) {
+    return insideKind === void 0 ? (
+      // Letter inside: already forms.
+      { inside: false, outside: false }
+    ) : insideKind === 1 ? (
+      // Whitespace inside: encode both (whitespace).
+      { inside: true, outside: true }
+    ) : (
+      // Punctuation inside: already forms.
+      { inside: false, outside: false }
+    );
+  }
+  return insideKind === void 0 ? (
+    // Letter inside: already forms.
+    { inside: false, outside: false }
+  ) : insideKind === 1 ? (
+    // Whitespace inside: encode inner (whitespace).
+    { inside: true, outside: false }
+  ) : (
+    // Punctuation inside: already forms.
+    { inside: false, outside: false }
+  );
+}
+emphasis.peek = emphasisPeek;
+function emphasis(node2, _, state, info) {
+  const marker = checkEmphasis(state);
+  const exit = state.enter("emphasis");
+  const tracker = state.createTracker(info);
+  const before = tracker.move(marker);
+  let between = tracker.move(
+    state.containerPhrasing(node2, {
       after: marker,
+      before,
       ...tracker.current()
     })
-  )
-  value += tracker.move(marker)
-  exit()
-  return value
-}
-
-/**
- * @param {Emphasis} _
- * @param {Parents | undefined} _1
- * @param {State} state
- * @returns {string}
- */
+  );
+  const betweenHead = between.charCodeAt(0);
+  const open = encodeInfo(
+    info.before.charCodeAt(info.before.length - 1),
+    betweenHead,
+    marker
+  );
+  if (open.inside) {
+    between = encodeCharacterReference(betweenHead) + between.slice(1);
+  }
+  const betweenTail = between.charCodeAt(between.length - 1);
+  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
+  if (close.inside) {
+    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
+  }
+  const after = tracker.move(marker);
+  exit();
+  state.attentionEncodeSurroundingInfo = {
+    after: close.outside,
+    before: open.outside
+  };
+  return before + between + after;
+}
 function emphasisPeek(_, _1, state) {
-  return state.options.emphasis || '*'
-}
-
-;// CONCATENATED MODULE: ./node_modules/unist-util-visit/lib/index.js
-/**
- * @typedef {import('unist').Node} UnistNode
- * @typedef {import('unist').Parent} UnistParent
- * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
- */
-
-/**
- * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test
- *   Test from `unist-util-is`.
- *
- *   Note: we have remove and add `undefined`, because otherwise when generating
- *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,
- *   which doesnt work when publishing on npm.
- */
-
-// To do: use types from `unist-util-visit-parents` when its released.
-
-/**
- * @typedef {(
- *   Fn extends (value: any) => value is infer Thing
- *   ? Thing
- *   : Fallback
- * )} Predicate
- *   Get the value of a type guard `Fn`.
- * @template Fn
- *   Value; typically function that is a type guard (such as `(x): x is Y`).
- * @template Fallback
- *   Value to yield if `Fn` is not a type guard.
- */
-
-/**
- * @typedef {(
- *   Check extends null | undefined // No test.
- *   ? Value
- *   : Value extends {type: Check} // String (type) test.
- *   ? Value
- *   : Value extends Check // Partial test.
- *   ? Value
- *   : Check extends Function // Function test.
- *   ? Predicate<Check, Value> extends Value
- *     ? Predicate<Check, Value>
- *     : never
- *   : never // Some other test?
- * )} MatchesOne
- *   Check whether a node matches a primitive check in the type system.
- * @template Value
- *   Value; typically unist `Node`.
- * @template Check
- *   Value; typically `unist-util-is`-compatible test, but not arrays.
- */
-
-/**
- * @typedef {(
- *   Check extends Array<any>
- *   ? MatchesOne<Value, Check[keyof Check]>
- *   : MatchesOne<Value, Check>
- * )} Matches
- *   Check whether a node matches a check in the type system.
- * @template Value
- *   Value; typically unist `Node`.
- * @template Check
- *   Value; typically `unist-util-is`-compatible test.
- */
-
-/**
- * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint
- *   Number; capped reasonably.
- */
-
-/**
- * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment
- *   Increment a number in the type system.
- * @template {Uint} [I=0]
- *   Index.
- */
-
-/**
- * @typedef {(
- *   Node extends UnistParent
- *   ? Node extends {children: Array<infer Children>}
- *     ? Child extends Children ? Node : never
- *     : never
- *   : never
- * )} InternalParent
- *   Collect nodes that can be parents of `Child`.
- * @template {UnistNode} Node
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent
- *   Collect nodes in `Tree` that can be parents of `Child`.
- * @template {UnistNode} Tree
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {(
- *   Depth extends Max
- *   ? never
- *   :
- *     | InternalParent<Node, Child>
- *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>
- * )} InternalAncestor
- *   Collect nodes in `Tree` that can be ancestors of `Child`.
- * @template {UnistNode} Node
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- * @template {Uint} [Max=10]
- *   Max; searches up to this depth.
- * @template {Uint} [Depth=0]
- *   Current depth.
- */
-
-/**
- * @typedef {(
- *   Tree extends UnistParent
- *     ? Depth extends Max
- *       ? Tree
- *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>
- *     : Tree
- * )} InclusiveDescendant
- *   Collect all (inclusive) descendants of `Tree`.
- *
- *   >  **Note**: for performance reasons, this seems to be the fastest way to
- *   > recurse without actually running into an infinite loop, which the
- *   > previous version did.
- *   >
- *   > Practically, a max of `2` is typically enough assuming a `Root` is
- *   > passed, but it doesnt improve performance.
- *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.
- *   > Using up to `10` doesnt hurt or help either.
- * @template {UnistNode} Tree
- *   Tree type.
- * @template {Uint} [Max=10]
- *   Max; searches up to this depth.
- * @template {Uint} [Depth=0]
- *   Current depth.
- */
-
-/**
- * @callback Visitor
- *   Handle a node (matching `test`, if given).
- *
- *   Visitors are free to transform `node`.
- *   They can also transform `parent`.
- *
- *   Replacing `node` itself, if `SKIP` is not returned, still causes its
- *   descendants to be walked (which is a bug).
- *
- *   When adding or removing previous siblings of `node` (or next siblings, in
- *   case of reverse), the `Visitor` should return a new `Index` to specify the
- *   sibling to traverse after `node` is traversed.
- *   Adding or removing next siblings of `node` (or previous siblings, in case
- *   of reverse) is handled as expected without needing to return a new `Index`.
- *
- *   Removing the children property of `parent` still results in them being
- *   traversed.
- * @param {Visited} node
- *   Found node.
- * @param {Visited extends UnistNode ? number | undefined : never} index
- *   Index of `node` in `parent`.
- * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent
- *   Parent of `node`.
- * @returns {VisitorResult}
- *   What to do next.
- *
- *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
- *   An `Action` is treated as a tuple of `[Action]`.
- *
- *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
- *   When the `Action` is `EXIT`, that action can be returned.
- *   When the `Action` is `CONTINUE`, `Index` can be returned.
- * @template {UnistNode} [Visited=UnistNode]
- *   Visited node type.
- * @template {UnistParent} [Ancestor=UnistParent]
- *   Ancestor type.
- */
-
-/**
- * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch
- *   Build a typed `Visitor` function from a node and all possible parents.
- *
- *   It will infer which values are passed as `node` and which as `parent`.
- * @template {UnistNode} Visited
- *   Node type.
- * @template {UnistParent} Ancestor
- *   Parent type.
- */
-
-/**
- * @typedef {(
- *   BuildVisitorFromMatch<
- *     Matches<Descendant, Check>,
- *     Extract<Descendant, UnistParent>
- *   >
- * )} BuildVisitorFromDescendants
- *   Build a typed `Visitor` function from a list of descendants and a test.
- *
- *   It will infer which values are passed as `node` and which as `parent`.
- * @template {UnistNode} Descendant
- *   Node type.
- * @template {Test} Check
- *   Test type.
- */
-
-/**
- * @typedef {(
- *   BuildVisitorFromDescendants<
- *     InclusiveDescendant<Tree>,
- *     Check
- *   >
- * )} BuildVisitor
- *   Build a typed `Visitor` function from a tree and a test.
- *
- *   It will infer which values are passed as `node` and which as `parent`.
- * @template {UnistNode} [Tree=UnistNode]
- *   Node type.
- * @template {Test} [Check=Test]
- *   Test type.
- */
-
-
-
-
-
-/**
- * Visit nodes.
- *
- * This algorithm performs *depth-first* *tree traversal* in *preorder*
- * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
- *
- * You can choose for which nodes `visitor` is called by passing a `test`.
- * For complex tests, you should test yourself in `visitor`, as it will be
- * faster and will have improved type information.
- *
- * Walking the tree is an intensive task.
- * Make use of the return values of the visitor when possible.
- * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
- * to check if a node matches, and then perform different operations.
- *
- * You can change the tree.
- * See `Visitor` for more info.
- *
- * @overload
- * @param {Tree} tree
- * @param {Check} check
- * @param {BuildVisitor<Tree, Check>} visitor
- * @param {boolean | null | undefined} [reverse]
- * @returns {undefined}
- *
- * @overload
- * @param {Tree} tree
- * @param {BuildVisitor<Tree>} visitor
- * @param {boolean | null | undefined} [reverse]
- * @returns {undefined}
- *
- * @param {UnistNode} tree
- *   Tree to traverse.
- * @param {Visitor | Test} testOrVisitor
- *   `unist-util-is`-compatible test (optional, omit to pass a visitor).
- * @param {Visitor | boolean | null | undefined} [visitorOrReverse]
- *   Handle each node (when test is omitted, pass `reverse`).
- * @param {boolean | null | undefined} [maybeReverse=false]
- *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
- * @returns {undefined}
- *   Nothing.
- *
- * @template {UnistNode} Tree
- *   Node type.
- * @template {Test} Check
- *   `unist-util-is`-compatible test.
- */
+  return state.options.emphasis || "*";
+}
 function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
-  /** @type {boolean | null | undefined} */
-  let reverse
-  /** @type {Test} */
-  let test
-  /** @type {Visitor} */
-  let visitor
-
-  if (
-    typeof testOrVisitor === 'function' &&
-    typeof visitorOrReverse !== 'function'
-  ) {
-    test = undefined
-    visitor = testOrVisitor
-    reverse = visitorOrReverse
+  let reverse;
+  let test;
+  let visitor;
+  if (typeof testOrVisitor === "function" && true) {
+    test = void 0;
+    visitor = testOrVisitor;
+    reverse = visitorOrReverse;
   } else {
-    // @ts-expect-error: assume the overload with test was given.
-    test = testOrVisitor
-    // @ts-expect-error: assume the overload with test was given.
-    visitor = visitorOrReverse
-    reverse = maybeReverse
-  }
-
-  visitParents(tree, test, overload, reverse)
-
-  /**
-   * @param {UnistNode} node
-   * @param {Array<UnistParent>} parents
-   */
-  function overload(node, parents) {
-    const parent = parents[parents.length - 1]
-    const index = parent ? parent.children.indexOf(node) : undefined
-    return visitor(node, index, parent)
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-string/lib/index.js
-/**
- * @typedef {import('mdast').Nodes} Nodes
- *
- * @typedef Options
- *   Configuration (optional).
- * @property {boolean | null | undefined} [includeImageAlt=true]
- *   Whether to use `alt` for `image`s (default: `true`).
- * @property {boolean | null | undefined} [includeHtml=true]
- *   Whether to use `value` of HTML (default: `true`).
- */
-
-/** @type {Options} */
-const emptyOptions = {}
-
-/**
- * Get the text content of a node or list of nodes.
- *
- * Prefers the nodes plain-text fields, otherwise serializes its children,
- * and if the given value is an array, serialize the nodes in it.
- *
- * @param {unknown} [value]
- *   Thing to serialize, typically `Node`.
- * @param {Options | null | undefined} [options]
- *   Configuration (optional).
- * @returns {string}
- *   Serialized `value`.
- */
-function lib_toString(value, options) {
-  const settings = options || emptyOptions
-  const includeImageAlt =
-    typeof settings.includeImageAlt === 'boolean'
-      ? settings.includeImageAlt
-      : true
-  const includeHtml =
-    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true
-
-  return one(value, includeImageAlt, includeHtml)
-}
-
-/**
- * One node or several nodes.
- *
- * @param {unknown} value
- *   Thing to serialize.
- * @param {boolean} includeImageAlt
- *   Include image `alt`s.
- * @param {boolean} includeHtml
- *   Include HTML.
- * @returns {string}
- *   Serialized node.
- */
+    test = testOrVisitor;
+    visitor = visitorOrReverse;
+    reverse = maybeReverse;
+  }
+  visitParents(tree, test, overload, reverse);
+  function overload(node2, parents) {
+    const parent = parents[parents.length - 1];
+    const index = parent ? parent.children.indexOf(node2) : void 0;
+    return visitor(node2, index, parent);
+  }
+}
+const emptyOptions = {};
+function toString(value, options) {
+  const settings = emptyOptions;
+  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
+  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
+  return one(value, includeImageAlt, includeHtml);
+}
 function one(value, includeImageAlt, includeHtml) {
   if (node(value)) {
-    if ('value' in value) {
-      return value.type === 'html' && !includeHtml ? '' : value.value
+    if ("value" in value) {
+      return value.type === "html" && !includeHtml ? "" : value.value;
     }
-
-    if (includeImageAlt && 'alt' in value && value.alt) {
-      return value.alt
+    if (includeImageAlt && "alt" in value && value.alt) {
+      return value.alt;
     }
-
-    if ('children' in value) {
-      return lib_all(value.children, includeImageAlt, includeHtml)
+    if ("children" in value) {
+      return all(value.children, includeImageAlt, includeHtml);
     }
   }
-
   if (Array.isArray(value)) {
-    return lib_all(value, includeImageAlt, includeHtml)
-  }
-
-  return ''
-}
-
-/**
- * Serialize a list of nodes.
- *
- * @param {Array<unknown>} values
- *   Thing to serialize.
- * @param {boolean} includeImageAlt
- *   Include image `alt`s.
- * @param {boolean} includeHtml
- *   Include HTML.
- * @returns {string}
- *   Serialized nodes.
- */
-function lib_all(values, includeImageAlt, includeHtml) {
-  /** @type {Array<string>} */
-  const result = []
-  let index = -1
-
+    return all(value, includeImageAlt, includeHtml);
+  }
+  return "";
+}
+function all(values, includeImageAlt, includeHtml) {
+  const result = [];
+  let index = -1;
   while (++index < values.length) {
-    result[index] = one(values[index], includeImageAlt, includeHtml)
-  }
-
-  return result.join('')
-}
-
-/**
- * Check if `value` looks like a node.
- *
- * @param {unknown} value
- *   Thing.
- * @returns {value is Nodes}
- *   Whether `value` is a node.
- */
+    result[index] = one(values[index], includeImageAlt, includeHtml);
+  }
+  return result.join("");
+}
 function node(value) {
-  return Boolean(value && typeof value === 'object')
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
-/**
- * @typedef {import('mdast').Heading} Heading
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-/**
- * @param {Heading} node
- * @param {State} state
- * @returns {boolean}
- */
-function formatHeadingAsSetext(node, state) {
-  let literalWithBreak = false
-
-  // Look for literals with a line break.
-  // Note that this also
-  visit(node, function (node) {
-    if (
-      ('value' in node && /\r?\n|\r/.test(node.value)) ||
-      node.type === 'break'
-    ) {
-      literalWithBreak = true
-      return EXIT
+  return Boolean(value && typeof value === "object");
+}
+function formatHeadingAsSetext(node2, state) {
+  let literalWithBreak = false;
+  visit(node2, function(node3) {
+    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
+      literalWithBreak = true;
+      return EXIT;
     }
-  })
-
+  });
   return Boolean(
-    (!node.depth || node.depth < 3) &&
-      lib_toString(node) &&
-      (state.options.setext || literalWithBreak)
-  )
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/heading.js
-/**
- * @typedef {import('mdast').Heading} Heading
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Heading} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function heading(node, _, state, info) {
-  const rank = Math.max(Math.min(6, node.depth || 1), 1)
-  const tracker = state.createTracker(info)
-
-  if (formatHeadingAsSetext(node, state)) {
-    const exit = state.enter('headingSetext')
-    const subexit = state.enter('phrasing')
-    const value = state.containerPhrasing(node, {
+    (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
+  );
+}
+function heading(node2, _, state, info) {
+  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
+  const tracker = state.createTracker(info);
+  if (formatHeadingAsSetext(node2, state)) {
+    const exit2 = state.enter("headingSetext");
+    const subexit2 = state.enter("phrasing");
+    const value2 = state.containerPhrasing(node2, {
       ...tracker.current(),
-      before: '\n',
-      after: '\n'
-    })
-    subexit()
-    exit()
-
-    return (
-      value +
-      '\n' +
-      (rank === 1 ? '=' : '-').repeat(
-        // The whole size
-        value.length -
-          // Minus the position of the character after the last EOL (or
-          // 0 if there is none)
-          (Math.max(value.lastIndexOf('\r'), value.lastIndexOf('\n')) + 1)
-      )
-    )
-  }
-
-  const sequence = '#'.repeat(rank)
-  const exit = state.enter('headingAtx')
-  const subexit = state.enter('phrasing')
-
-  // Note: for proper tracking, we should reset the output positions when there
-  // is no content returned, because then the space is not output.
-  // Practically, in that case, there is no content, so it doesnt matter that
-  // weve tracked one too many characters.
-  tracker.move(sequence + ' ')
-
-  let value = state.containerPhrasing(node, {
-    before: '# ',
-    after: '\n',
+      before: "\n",
+      after: "\n"
+    });
+    subexit2();
+    exit2();
+    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
+      // The whole size
+      value2.length - // Minus the position of the character after the last EOL (or
+      // 0 if there is none)
+      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
+    );
+  }
+  const sequence = "#".repeat(rank);
+  const exit = state.enter("headingAtx");
+  const subexit = state.enter("phrasing");
+  tracker.move(sequence + " ");
+  let value = state.containerPhrasing(node2, {
+    before: "# ",
+    after: "\n",
     ...tracker.current()
-  })
-
+  });
   if (/^[\t ]/.test(value)) {
-    // To do: what effect has the character reference on tracking?
-    value =
-      '&#x' +
-      value.charCodeAt(0).toString(16).toUpperCase() +
-      ';' +
-      value.slice(1)
-  }
-
-  value = value ? sequence + ' ' + value : sequence
-
+    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
+  }
+  value = value ? sequence + " " + value : sequence;
   if (state.options.closeAtx) {
-    value += ' ' + sequence
-  }
-
-  subexit()
-  exit()
-
-  return value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/html.js
-/**
- * @typedef {import('mdast').Html} Html
- */
-
-html.peek = htmlPeek
-
-/**
- * @param {Html} node
- * @returns {string}
- */
-function html(node) {
-  return node.value || ''
-}
-
-/**
- * @returns {string}
- */
+    value += " " + sequence;
+  }
+  subexit();
+  exit();
+  return value;
+}
+html.peek = htmlPeek;
+function html(node2) {
+  return node2.value || "";
+}
 function htmlPeek() {
-  return '<'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/image.js
-/**
- * @typedef {import('mdast').Image} Image
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-image_image.peek = imagePeek
-
-/**
- * @param {Image} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function image_image(node, _, state, info) {
-  const quote = checkQuote(state)
-  const suffix = quote === '"' ? 'Quote' : 'Apostrophe'
-  const exit = state.enter('image')
-  let subexit = state.enter('label')
-  const tracker = state.createTracker(info)
-  let value = tracker.move('![')
+  return "<";
+}
+image.peek = imagePeek;
+function image(node2, _, state, info) {
+  const quote = checkQuote(state);
+  const suffix = quote === '"' ? "Quote" : "Apostrophe";
+  const exit = state.enter("image");
+  let subexit = state.enter("label");
+  const tracker = state.createTracker(info);
+  let value = tracker.move("![");
   value += tracker.move(
-    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})
-  )
-  value += tracker.move('](')
-
-  subexit()
-
+    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
+  );
+  value += tracker.move("](");
+  subexit();
   if (
     // If theres no url but there is a title
-    (!node.url && node.title) ||
-    // If there are control characters or whitespace.
-    /[\0- \u007F]/.test(node.url)
+    !node2.url && node2.title || // If there are control characters or whitespace.
+    /[\0- \u007F]/.test(node2.url)
   ) {
-    subexit = state.enter('destinationLiteral')
-    value += tracker.move('<')
+    subexit = state.enter("destinationLiteral");
+    value += tracker.move("<");
     value += tracker.move(
-      state.safe(node.url, {before: value, after: '>', ...tracker.current()})
-    )
-    value += tracker.move('>')
+      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
+    );
+    value += tracker.move(">");
   } else {
-    // No whitespace, raw is prettier.
-    subexit = state.enter('destinationRaw')
+    subexit = state.enter("destinationRaw");
     value += tracker.move(
-      state.safe(node.url, {
+      state.safe(node2.url, {
         before: value,
-        after: node.title ? ' ' : ')',
+        after: node2.title ? " " : ")",
         ...tracker.current()
       })
-    )
-  }
-
-  subexit()
-
-  if (node.title) {
-    subexit = state.enter(`title${suffix}`)
-    value += tracker.move(' ' + quote)
+    );
+  }
+  subexit();
+  if (node2.title) {
+    subexit = state.enter(`title${suffix}`);
+    value += tracker.move(" " + quote);
     value += tracker.move(
-      state.safe(node.title, {
+      state.safe(node2.title, {
         before: value,
         after: quote,
         ...tracker.current()
       })
-    )
-    value += tracker.move(quote)
-    subexit()
-  }
-
-  value += tracker.move(')')
-  exit()
-
-  return value
-}
-
-/**
- * @returns {string}
- */
+    );
+    value += tracker.move(quote);
+    subexit();
+  }
+  value += tracker.move(")");
+  exit();
+  return value;
+}
 function imagePeek() {
-  return '!'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
-/**
- * @typedef {import('mdast').ImageReference} ImageReference
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-imageReference.peek = imageReferencePeek
-
-/**
- * @param {ImageReference} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function imageReference(node, _, state, info) {
-  const type = node.referenceType
-  const exit = state.enter('imageReference')
-  let subexit = state.enter('label')
-  const tracker = state.createTracker(info)
-  let value = tracker.move('![')
-  const alt = state.safe(node.alt, {
+  return "!";
+}
+imageReference.peek = imageReferencePeek;
+function imageReference(node2, _, state, info) {
+  const type = node2.referenceType;
+  const exit = state.enter("imageReference");
+  let subexit = state.enter("label");
+  const tracker = state.createTracker(info);
+  let value = tracker.move("![");
+  const alt = state.safe(node2.alt, {
     before: value,
-    after: ']',
+    after: "]",
     ...tracker.current()
-  })
-  value += tracker.move(alt + '][')
-
-  subexit()
-  // Hide the fact that were in phrasing, because escapes dont work.
-  const stack = state.stack
-  state.stack = []
-  subexit = state.enter('reference')
-  // Note: for proper tracking, we should reset the output positions when we end
-  // up making a `shortcut` reference, because then there is no brace output.
-  // Practically, in that case, there is no content, so it doesnt matter that
-  // weve tracked one too many characters.
-  const reference = state.safe(state.associationId(node), {
+  });
+  value += tracker.move(alt + "][");
+  subexit();
+  const stack = state.stack;
+  state.stack = [];
+  subexit = state.enter("reference");
+  const reference = state.safe(state.associationId(node2), {
     before: value,
-    after: ']',
+    after: "]",
     ...tracker.current()
-  })
-  subexit()
-  state.stack = stack
-  exit()
-
-  if (type === 'full' || !alt || alt !== reference) {
-    value += tracker.move(reference + ']')
-  } else if (type === 'shortcut') {
-    // Remove the unwanted `[`.
-    value = value.slice(0, -1)
+  });
+  subexit();
+  state.stack = stack;
+  exit();
+  if (type === "full" || !alt || alt !== reference) {
+    value += tracker.move(reference + "]");
+  } else if (type === "shortcut") {
+    value = value.slice(0, -1);
   } else {
-    value += tracker.move(']')
+    value += tracker.move("]");
   }
-
-  return value
+  return value;
 }
-
-/**
- * @returns {string}
- */
 function imageReferencePeek() {
-  return '!'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
-/**
- * @typedef {import('mdast').InlineCode} InlineCode
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').State} State
- */
-
-inlineCode.peek = inlineCodePeek
-
-/**
- * @param {InlineCode} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @returns {string}
- */
-function inlineCode(node, _, state) {
-  let value = node.value || ''
-  let sequence = '`'
-  let index = -1
-
-  // If there is a single grave accent on its own in the code, use a fence of
-  // two.
-  // If there are two in a row, use one.
-  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {
-    sequence += '`'
-  }
-
-  // If this is not just spaces or eols (tabs dont count), and either the
-  // first or last character are a space, eol, or tick, then pad with spaces.
-  if (
-    /[^ \r\n]/.test(value) &&
-    ((/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value)) || /^`|`$/.test(value))
-  ) {
-    value = ' ' + value + ' '
-  }
-
-  // We have a potential problem: certain characters after eols could result in
-  // blocks being seen.
-  // For example, if someone injected the string `'\n# b'`, then that would
-  // result in an ATX heading.
-  // We cant escape characters in `inlineCode`, but because eols are
-  // transformed to spaces when going from markdown to HTML anyway, we can swap
-  // them out.
+  return "!";
+}
+inlineCode.peek = inlineCodePeek;
+function inlineCode(node2, _, state) {
+  let value = node2.value || "";
+  let sequence = "`";
+  let index = -1;
+  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
+    sequence += "`";
+  }
+  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
+    value = " " + value + " ";
+  }
   while (++index < state.unsafe.length) {
-    const pattern = state.unsafe[index]
-    const expression = state.compilePattern(pattern)
-    /** @type {RegExpExecArray | null} */
-    let match
-
-    // Only look for `atBreak`s.
-    // Btw: note that `atBreak` patterns will always start the regex at LF or
-    // CR.
-    if (!pattern.atBreak) continue
-
-    while ((match = expression.exec(value))) {
-      let position = match.index
-
-      // Support CRLF (patterns only look for one of the characters).
-      if (
-        value.charCodeAt(position) === 10 /* `\n` */ &&
-        value.charCodeAt(position - 1) === 13 /* `\r` */
-      ) {
-        position--
+    const pattern = state.unsafe[index];
+    const expression = state.compilePattern(pattern);
+    let match;
+    if (!pattern.atBreak) continue;
+    while (match = expression.exec(value)) {
+      let position = match.index;
+      if (value.charCodeAt(position) === 10 && value.charCodeAt(position - 1) === 13) {
+        position--;
       }
-
-      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)
+      value = value.slice(0, position) + " " + value.slice(match.index + 1);
     }
   }
-
-  return sequence + value + sequence
+  return sequence + value + sequence;
 }
-
-/**
- * @returns {string}
- */
 function inlineCodePeek() {
-  return '`'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
-/**
- * @typedef {import('mdast').Link} Link
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Link} node
- * @param {State} state
- * @returns {boolean}
- */
-function formatLinkAsAutolink(node, state) {
-  const raw = lib_toString(node)
-
+  return "`";
+}
+function formatLinkAsAutolink(node2, state) {
+  const raw = toString(node2);
   return Boolean(
-    !state.options.resourceLink &&
-      // If theres a url
-      node.url &&
-      // And theres a no title
-      !node.title &&
-      // And the content of `node` is a single text node
-      node.children &&
-      node.children.length === 1 &&
-      node.children[0].type === 'text' &&
-      // And if the url is the same as the content
-      (raw === node.url || 'mailto:' + raw === node.url) &&
-      // And that starts w/ a protocol
-      /^[a-z][a-z+.-]+:/i.test(node.url) &&
-      // And that doesnt contain ASCII control codes (character escapes and
-      // references dont work), space, or angle brackets
-      !/[\0- <>\u007F]/.test(node.url)
-  )
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/link.js
-/**
- * @typedef {import('mdast').Link} Link
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Exit} Exit
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-link_link.peek = linkPeek
-
-/**
- * @param {Link} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function link_link(node, _, state, info) {
-  const quote = checkQuote(state)
-  const suffix = quote === '"' ? 'Quote' : 'Apostrophe'
-  const tracker = state.createTracker(info)
-  /** @type {Exit} */
-  let exit
-  /** @type {Exit} */
-  let subexit
-
-  if (formatLinkAsAutolink(node, state)) {
-    // Hide the fact that were in phrasing, because escapes dont work.
-    const stack = state.stack
-    state.stack = []
-    exit = state.enter('autolink')
-    let value = tracker.move('<')
-    value += tracker.move(
-      state.containerPhrasing(node, {
-        before: value,
-        after: '>',
+    !state.options.resourceLink && // If theres a url
+    node2.url && // And theres a no title
+    !node2.title && // And the content of `node` is a single text node
+    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content
+    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocol
+    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnt contain ASCII control codes (character escapes and
+    // references dont work), space, or angle brackets
+    !/[\0- <>\u007F]/.test(node2.url)
+  );
+}
+link.peek = linkPeek;
+function link(node2, _, state, info) {
+  const quote = checkQuote(state);
+  const suffix = quote === '"' ? "Quote" : "Apostrophe";
+  const tracker = state.createTracker(info);
+  let exit;
+  let subexit;
+  if (formatLinkAsAutolink(node2, state)) {
+    const stack = state.stack;
+    state.stack = [];
+    exit = state.enter("autolink");
+    let value2 = tracker.move("<");
+    value2 += tracker.move(
+      state.containerPhrasing(node2, {
+        before: value2,
+        after: ">",
         ...tracker.current()
       })
-    )
-    value += tracker.move('>')
-    exit()
-    state.stack = stack
-    return value
-  }
-
-  exit = state.enter('link')
-  subexit = state.enter('label')
-  let value = tracker.move('[')
+    );
+    value2 += tracker.move(">");
+    exit();
+    state.stack = stack;
+    return value2;
+  }
+  exit = state.enter("link");
+  subexit = state.enter("label");
+  let value = tracker.move("[");
   value += tracker.move(
-    state.containerPhrasing(node, {
+    state.containerPhrasing(node2, {
       before: value,
-      after: '](',
+      after: "](",
       ...tracker.current()
     })
-  )
-  value += tracker.move('](')
-  subexit()
-
+  );
+  value += tracker.move("](");
+  subexit();
   if (
     // If theres no url but there is a title
-    (!node.url && node.title) ||
-    // If there are control characters or whitespace.
-    /[\0- \u007F]/.test(node.url)
+    !node2.url && node2.title || // If there are control characters or whitespace.
+    /[\0- \u007F]/.test(node2.url)
   ) {
-    subexit = state.enter('destinationLiteral')
-    value += tracker.move('<')
+    subexit = state.enter("destinationLiteral");
+    value += tracker.move("<");
     value += tracker.move(
-      state.safe(node.url, {before: value, after: '>', ...tracker.current()})
-    )
-    value += tracker.move('>')
+      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
+    );
+    value += tracker.move(">");
   } else {
-    // No whitespace, raw is prettier.
-    subexit = state.enter('destinationRaw')
+    subexit = state.enter("destinationRaw");
     value += tracker.move(
-      state.safe(node.url, {
+      state.safe(node2.url, {
         before: value,
-        after: node.title ? ' ' : ')',
+        after: node2.title ? " " : ")",
         ...tracker.current()
       })
-    )
-  }
-
-  subexit()
-
-  if (node.title) {
-    subexit = state.enter(`title${suffix}`)
-    value += tracker.move(' ' + quote)
+    );
+  }
+  subexit();
+  if (node2.title) {
+    subexit = state.enter(`title${suffix}`);
+    value += tracker.move(" " + quote);
     value += tracker.move(
-      state.safe(node.title, {
+      state.safe(node2.title, {
         before: value,
         after: quote,
         ...tracker.current()
       })
-    )
-    value += tracker.move(quote)
-    subexit()
-  }
-
-  value += tracker.move(')')
-
-  exit()
-  return value
-}
-
-/**
- * @param {Link} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @returns {string}
- */
-function linkPeek(node, _, state) {
-  return formatLinkAsAutolink(node, state) ? '<' : '['
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
-/**
- * @typedef {import('mdast').LinkReference} LinkReference
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-linkReference.peek = linkReferencePeek
-
-/**
- * @param {LinkReference} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function linkReference(node, _, state, info) {
-  const type = node.referenceType
-  const exit = state.enter('linkReference')
-  let subexit = state.enter('label')
-  const tracker = state.createTracker(info)
-  let value = tracker.move('[')
-  const text = state.containerPhrasing(node, {
+    );
+    value += tracker.move(quote);
+    subexit();
+  }
+  value += tracker.move(")");
+  exit();
+  return value;
+}
+function linkPeek(node2, _, state) {
+  return formatLinkAsAutolink(node2, state) ? "<" : "[";
+}
+linkReference.peek = linkReferencePeek;
+function linkReference(node2, _, state, info) {
+  const type = node2.referenceType;
+  const exit = state.enter("linkReference");
+  let subexit = state.enter("label");
+  const tracker = state.createTracker(info);
+  let value = tracker.move("[");
+  const text2 = state.containerPhrasing(node2, {
     before: value,
-    after: ']',
+    after: "]",
     ...tracker.current()
-  })
-  value += tracker.move(text + '][')
-
-  subexit()
-  // Hide the fact that were in phrasing, because escapes dont work.
-  const stack = state.stack
-  state.stack = []
-  subexit = state.enter('reference')
-  // Note: for proper tracking, we should reset the output positions when we end
-  // up making a `shortcut` reference, because then there is no brace output.
-  // Practically, in that case, there is no content, so it doesnt matter that
-  // weve tracked one too many characters.
-  const reference = state.safe(state.associationId(node), {
+  });
+  value += tracker.move(text2 + "][");
+  subexit();
+  const stack = state.stack;
+  state.stack = [];
+  subexit = state.enter("reference");
+  const reference = state.safe(state.associationId(node2), {
     before: value,
-    after: ']',
+    after: "]",
     ...tracker.current()
-  })
-  subexit()
-  state.stack = stack
-  exit()
-
-  if (type === 'full' || !text || text !== reference) {
-    value += tracker.move(reference + ']')
-  } else if (type === 'shortcut') {
-    // Remove the unwanted `[`.
-    value = value.slice(0, -1)
+  });
+  subexit();
+  state.stack = stack;
+  exit();
+  if (type === "full" || !text2 || text2 !== reference) {
+    value += tracker.move(reference + "]");
+  } else if (type === "shortcut") {
+    value = value.slice(0, -1);
   } else {
-    value += tracker.move(']')
+    value += tracker.move("]");
   }
-
-  return value
+  return value;
 }
-
-/**
- * @returns {string}
- */
 function linkReferencePeek() {
-  return '['
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['bullet'], null | undefined>}
- */
+  return "[";
+}
 function checkBullet(state) {
-  const marker = state.options.bullet || '*'
-
-  if (marker !== '*' && marker !== '+' && marker !== '-') {
+  const marker = state.options.bullet || "*";
+  if (marker !== "*" && marker !== "+" && marker !== "-") {
     throw new Error(
-      'Cannot serialize items with `' +
-        marker +
-        '` for `options.bullet`, expected `*`, `+`, or `-`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['bullet'], null | undefined>}
- */
+      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
+    );
+  }
+  return marker;
+}
 function checkBulletOther(state) {
-  const bullet = checkBullet(state)
-  const bulletOther = state.options.bulletOther
-
+  const bullet = checkBullet(state);
+  const bulletOther = state.options.bulletOther;
   if (!bulletOther) {
-    return bullet === '*' ? '-' : '*'
+    return bullet === "*" ? "-" : "*";
   }
-
-  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {
+  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
     throw new Error(
-      'Cannot serialize items with `' +
-        bulletOther +
-        '` for `options.bulletOther`, expected `*`, `+`, or `-`'
-    )
+      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
+    );
   }
-
   if (bulletOther === bullet) {
     throw new Error(
-      'Expected `bullet` (`' +
-        bullet +
-        '`) and `bulletOther` (`' +
-        bulletOther +
-        '`) to be different'
-    )
-  }
-
-  return bulletOther
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['bulletOrdered'], null | undefined>}
- */
+      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
+    );
+  }
+  return bulletOther;
+}
 function checkBulletOrdered(state) {
-  const marker = state.options.bulletOrdered || '.'
-
-  if (marker !== '.' && marker !== ')') {
+  const marker = state.options.bulletOrdered || ".";
+  if (marker !== "." && marker !== ")") {
     throw new Error(
-      'Cannot serialize items with `' +
-        marker +
-        '` for `options.bulletOrdered`, expected `.` or `)`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-rule.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['rule'], null | undefined>}
- */
+      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
+    );
+  }
+  return marker;
+}
 function checkRule(state) {
-  const marker = state.options.rule || '*'
-
-  if (marker !== '*' && marker !== '-' && marker !== '_') {
+  const marker = state.options.rule || "*";
+  if (marker !== "*" && marker !== "-" && marker !== "_") {
     throw new Error(
-      'Cannot serialize rules with `' +
-        marker +
-        '` for `options.rule`, expected `*`, `-`, or `_`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/list.js
-/**
- * @typedef {import('mdast').List} List
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-
-
-/**
- * @param {List} node
- * @param {Parents | undefined} parent
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function list(node, parent, state, info) {
-  const exit = state.enter('list')
-  const bulletCurrent = state.bulletCurrent
-  /** @type {string} */
-  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)
-  /** @type {string} */
-  const bulletOther = node.ordered
-    ? bullet === '.'
-      ? ')'
-      : '.'
-    : checkBulletOther(state)
-  let useDifferentMarker =
-    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false
-
-  if (!node.ordered) {
-    const firstListItem = node.children ? node.children[0] : undefined
-
-    // If theres an empty first list item directly in two list items,
-    // we have to use a different bullet:
-    //
-    // ```markdown
-    // * - *
-    // ```
-    //
-    // because otherwise it would become one big thematic break.
+      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
+    );
+  }
+  return marker;
+}
+function list(node2, parent, state, info) {
+  const exit = state.enter("list");
+  const bulletCurrent = state.bulletCurrent;
+  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
+  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
+  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
+  if (!node2.ordered) {
+    const firstListItem = node2.children ? node2.children[0] : void 0;
     if (
       // Bullet could be used as a thematic break marker:
-      (bullet === '*' || bullet === '-') &&
-      // Empty first list item:
-      firstListItem &&
-      (!firstListItem.children || !firstListItem.children[0]) &&
-      // Directly in two other list items:
-      state.stack[state.stack.length - 1] === 'list' &&
-      state.stack[state.stack.length - 2] === 'listItem' &&
-      state.stack[state.stack.length - 3] === 'list' &&
-      state.stack[state.stack.length - 4] === 'listItem' &&
-      // That are each the first child.
-      state.indexStack[state.indexStack.length - 1] === 0 &&
-      state.indexStack[state.indexStack.length - 2] === 0 &&
-      state.indexStack[state.indexStack.length - 3] === 0
+      (bullet === "*" || bullet === "-") && // Empty first list item:
+      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
+      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
+      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
     ) {
-      useDifferentMarker = true
+      useDifferentMarker = true;
     }
-
-    // If theres a thematic break at the start of the first list item,
-    // we have to use a different bullet:
-    //
-    // ```markdown
-    // * ---
-    // ```
-    //
-    // because otherwise it would become one big thematic break.
     if (checkRule(state) === bullet && firstListItem) {
-      let index = -1
-
-      while (++index < node.children.length) {
-        const item = node.children[index]
-
-        if (
-          item &&
-          item.type === 'listItem' &&
-          item.children &&
-          item.children[0] &&
-          item.children[0].type === 'thematicBreak'
-        ) {
-          useDifferentMarker = true
-          break
+      let index = -1;
+      while (++index < node2.children.length) {
+        const item = node2.children[index];
+        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
+          useDifferentMarker = true;
+          break;
         }
       }
     }
   }
-
   if (useDifferentMarker) {
-    bullet = bulletOther
-  }
-
-  state.bulletCurrent = bullet
-  const value = state.containerFlow(node, info)
-  state.bulletLastUsed = bullet
-  state.bulletCurrent = bulletCurrent
-  exit()
-  return value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['listItemIndent'], null | undefined>}
- */
+    bullet = bulletOther;
+  }
+  state.bulletCurrent = bullet;
+  const value = state.containerFlow(node2, info);
+  state.bulletLastUsed = bullet;
+  state.bulletCurrent = bulletCurrent;
+  exit();
+  return value;
+}
 function checkListItemIndent(state) {
-  const style = state.options.listItemIndent || 'one'
-
-  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {
+  const style = state.options.listItemIndent || "one";
+  if (style !== "tab" && style !== "one" && style !== "mixed") {
     throw new Error(
-      'Cannot serialize items with `' +
-        style +
-        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'
-    )
-  }
-
-  return style
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/list-item.js
-/**
- * @typedef {import('mdast').ListItem} ListItem
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').Map} Map
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-/**
- * @param {ListItem} node
- * @param {Parents | undefined} parent
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function listItem(node, parent, state, info) {
-  const listItemIndent = checkListItemIndent(state)
-  let bullet = state.bulletCurrent || checkBullet(state)
-
-  // Add the marker value for ordered lists.
-  if (parent && parent.type === 'list' && parent.ordered) {
-    bullet =
-      (typeof parent.start === 'number' && parent.start > -1
-        ? parent.start
-        : 1) +
-      (state.options.incrementListMarker === false
-        ? 0
-        : parent.children.indexOf(node)) +
-      bullet
-  }
-
-  let size = bullet.length + 1
-
-  if (
-    listItemIndent === 'tab' ||
-    (listItemIndent === 'mixed' &&
-      ((parent && parent.type === 'list' && parent.spread) || node.spread))
-  ) {
-    size = Math.ceil(size / 4) * 4
+      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
+    );
+  }
+  return style;
+}
+function listItem(node2, parent, state, info) {
+  const listItemIndent = checkListItemIndent(state);
+  let bullet = state.bulletCurrent || checkBullet(state);
+  if (parent && parent.type === "list" && parent.ordered) {
+    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
   }
-
-  const tracker = state.createTracker(info)
-  tracker.move(bullet + ' '.repeat(size - bullet.length))
-  tracker.shift(size)
-  const exit = state.enter('listItem')
+  let size = bullet.length + 1;
+  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
+    size = Math.ceil(size / 4) * 4;
+  }
+  const tracker = state.createTracker(info);
+  tracker.move(bullet + " ".repeat(size - bullet.length));
+  tracker.shift(size);
+  const exit = state.enter("listItem");
   const value = state.indentLines(
-    state.containerFlow(node, tracker.current()),
-    map
-  )
-  exit()
-
-  return value
-
-  /** @type {Map} */
-  function map(line, index, blank) {
+    state.containerFlow(node2, tracker.current()),
+    map2
+  );
+  exit();
+  return value;
+  function map2(line, index, blank) {
     if (index) {
-      return (blank ? '' : ' '.repeat(size)) + line
+      return (blank ? "" : " ".repeat(size)) + line;
     }
-
-    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
-/**
- * @typedef {import('mdast').Paragraph} Paragraph
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {Paragraph} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function paragraph(node, _, state, info) {
-  const exit = state.enter('paragraph')
-  const subexit = state.enter('phrasing')
-  const value = state.containerPhrasing(node, info)
-  subexit()
-  exit()
-  return value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-phrasing/lib/index.js
-/**
- * @typedef {import('mdast').Html} Html
- * @typedef {import('mdast').PhrasingContent} PhrasingContent
- */
-
-
-
-/**
- * Check if the given value is *phrasing content*.
- *
- * >  **Note**: Excludes `html`, which can be both phrasing or flow.
- *
- * @param node
- *   Thing to check, typically `Node`.
- * @returns
- *   Whether `value` is phrasing content.
- */
-
-const phrasing =
+    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
+  }
+}
+function paragraph(node2, _, state, info) {
+  const exit = state.enter("paragraph");
+  const subexit = state.enter("phrasing");
+  const value = state.containerPhrasing(node2, info);
+  subexit();
+  exit();
+  return value;
+}
+const phrasing = (
   /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
-  (
-    convert([
-      'break',
-      'delete',
-      'emphasis',
-      // To do: next major: removed since footnotes were added to GFM.
-      'footnote',
-      'footnoteReference',
-      'image',
-      'imageReference',
-      'inlineCode',
-      // Enabled by `mdast-util-math`:
-      'inlineMath',
-      'link',
-      'linkReference',
-      // Enabled by `mdast-util-mdx`:
-      'mdxJsxTextElement',
-      // Enabled by `mdast-util-mdx`:
-      'mdxTextExpression',
-      'strong',
-      'text',
-      // Enabled by `mdast-util-directive`:
-      'textDirective'
-    ])
-  )
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/root.js
-/**
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').Root} Root
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Root} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function root(node, _, state, info) {
-  // Note: `html` nodes are ambiguous.
-  const hasPhrasing = node.children.some(function (d) {
-    return phrasing(d)
-  })
-  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow
-  return fn.call(state, node, info)
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-strong.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['strong'], null | undefined>}
- */
+  convert([
+    "break",
+    "delete",
+    "emphasis",
+    // To do: next major: removed since footnotes were added to GFM.
+    "footnote",
+    "footnoteReference",
+    "image",
+    "imageReference",
+    "inlineCode",
+    // Enabled by `mdast-util-math`:
+    "inlineMath",
+    "link",
+    "linkReference",
+    // Enabled by `mdast-util-mdx`:
+    "mdxJsxTextElement",
+    // Enabled by `mdast-util-mdx`:
+    "mdxTextExpression",
+    "strong",
+    "text",
+    // Enabled by `mdast-util-directive`:
+    "textDirective"
+  ])
+);
+function root(node2, _, state, info) {
+  const hasPhrasing = node2.children.some(function(d) {
+    return phrasing(d);
+  });
+  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
+  return container.call(state, node2, info);
+}
 function checkStrong(state) {
-  const marker = state.options.strong || '*'
-
-  if (marker !== '*' && marker !== '_') {
+  const marker = state.options.strong || "*";
+  if (marker !== "*" && marker !== "_") {
     throw new Error(
-      'Cannot serialize strong with `' +
-        marker +
-        '` for `options.strong`, expected `*`, or `_`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/strong.js
-/**
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').Strong} Strong
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-strong.peek = strongPeek
-
-// To do: there are cases where emphasis cannot form depending on the
-// previous or next character of sequences.
-// Theres no way around that though, except for injecting zero-width stuff.
-// Do we need to safeguard against that?
-/**
- * @param {Strong} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function strong(node, _, state, info) {
-  const marker = checkStrong(state)
-  const exit = state.enter('strong')
-  const tracker = state.createTracker(info)
-  let value = tracker.move(marker + marker)
-  value += tracker.move(
-    state.containerPhrasing(node, {
-      before: value,
+      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
+    );
+  }
+  return marker;
+}
+strong.peek = strongPeek;
+function strong(node2, _, state, info) {
+  const marker = checkStrong(state);
+  const exit = state.enter("strong");
+  const tracker = state.createTracker(info);
+  const before = tracker.move(marker + marker);
+  let between = tracker.move(
+    state.containerPhrasing(node2, {
       after: marker,
+      before,
       ...tracker.current()
     })
-  )
-  value += tracker.move(marker + marker)
-  exit()
-  return value
-}
-
-/**
- * @param {Strong} _
- * @param {Parents | undefined} _1
- * @param {State} state
- * @returns {string}
- */
+  );
+  const betweenHead = between.charCodeAt(0);
+  const open = encodeInfo(
+    info.before.charCodeAt(info.before.length - 1),
+    betweenHead,
+    marker
+  );
+  if (open.inside) {
+    between = encodeCharacterReference(betweenHead) + between.slice(1);
+  }
+  const betweenTail = between.charCodeAt(between.length - 1);
+  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
+  if (close.inside) {
+    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
+  }
+  const after = tracker.move(marker + marker);
+  exit();
+  state.attentionEncodeSurroundingInfo = {
+    after: close.outside,
+    before: open.outside
+  };
+  return before + between + after;
+}
 function strongPeek(_, _1, state) {
-  return state.options.strong || '*'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/text.js
-/**
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').Text} Text
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {Text} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function text_text(node, _, state, info) {
-  return state.safe(node.value, info)
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['ruleRepetition'], null | undefined>}
- */
+  return state.options.strong || "*";
+}
+function text(node2, _, state, info) {
+  return state.safe(node2.value, info);
+}
 function checkRuleRepetition(state) {
-  const repetition = state.options.ruleRepetition || 3
-
+  const repetition = state.options.ruleRepetition || 3;
   if (repetition < 3) {
     throw new Error(
-      'Cannot serialize rules with repetition `' +
-        repetition +
-        '` for `options.ruleRepetition`, expected `3` or more'
-    )
-  }
-
-  return repetition
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
-/**
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').ThematicBreak} ThematicBreak
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-/**
- * @param {ThematicBreak} _
- * @param {Parents | undefined} _1
- * @param {State} state
- * @returns {string}
- */
+      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
+    );
+  }
+  return repetition;
+}
 function thematicBreak(_, _1, state) {
-  const value = (
-    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')
-  ).repeat(checkRuleRepetition(state))
-
-  return state.options.ruleSpaces ? value.slice(0, -1) : value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/index.js
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-/**
- * Default (CommonMark) handlers.
- */
+  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
+  return state.options.ruleSpaces ? value.slice(0, -1) : value;
+}
 const handle = {
-  blockquote: blockquote,
+  blockquote,
   break: hardBreak,
-  code: code_code,
-  definition: definition,
-  emphasis: emphasis,
-  hardBreak: hardBreak,
-  heading: heading,
-  html: html,
-  image: image_image,
-  imageReference: imageReference,
-  inlineCode: inlineCode,
-  link: link_link,
-  linkReference: linkReference,
-  list: list,
-  listItem: listItem,
-  paragraph: paragraph,
-  root: root,
-  strong: strong,
-  text: text_text,
-  thematicBreak: thematicBreak
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-gfm-task-list-item/lib/index.js
-/**
- * @typedef {import('mdast').ListItem} ListItem
- * @typedef {import('mdast').Paragraph} Paragraph
- * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
- * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
- * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
- * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
- * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
- */
-
-
-
-
-/**
- * Create an extension for `mdast-util-from-markdown` to enable GFM task
- * list items in markdown.
- *
- * @returns {FromMarkdownExtension}
- *   Extension for `mdast-util-from-markdown` to enable GFM task list items.
- */
+  code,
+  definition,
+  emphasis,
+  hardBreak,
+  heading,
+  html,
+  image,
+  imageReference,
+  inlineCode,
+  link,
+  linkReference,
+  list,
+  listItem,
+  paragraph,
+  root,
+  strong,
+  text,
+  thematicBreak
+};
 function gfmTaskListItemFromMarkdown() {
   return {
     exit: {
@@ -6168,209 +3029,94 @@ function gfmTaskListItemFromMarkdown() {
       taskListCheckValueUnchecked: exitCheck,
       paragraph: exitParagraphWithTaskListItem
     }
-  }
+  };
 }
-
-/**
- * Create an extension for `mdast-util-to-markdown` to enable GFM task list
- * items in markdown.
- *
- * @returns {ToMarkdownExtension}
- *   Extension for `mdast-util-to-markdown` to enable GFM task list items.
- */
 function gfmTaskListItemToMarkdown() {
   return {
-    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],
-    handlers: {listItem: listItemWithTaskListItem}
-  }
+    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
+    handlers: { listItem: listItemWithTaskListItem }
+  };
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitCheck(token) {
-  // Were always in a paragraph, in a list item.
-  const node = this.stack[this.stack.length - 2]
-  ok(node.type === 'listItem')
-  node.checked = token.type === 'taskListCheckValueChecked'
-}
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
+  const node2 = this.stack[this.stack.length - 2];
+  ok$1(node2.type === "listItem");
+  node2.checked = token.type === "taskListCheckValueChecked";
+}
 function exitParagraphWithTaskListItem(token) {
-  const parent = this.stack[this.stack.length - 2]
-
-  if (
-    parent &&
-    parent.type === 'listItem' &&
-    typeof parent.checked === 'boolean'
-  ) {
-    const node = this.stack[this.stack.length - 1]
-    ok(node.type === 'paragraph')
-    const head = node.children[0]
-
-    if (head && head.type === 'text') {
-      const siblings = parent.children
-      let index = -1
-      /** @type {Paragraph | undefined} */
-      let firstParaghraph
-
+  const parent = this.stack[this.stack.length - 2];
+  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
+    const node2 = this.stack[this.stack.length - 1];
+    ok$1(node2.type === "paragraph");
+    const head = node2.children[0];
+    if (head && head.type === "text") {
+      const siblings = parent.children;
+      let index = -1;
+      let firstParaghraph;
       while (++index < siblings.length) {
-        const sibling = siblings[index]
-        if (sibling.type === 'paragraph') {
-          firstParaghraph = sibling
-          break
+        const sibling = siblings[index];
+        if (sibling.type === "paragraph") {
+          firstParaghraph = sibling;
+          break;
         }
       }
-
-      if (firstParaghraph === node) {
-        // Must start with a space or a tab.
-        head.value = head.value.slice(1)
-
+      if (firstParaghraph === node2) {
+        head.value = head.value.slice(1);
         if (head.value.length === 0) {
-          node.children.shift()
-        } else if (
-          node.position &&
-          head.position &&
-          typeof head.position.start.offset === 'number'
-        ) {
-          head.position.start.column++
-          head.position.start.offset++
-          node.position.start = Object.assign({}, head.position.start)
+          node2.children.shift();
+        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
+          head.position.start.column++;
+          head.position.start.offset++;
+          node2.position.start = Object.assign({}, head.position.start);
         }
       }
     }
   }
-
-  this.exit(token)
-}
-
-/**
- * @type {ToMarkdownHandle}
- * @param {ListItem} node
- */
-function listItemWithTaskListItem(node, parent, state, info) {
-  const head = node.children[0]
-  const checkable =
-    typeof node.checked === 'boolean' && head && head.type === 'paragraph'
-  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '
-  const tracker = state.createTracker(info)
-
+  this.exit(token);
+}
+function listItemWithTaskListItem(node2, parent, state, info) {
+  const head = node2.children[0];
+  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
+  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
+  const tracker = state.createTracker(info);
   if (checkable) {
-    tracker.move(checkbox)
+    tracker.move(checkbox);
   }
-
-  let value = handle.listItem(node, parent, state, {
+  let value = handle.listItem(node2, parent, state, {
     ...info,
     ...tracker.current()
-  })
-
+  });
   if (checkable) {
-    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check)
+    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
   }
-
-  return value
-
-  /**
-   * @param {string} $0
-   * @returns {string}
-   */
+  return value;
   function check($0) {
-    return $0 + checkbox
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-factory-space/index.js
-/**
- * @typedef {import('micromark-util-types').Effects} Effects
- * @typedef {import('micromark-util-types').State} State
- * @typedef {import('micromark-util-types').TokenType} TokenType
- */
-
-
-
-// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.
-
-/**
- * Parse spaces and tabs.
- *
- * There is no `nok` parameter:
- *
- * *   spaces in markdown are often optional, in which case this factory can be
- *     used and `ok` will be switched to whether spaces were found or not
- * *   one line ending or space can be detected with `markdownSpace(code)` right
- *     before using `factorySpace`
- *
- * ###### Examples
- *
- * Where `` represents a tab (plus how much it expands) and `` represents a
- * single space.
- *
- * ```markdown
- * 
- * 
- * 
- * ```
- *
- * @param {Effects} effects
- *   Context.
- * @param {State} ok
- *   State switched to when successful.
- * @param {TokenType} type
- *   Type (`' \t'`).
- * @param {number | undefined} [max=Infinity]
- *   Max (exclusive).
- * @returns {State}
- *   Start state.
- */
-function factorySpace(effects, ok, type, max) {
-  const limit = max ? max - 1 : Number.POSITIVE_INFINITY
-  let size = 0
-  return start
-
-  /** @type {State} */
-  function start(code) {
-    if (markdownSpace(code)) {
-      effects.enter(type)
-      return prefix(code)
+    return $0 + checkbox;
+  }
+}
+function factorySpace(effects, ok2, type, max) {
+  const limit = Number.POSITIVE_INFINITY;
+  let size = 0;
+  return start;
+  function start(code2) {
+    if (markdownSpace(code2)) {
+      effects.enter(type);
+      return prefix(code2);
     }
-    return ok(code)
-  }
-
-  /** @type {State} */
-  function prefix(code) {
-    if (markdownSpace(code) && size++ < limit) {
-      effects.consume(code)
-      return prefix
+    return ok2(code2);
+  }
+  function prefix(code2) {
+    if (markdownSpace(code2) && size++ < limit) {
+      effects.consume(code2);
+      return prefix;
     }
-    effects.exit(type)
-    return ok(code)
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
-/**
- * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'
- */
-
-
-
+    effects.exit(type);
+    return ok2(code2);
+  }
+}
 const tasklistCheck = {
-  name: 'tasklistCheck',
+  name: "tasklistCheck",
   tokenize: tokenizeTasklistCheck
 };
-
-/**
- * Create an HTML extension for `micromark` to support GFM task list items
- * syntax.
- *
- * @returns {Extension}
- *   Extension for `micromark` that can be passed in `htmlExtensions` to
- *   support GFM task list items when serializing to HTML.
- */
 function gfmTaskListItem() {
   return {
     text: {
@@ -6378,339 +3124,276 @@ function gfmTaskListItem() {
     }
   };
 }
-
-/**
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeTasklistCheck(effects, ok, nok) {
+function tokenizeTasklistCheck(effects, ok2, nok) {
   const self = this;
   return open;
-
-  /**
-   * At start of task list item check.
-   *
-   * ```markdown
-   * > | * [x] y.
-   *       ^
-   * ```
-   *
-   * @type {State}
-   */
-  function open(code) {
+  function open(code2) {
     if (
-    // Exit if theres stuff before.
-    self.previous !== null ||
-    // Exit if not in the first content that is the first child of a list
-    // item.
-    !self._gfmTasklistFirstContentOfListItem) {
-      return nok(code);
+      // Exit if theres stuff before.
+      self.previous !== null || // Exit if not in the first content that is the first child of a list
+      // item.
+      !self._gfmTasklistFirstContentOfListItem
+    ) {
+      return nok(code2);
     }
-    effects.enter('taskListCheck');
-    effects.enter('taskListCheckMarker');
-    effects.consume(code);
-    effects.exit('taskListCheckMarker');
+    effects.enter("taskListCheck");
+    effects.enter("taskListCheckMarker");
+    effects.consume(code2);
+    effects.exit("taskListCheckMarker");
     return inside;
   }
-
-  /**
-   * In task list item check.
-   *
-   * ```markdown
-   * > | * [x] y.
-   *        ^
-   * ```
-   *
-   * @type {State}
-   */
-  function inside(code) {
-    // Currently we match how GH works in files.
-    // To match how GH works in comments, use `markdownSpace` (`[\t ]`) instead
-    // of `markdownLineEndingOrSpace` (`[\t\n\r ]`).
-    if (markdownLineEndingOrSpace(code)) {
-      effects.enter('taskListCheckValueUnchecked');
-      effects.consume(code);
-      effects.exit('taskListCheckValueUnchecked');
+  function inside(code2) {
+    if (markdownLineEndingOrSpace(code2)) {
+      effects.enter("taskListCheckValueUnchecked");
+      effects.consume(code2);
+      effects.exit("taskListCheckValueUnchecked");
       return close;
     }
-    if (code === 88 || code === 120) {
-      effects.enter('taskListCheckValueChecked');
-      effects.consume(code);
-      effects.exit('taskListCheckValueChecked');
+    if (code2 === 88 || code2 === 120) {
+      effects.enter("taskListCheckValueChecked");
+      effects.consume(code2);
+      effects.exit("taskListCheckValueChecked");
       return close;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * At close of task list item check.
-   *
-   * ```markdown
-   * > | * [x] y.
-   *         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function close(code) {
-    if (code === 93) {
-      effects.enter('taskListCheckMarker');
-      effects.consume(code);
-      effects.exit('taskListCheckMarker');
-      effects.exit('taskListCheck');
+  function close(code2) {
+    if (code2 === 93) {
+      effects.enter("taskListCheckMarker");
+      effects.consume(code2);
+      effects.exit("taskListCheckMarker");
+      effects.exit("taskListCheck");
       return after;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * @type {State}
-   */
-  function after(code) {
-    // EOL in paragraph means there must be something else after it.
-    if (markdownLineEnding(code)) {
-      return ok(code);
+  function after(code2) {
+    if (markdownLineEnding(code2)) {
+      return ok2(code2);
     }
-
-    // Space or tab?
-    // Check what comes after.
-    if (markdownSpace(code)) {
+    if (markdownSpace(code2)) {
       return effects.check({
         tokenize: spaceThenNonSpace
-      }, ok, nok)(code);
+      }, ok2, nok)(code2);
     }
-
-    // EOF, or non-whitespace, both wrong.
-    return nok(code);
+    return nok(code2);
   }
 }
-
-/**
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function spaceThenNonSpace(effects, ok, nok) {
+function spaceThenNonSpace(effects, ok2, nok) {
   return factorySpace(effects, after, "whitespace");
-
-  /**
-   * After whitespace, after task list item check.
-   *
-   * ```markdown
-   * > | * [x] y.
-   *           ^
-   * ```
-   *
-   * @type {State}
-   */
-  function after(code) {
-    // EOF means there was nothing, so bad.
-    // EOL means theres content after it, so good.
-    // Impossible to have more spaces.
-    // Anything else is good.
-    return code === null ? nok(code) : ok(code);
-  }
-}
-;// CONCATENATED MODULE: ./src/syntax-extensions/TaskListItemExtension.ts
-
-
-
-
-
+  function after(code2) {
+    return code2 === null ? nok(code2) : ok2(code2);
+  }
+}
 class TaskListItemView {
-    constructor(node, view, getPos) {
-        const checkbox = document.createElement("input");
-        checkbox.setAttribute("type", "checkbox");
-        checkbox.setAttribute("style", "cursor: pointer;");
-        if (node.attrs["checked"] === true) {
-            checkbox.setAttribute("checked", "checked");
+  constructor(node2, view, getPos) {
+    const checkbox = document.createElement("input");
+    checkbox.setAttribute("type", "checkbox");
+    checkbox.setAttribute("style", "cursor: pointer;");
+    if (node2.attrs["checked"] === true) {
+      checkbox.setAttribute("checked", "checked");
+    }
+    checkbox.addEventListener("click", (e) => {
+      const pos = getPos();
+      if (pos === void 0) {
+        return;
+      }
+      e.preventDefault();
+      view.dispatch(
+        view.state.tr.setNodeAttribute(
+          pos,
+          "checked",
+          !node2.attrs["checked"]
+        )
+      );
+    });
+    const checkboxContainer = document.createElement("span");
+    checkboxContainer.setAttribute("contenteditable", "false");
+    checkboxContainer.setAttribute("style", "position: absolute; left: 5px;");
+    checkboxContainer.appendChild(checkbox);
+    this.contentDOM = document.createElement("span");
+    this.contentDOM.setAttribute("style", "position: relative; left: 30px;");
+    this.dom = document.createElement("li");
+    this.dom.setAttribute(
+      "style",
+      "list-style-type: none; margin-left: -30px;"
+    );
+    this.dom.appendChild(checkboxContainer);
+    this.dom.appendChild(this.contentDOM);
+  }
+  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inherited from the NodeView interface
+  stopEvent() {
+    return true;
+  }
+}
+class TaskListItemExtension extends prosemirrorUnified.NodeExtension {
+  static isAtStart(state, view) {
+    if (!state.selection.empty) {
+      return false;
+    }
+    if (view !== void 0) {
+      return view.endOfTextblock("backward", state);
+    }
+    return state.selection.$anchor.parentOffset > 0;
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new prosemirrorInputrules.InputRule(/^\[([x\s]?)\][\s\S]$/u, (state, match, start) => {
+        const wrappingNode = state.doc.resolve(start).node(-1);
+        if (wrappingNode.type.name !== "regular_list_item") {
+          return null;
         }
-        checkbox.addEventListener("click", (e) => {
-            const pos = getPos();
-            if (pos === undefined) {
-                return;
-            }
-            e.preventDefault();
-            view.dispatch(view.state.tr.setNodeAttribute(pos, "checked", !node.attrs["checked"]));
-        });
-        const checkboxContainer = document.createElement("span");
-        checkboxContainer.setAttribute("contenteditable", "false");
-        checkboxContainer.setAttribute("style", "position: absolute; left: 5px;");
-        checkboxContainer.appendChild(checkbox);
-        this.contentDOM = document.createElement("span");
-        this.contentDOM.setAttribute("style", "position: relative; left: 30px;");
-        this.dom = document.createElement("li");
-        this.dom.setAttribute("style", "list-style-type: none; margin-left: -30px;");
-        this.dom.appendChild(checkboxContainer);
-        this.dom.appendChild(this.contentDOM);
-    }
-    // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inherited from the NodeView interface
-    stopEvent() {
-        return true;
-    }
-}
-/**
- * @public
- */
-class TaskListItemExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    static isAtStart(state, view) {
-        if (!state.selection.empty) {
-            return false;
+        return state.tr.replaceRangeWith(
+          start - 2,
+          start + wrappingNode.nodeSize,
+          proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(
+            { checked: match[1] === "x" },
+            wrappingNode.content.cut(3 + match[1].length)
+          )
+        );
+      })
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      Backspace: (state, dispatch, view) => {
+        if (!TaskListItemExtension.isAtStart(state, view)) {
+          return false;
         }
-        if (view !== undefined) {
-            return view.endOfTextblock("backward", state);
+        const taskListItemNode = state.selection.$anchor.node(-1);
+        if (taskListItemNode.type.name !== "task_list_item") {
+          return false;
         }
-        return state.selection.$anchor.parentOffset > 0;
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_inputrules_namespaceObject.InputRule(/^\[([x\s]?)\][\s\S]$/u, (state, match, start) => {
-                const wrappingNode = state.doc.resolve(start).node(-1);
-                if (wrappingNode.type.name !== "regular_list_item") {
-                    return null;
-                }
-                return state.tr.replaceRangeWith(start - 2, start + wrappingNode.nodeSize, proseMirrorSchema.nodes[this.proseMirrorNodeName()].create({ checked: match[1] === "x" }, wrappingNode.content.cut(3 + match[1].length)));
-            }),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            Backspace: (state, dispatch, view) => {
-                if (!TaskListItemExtension.isAtStart(state, view)) {
-                    return false;
-                }
-                const taskListItemNode = state.selection.$anchor.node(-1);
-                if (taskListItemNode.type.name !== "task_list_item") {
-                    return false;
-                }
-                if (dispatch === undefined) {
-                    return true;
-                }
-                dispatch(state.tr.replaceRangeWith(state.selection.$from.before() - 2, state.selection.$from.before() + taskListItemNode.nodeSize, proseMirrorSchema.nodes["regular_list_item"].create({}, taskListItemNode.content)));
-                return true;
-            },
-        };
-    }
-    proseMirrorNodeName() {
-        return "task_list_item";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: { checked: { default: false } },
-            content: "paragraph block*",
-            defining: true,
-            group: "list_item",
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        const checkbox = dom.firstChild;
-                        if (!(checkbox instanceof HTMLInputElement)) {
-                            return false;
-                        }
-                        return { checked: checkbox.checked };
-                    },
-                    tag: "li",
-                },
-            ],
-            toDOM(node) {
-                return [
-                    "li",
-                    { style: "list-style-type: none;, margin-left: -30px;" },
-                    [
-                        "span",
-                        {
-                            contenteditable: "false",
-                            style: "position: absolute; left: 5px;",
-                        },
-                        [
-                            "input",
-                            {
-                                checked: node.attrs["checked"]
-                                    ? "checked"
-                                    : undefined,
-                                disabled: "disabled",
-                                type: "checkbox",
-                            },
-                        ],
-                    ],
-                    ["span", { style: "position: relative; left: 30px" }, 0],
-                ];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node, convertedChildren) {
+        if (dispatch === void 0) {
+          return true;
+        }
+        dispatch(
+          state.tr.replaceRangeWith(
+            state.selection.$from.before() - 2,
+            state.selection.$from.before() + taskListItemNode.nodeSize,
+            proseMirrorSchema.nodes["regular_list_item"].create(
+              {},
+              taskListItemNode.content
+            )
+          )
+        );
+        return true;
+      }
+    };
+  }
+  proseMirrorNodeName() {
+    return "task_list_item";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: { checked: { default: false } },
+      content: "paragraph block*",
+      defining: true,
+      group: "list_item",
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            const checkbox = dom.firstChild;
+            if (!(checkbox instanceof HTMLInputElement)) {
+              return false;
+            }
+            return { checked: checkbox.checked };
+          },
+          tag: "li"
+        }
+      ],
+      toDOM(node2) {
         return [
+          "li",
+          { style: "list-style-type: none;, margin-left: -30px;" },
+          [
+            "span",
             {
-                checked: node.attrs["checked"],
-                children: convertedChildren,
-                type: this.unistNodeName(),
+              contenteditable: "false",
+              style: "position: absolute; left: 5px;"
             },
+            [
+              "input",
+              {
+                checked: node2.attrs["checked"] ? "checked" : void 0,
+                disabled: "disabled",
+                type: "checkbox"
+              }
+            ]
+          ],
+          ["span", { style: "position: relative; left: 30px" }, 0]
         ];
-    }
-    proseMirrorNodeView() {
-        return (node, view, getPos) => new TaskListItemView(node, view, getPos);
-    }
-    unifiedInitializationHook(processor) {
-        return processor.use(buildUnifiedExtension([gfmTaskListItem()], [gfmTaskListItemFromMarkdown()], [gfmTaskListItemToMarkdown()]));
-    }
-    unistNodeName() {
-        return "listItem";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, { checked: node.checked });
-    }
-    unistToProseMirrorTest(node) {
-        return (node.type === this.unistNodeName() &&
-            "checked" in node &&
-            typeof node.checked === "boolean");
-    }
-}
-
-;// CONCATENATED MODULE: ./src/GFMExtension.ts
-
-
-
-
-
-/**
- * @public
- */
-class GFMExtension extends external_prosemirror_unified_namespaceObject.Extension {
-    dependencies() {
-        return [
-            new MarkdownExtension(),
-            new ExtendedAutolinkExtension(),
-            new StrikethroughExtension(),
-            new TaskListItemExtension(),
-        ];
-    }
-}
-
-;// CONCATENATED MODULE: ./src/index.ts
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-module.exports = __webpack_exports__;
-
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2, convertedChildren) {
+    return [
+      {
+        checked: node2.attrs["checked"],
+        children: convertedChildren,
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  proseMirrorNodeView() {
+    return (node2, view, getPos) => new TaskListItemView(node2, view, getPos);
+  }
+  unifiedInitializationHook(processor) {
+    return processor.use(
+      buildUnifiedExtension(
+        [gfmTaskListItem()],
+        [gfmTaskListItemFromMarkdown()],
+        [gfmTaskListItemToMarkdown()]
+      )
+    );
+  }
+  unistNodeName() {
+    return "listItem";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return prosemirrorUnified.createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      { checked: node2.checked }
+    );
+  }
+  unistToProseMirrorTest(node2) {
+    return node2.type === this.unistNodeName() && "checked" in node2 && typeof node2.checked === "boolean";
+  }
+}
+class GFMExtension extends prosemirrorUnified.Extension {
+  dependencies() {
+    return [
+      new MarkdownExtension(),
+      new ExtendedAutolinkExtension(),
+      new StrikethroughExtension(),
+      new TaskListItemExtension()
+    ];
+  }
+}
+exports.BlockquoteExtension = BlockquoteExtension;
+exports.BoldExtension = BoldExtension;
+exports.BreakExtension = BreakExtension;
+exports.CodeBlockExtension = CodeBlockExtension;
+exports.DefinitionExtension = DefinitionExtension;
+exports.ExtendedAutolinkExtension = ExtendedAutolinkExtension;
+exports.GFMExtension = GFMExtension;
+exports.HeadingExtension = HeadingExtension;
+exports.HorizontalRuleExtension = HorizontalRuleExtension;
+exports.ImageExtension = ImageExtension;
+exports.ImageReferenceExtension = ImageReferenceExtension;
+exports.InlineCodeExtension = InlineCodeExtension;
+exports.ItalicExtension = ItalicExtension;
+exports.LinkExtension = LinkExtension;
+exports.LinkReferenceExtension = LinkReferenceExtension;
+exports.ListItemExtension = ListItemExtension;
+exports.MarkdownExtension = MarkdownExtension;
+exports.OrderedListExtension = OrderedListExtension;
+exports.ParagraphExtension = ParagraphExtension;
+exports.RootExtension = RootExtension;
+exports.StrikethroughExtension = StrikethroughExtension;
+exports.TaskListItemExtension = TaskListItemExtension;
+exports.TextExtension = TextExtension;
+exports.UnorderedListExtension = UnorderedListExtension;
 //# sourceMappingURL=prosemirror-remark.cjs.map
diff --git a/dist/prosemirror-remark.cjs.map b/dist/prosemirror-remark.cjs.map
index a157ad1faf277ec367a1b6ecaf2d966aa6df5669..a9fda00aa254873d8c657523ce855fdb42166bc3 100644
--- a/dist/prosemirror-remark.cjs.map
+++ b/dist/prosemirror-remark.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"prosemirror-remark.cjs","mappings":"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aAAa,EAAE;YACnB,IAAI,aAAa,EAAE;YACnB,IAAI,sBAAsB,EAAE;SAC7B,CAAC;IACJ,CAAC;IAEe,yBAAyB,CACvC,SAAwE;QAExE,OAAO,SAAS,CAAC,GAAG,CAAC,gDAAW,CAAC,CAAC,GAAG,CAAC,oDAAe,EAAE;YACrD,MAAM,EAAE,IAAI;YACZ,cAAc,EAAE,KAAK;YACrB,YAAY,EAAE,IAAI;YAClB,IAAI,EAAE,GAAG;SACV,CAMA,CAAC;IACJ,CAAC;CACF;;;ACxED;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,YAAY;AACZ;AACA;AACO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AC1BO;AACP;AACA;;AAEO;;AAEA;;AAEA;;;ACRP;AACA,aAAa,qCAAqC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA;AACO,gDAAgD;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C,EAAE,IAAI,EAAE;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;ACnPe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;;ACVA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC;;AAEA;AACA;AACA;AACA,aAAa,oEAAoE;AACjF;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,2BAA2B;AACtC;AACA,aAAa;AACb;AACA;AACA,aAAa,gCAAgC;AAC7C;AACA;AACA;AACA;AACA,aAAa,yFAAyF;AACtG;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,MAAM;AACjB;AACA,WAAW,oBAAoB;AAC/B;AACA,WAAW,oBAAoB;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,MAAM;AACjB;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,YAAY;AACZ,gLAAgL,gBAAgB;AAChM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,MAAM;AACrB,eAAe,2BAA2B;AAC1C,eAAe,2BAA2B;AAC1C,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,YAAY;AACZ,oLAAoL,gBAAgB;AACpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,MAAE;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,sCAAsC;AACjD,aAAa;AACb;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,mCAAmC,yBAAyB;;AAE5D;;AAEA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA,oCAAoC,yBAAyB;AAC7D,iBAAiB,SAAS;AAC1B;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;;AAEA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,MAAE;AACX;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;;AClSA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;;;ACNA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC;;AAEA;AACA,aAAa,8DAA8D;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;;AAEA;AACA,aAAa,4CAA4C;AACzD,aAAa;AACb;;AAEA;AACA,aAAa,sKAAsK;AACnL;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa,kDAAkD;AAC/D;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB,UAAU;AACV,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa,oDAAoD;AACjE;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB,UAAU;AACV,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAoE;AACjF;AACA;AACA,aAAa,wDAAwD;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,uBAAuB;AAClC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA,aAAa,+GAA+G;AAC5H;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;;AAEqC;AAC0B;;AAE/D,WAAW,uBAAuB;AAClC;;AAEA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,2BAA2B;AACtC,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA;AACA,WAAW,MAAM;AACjB,WAAW,oBAAoB;AAC/B,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA,WAAW,WAAW;AACtB;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,sCAAsC;AACjD;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;AACO;AACP,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;;AAEA;;AAEA;AACA,aAAa,WAAW;AACxB,aAAa,oBAAoB;AACjC,aAAa,oBAAoB;AACjC;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,KAAK;AAC1B,OAAO;AACP;;AAEA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA,iBAAiB,uBAAuB;AACxC;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,oBAAoB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,aAAa;;AAErD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AC7YA;AACA,aAAa,uBAAuB;AACpC,aAAa,yBAAyB;AACtC,aAAa,iCAAiC;AAC9C,aAAa,sBAAsB;AACnC,aAAa,sBAAsB;AACnC,aAAa,yCAAyC;AACtD,aAAa,kDAAkD;AAC/D;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,2BAA2B;AACzC;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA,aAAa,6CAA6C;AAC1D;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;;AAEyC;AACY;AAChB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,0CAA0C;AACrD;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb;AACA;AACO;AACP;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,IAAI,YAAY;AAChB;;AAEA,aAAa,+DAA+D;AAC5E;AACA;AACA,eAAe,qBAAqB;AACpC;;AAEA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,gBAAgB;AAC7B;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,qBAAqB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,6CAA6C;AACjE;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,+CAA+C,kBAAM;AACrD;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzQA;AACA,YAAY,oCAAoC;AAChD,YAAY,sHAAsH;AAClI,YAAY,+CAA+C;AAC3D,YAAY,uBAAuB;AACnC;;AAE6B;AACM;AAC2C;AACpB;;AAE1D,WAAW,eAAe;AAC1B;AACA,WAAW,sBAAsB;AACjC;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,cAAc,iDAAiD;AAC/D;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA,EAAE,EAAM;AACR;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA,WAAW,uBAAuB;AAClC;AACA,EAAE,cAAc;AAChB;AACA;AACA;AACA,oBAAoB,EAAE,IAAI,EAAE;AAC5B;AACA,KAAK;AACL;AACA;;AAEA;AACA,UAAU;AACV,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;;AAEA;AACA,qBAAqB,8BAA8B;AACnD;;AAEA;AACA;;AAEA;AACA,UAAU;AACV,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,+BAA+B,MAAM;;AAErC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wBAAwB,MAAM;AAC9B,sBAAsB,MAAM;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AACxB;AACA;AACA;AACA;;;ACvRA;AACA,YAAY,sFAAsF;AAClG;;AAEyJ;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,iBAAiB;AAC5B,MAAM,WAAI;;AAEV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACO;AACP;AACA,QAAQ;AACR;AACA;;AAEA,WAAW,MAAM;AACjB;;AAEA;AACA;AACA,EAAE,WAAI;AACN;AACA,6BAA6B;AAC7B;AACA,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ,UAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,4BAA4B,YAAY,UAAU,yBAAyB,UAAU,iBAAiB,UAAU,kBAAkB;AAClI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,aAAa,qBAAqB;AAClC;AACA,aAAa,qBAAqB;AAClC;AACA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAyB,UAAU,iBAAiB,yBAAyB,kBAAkB;AACxH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAyB,UAAU,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB,UAAU,iBAAiB;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,uDAAuD,yBAAyB,UAAU,iBAAiB;AAC3G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,WAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,UAAU;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,qHAAqH,yBAAyB;AAC9I;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,UAAU;AACpB;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA,qEAAqE,iBAAiB;AACtF;;AAEA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh1BO,SAAS,qBAAqB,CACnC,mBAA8C,EAC9C,sBAAoD,EACpD,oBAAgD;IAEhD,OAAO;;QACL,uEAAuE;QACvE,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAEzB,UAAI,CAAC,mBAAmB,oCAAxB,IAAI,CAAC,mBAAmB,GAAK,EAAE,EAAC;QAChC,UAAI,CAAC,sBAAsB,oCAA3B,IAAI,CAAC,sBAAsB,GAAK,EAAE,EAAC;QACnC,UAAI,CAAC,oBAAoB,oCAAzB,IAAI,CAAC,oBAAoB,GAAK,EAAE,EAAC;QAEjC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,GAAG,mBAAmB,CAAC,CAAC;QACtD,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,GAAG,sBAAsB,CAAC,CAAC;QAC5D,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,oBAAoB,CAAC,CAAC;IAC1D,CAAC,CAAC;AACJ,CAAC;;;AChBwC;AACqC;AAC9B;AAEuB;AAEvE;;GAEG;AACI,MAAM,yBAA0B,SAAQ,sDAAS;IACtC,yBAAyB,CACvC,SAAwE;QAExE,OAAO,SAAS,CAAC,GAAG,CAClB,qBAAqB,CACnB,CAAC,kBAAkB,EAAE,CAAC,EACtB,CAAC,8BAA8B,EAAE,CAAC,EAClC,CAAC,4BAA4B,EAAE,CAAC,CACjC,CACF,CAAC;IACJ,CAAC;CACF;;;AC3BD;AACA,aAAa,wBAAwB;AACrC;AACA,aAAa,mDAAmD;AAChE,aAAa,8CAA8C;AAC3D,aAAa,2CAA2C;AACxD;AACA,aAAa,gDAAgD;AAC7D,aAAa,yCAAyC;AACtD,aAAa,0CAA0C;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,cAAc,6BAA6B;AAC3C;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,WAAW,kBAAkB;AAC7B;AACA;AACA;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,aAAa,gBAAgB;AAC7B;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;AChFA;AACA,aAAa,qCAAqC;AAClD;;AAMiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,IAAI,yBAAyB;AAC7B,IAAI,iBAAiB;AACrB;AACA;AACA;AACA,MAAM,kBAAkB;AACxB;AACA;AACA;;;AClCA;AACA,aAAa,sCAAsC;AACnD,aAAa,yCAAyC;AACtD,aAAa,gDAAgD;AAC7D;;AAEA;AACA;AACA;AACA,WAAW,OAAO,kCAAkC,GAAG;AACvD;AACA,WAAW,cAAc;AACzB;AACA,WAAW,iBAAiB;AAC5B;AACA,aAAa;AACb;AACA;AACO;AACP,aAAa,iBAAiB;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACjCA;AACA,YAAY,SAAS;AACrB,YAAY,sEAAsE;AAClF;;AAEgD;AACsB;AACd;AACxD;AACA;AACA;AACA,WAAW,4BAA4B,WAAW;AAClD;AACA,aAAa;AACb;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA,qCAAqC;AACrC,mCAAmC;AACnC;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA,qCAAqC;AACrC,mCAAmC;AACnC;;AAEA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,cAAc,MAAM,mCAAmC,UAAU;AACjE;;AAEA;AACA,YAAY,MAAM;AAClB,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A;;;AC/BA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;ACnCA;AACA,aAAa,sBAAsB;AACnC,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,sBAAsB;AACnC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,2BAA2B;AACxC,aAAa,6BAA6B;AAC1C;;AAE4C;AAC2B;AACtB;;AAEjD;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO,SAAS,SAAI;AACpB,iBAAiB,UAAU;AAC3B;AACA;;AAEA,MAAM,oBAAoB;AAC1B;AACA,yCAAyC,QAAG;AAC5C;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;AACvD;AACA;;AAEA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,KAAK;AAChB,SAAS,QAAG;AACZ;AACA;;;AC7EA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,4BAA4B;AACzC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEiD;;AAEjD;AACA,WAAW,YAAY;AACvB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAgD;AAC5E;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AC7EA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,0BAA0B;AACvC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEuD;;AAEvD;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;;AC/CA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC,aAAa,kDAAkD;AAC/D;;AAEA;AACA,aAAa,8DAA8D;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;;AAEA;AACA,aAAa,4CAA4C;AACzD,aAAa;AACb;;AAEA;AACA,aAAa,sKAAsK;AACnL;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa,kDAAkD;AAC/D;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB,UAAU;AACV,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB,UAAU;AACV,cAAc,MAAM;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,wDAAwD;AACnE;AACA,WAAW,6DAA6D;AACxE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA,aAAa,6CAA6C;AAC1D;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;;AAEqD;;AAEQ;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,2BAA2B;AACtC,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA;AACA,WAAW,MAAM;AACjB,WAAW,oBAAoB;AAC/B,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA,WAAW,WAAW;AACtB;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,sCAAsC;AACjD;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;AACO;AACP,aAAa,4BAA4B;AACzC;AACA,aAAa,MAAM;AACnB;AACA,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,YAAY;;AAEd;AACA,aAAa,WAAW;AACxB,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxTA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA,cAAc,4BAA4B;AAC1C;AACA;;AAEA,WAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb;AACA;AACO,SAAS,YAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAG;AAChB;AACA;;AAEA;AACA,WAAW,OAAG;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA,SAAS,OAAG;AACZ,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;AC3GA;AACA,aAAa,yBAAyB;AACtC,aAAa,6BAA6B;AAC1C;;AAE4C;AACC;;AAE7C;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA,EAAE,KAAK;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA,GAAG;;AAEH;AACA;AACA,MAAM,YAAQ;AACd;AACA;AACA;;;ACjCA;AACA,aAAa,yBAAyB;AACtC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEyE;;AAEzE;AACA,WAAW,SAAS;AACpB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;;AAEA,MAAM,qBAAqB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AC/EA;AACA,aAAa,sBAAsB;AACnC;;AAEA;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;ACnBA;AACA,aAAa,uBAAuB;AACpC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEiD;;AAEjD,WAAK;;AAEL;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO,SAAS,WAAK;AACrB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAgD;AAC5E;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;ACnFA;AACA,aAAa,gCAAgC;AAC7C,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEA;;AAEA;AACA,WAAW,gBAAgB;AAC3B,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AChEA;AACA,aAAa,4BAA4B;AACzC,aAAa,yBAAyB;AACtC,aAAa,6BAA6B;AAC1C;;AAEA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AC5EA;AACA,aAAa,sBAAsB;AACnC,aAAa,6BAA6B;AAC1C;;AAE6C;;AAE7C;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP,cAAc,YAAQ;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA,aAAa,sBAAsB;AACnC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEiD;AACsB;;AAEvE,SAAI;;AAEJ;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO,SAAS,SAAI;AACpB,gBAAgB,UAAU;AAC1B;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,MAAM;AACnB;;AAEA,MAAM,oBAAoB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAgD;AAC5E;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,SAAS,oBAAoB;AAC7B;;;ACnHA;AACA,aAAa,+BAA+B;AAC5C,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEA;;AAEA;AACA,WAAW,eAAe;AAC1B,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AChEA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAE6C;;AAE7C;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP,iBAAiB,WAAW;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACtCA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,sBAAsB;AACnC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEmD;AACW;AACI;AACnB;;AAE/C;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA,aAAa,QAAQ;AACrB,8BAA8B,kBAAkB,UAAU,WAAW;AACrE,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,MAAM,gBAAgB;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAS;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrGA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,0BAA0B;AACvC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,2BAA2B;AACxC,aAAa,6BAA6B;AAC1C;;AAEmD;AACkB;;AAErE;AACA,WAAW,UAAU;AACrB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,yBAAyB,mBAAmB;AAC5C,sCAAsC,WAAW;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AChEA;AACA,aAAa,2BAA2B;AACxC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA,aAAa,sBAAsB;AACnC,aAAa,iCAAiC;AAC9C;;AAEqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,aAAa,4DAA4D;AACzE;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5CA;AACA,aAAa,yBAAyB;AACtC,aAAa,sBAAsB;AACnC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAE4C;;AAE5C;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA,WAAW,QAAQ;AACnB,GAAG;AACH;AACA;AACA;;;ACvBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,yBAAyB;AACtC,aAAa,wBAAwB;AACrC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEmD;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;;AC/CA;AACA,aAAa,yBAAyB;AACtC,aAAa,sBAAsB;AACnC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO,SAAS,SAAI;AACpB;AACA;;;AChBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,yBAAyB;AACtC,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEoE;AACrB;;AAE/C;AACA,WAAW,eAAe;AAC1B,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA,IAAI,SAAS;AACb,WAAW,mBAAmB;;AAE9B;AACA;;;ACrB0C;AACN;AACN;AACY;AACJ;AACF;AACN;AACE;AACmB;AACR;AACb;AACmB;AACnB;AACS;AACC;AACV;AACI;AACJ;AACmB;;AAEjD;AACA;AACA;AACO;AACP,YAAY;AACZ,SAAS,SAAS;AAClB,MAAM;AACN,YAAY;AACZ,UAAU;AACV,WAAW;AACX,SAAS;AACT,MAAM;AACN,OAAO;AACP,gBAAgB;AAChB,YAAY;AACZ,MAAM;AACN,eAAe;AACf,MAAM;AACN,UAAU;AACV,WAAW;AACX,MAAM;AACN,QAAQ;AACR,MAAM;AACN,eAAe;AACf;;;AC5CA;AACA,aAAa,0BAA0B;AACvC,aAAa,2BAA2B;AACxC,aAAa,mDAAmD;AAChE,aAAa,8CAA8C;AAC3D,aAAa,2CAA2C;AACxD,aAAa,0CAA0C;AACvD,aAAa,yCAAyC;AACtD;;AAEmC;AACmB;;AAEtD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA,cAAc,8CAA8C;AAC5D,eAAe;AACf;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA,EAAE,EAAM;AACR;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAM;AACV;;AAEA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,MAAe;AAC7B;AACA;AACA,GAAG;;AAEH;AACA,qDAAqD,IAAI;AACzD;;AAEA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;;;AC5IA;AACA,aAAa,wCAAwC;AACrD,aAAa,sCAAsC;AACnD,aAAa,0CAA0C;AACvD;;AAEsD;;AAEtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,WAAW;AACtB;AACA,WAAW,oBAAoB;AAC/B;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjEA;AACA,YAAY,8CAA8C;AAC1D;;AAEuD;AACiD;AACxG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ,kBAAkB;AAC1B;AACA;;AAEA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,SAAS,YAAY;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IuC;AACkC;AACtB;AACwB;AAEJ;AAEvE,MAAM,gBAAgB;IAIpB,YACE,IAAqB,EACrB,IAAgB,EAChB,MAAgC;QAEhC,MAAM,QAAQ,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QACjD,QAAQ,CAAC,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAC1C,QAAQ,CAAC,YAAY,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;QACnD,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,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","sources":["webpack://prosemirror-remark/webpack/bootstrap","webpack://prosemirror-remark/webpack/runtime/define property getters","webpack://prosemirror-remark/webpack/runtime/hasOwnProperty shorthand","webpack://prosemirror-remark/webpack/runtime/make namespace object","webpack://prosemirror-remark/external module \"prosemirror-unified\"","webpack://prosemirror-remark/external module \"remark-parse\"","webpack://prosemirror-remark/external module \"remark-stringify\"","webpack://prosemirror-remark/external module \"prosemirror-commands\"","webpack://prosemirror-remark/external module \"prosemirror-inputrules\"","webpack://prosemirror-remark/./src/syntax-extensions/BlockquoteExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/BoldExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/BreakExtension.ts","webpack://prosemirror-remark/external module \"prosemirror-state\"","webpack://prosemirror-remark/./src/syntax-extensions/TextExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/CodeBlockExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/DefinitionExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ParagraphExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/HeadingExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/HorizontalRuleExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ImageExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ImageReferenceExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/InlineCodeExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ItalicExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/LinkExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/LinkReferenceExtension.ts","webpack://prosemirror-remark/external module \"prosemirror-schema-list\"","webpack://prosemirror-remark/./src/syntax-extensions/ListItemExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/OrderedListExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/RootExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/UnorderedListExtension.ts","webpack://prosemirror-remark/./src/MarkdownExtension.ts","webpack://prosemirror-remark/./node_modules/ccount/index.js","webpack://prosemirror-remark/./node_modules/devlop/lib/default.js","webpack://prosemirror-remark/./node_modules/micromark-util-character/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","webpack://prosemirror-remark/./node_modules/unist-util-is/lib/index.js","webpack://prosemirror-remark/./node_modules/unist-util-visit-parents/lib/color.js","webpack://prosemirror-remark/./node_modules/unist-util-visit-parents/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-find-and-replace/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-gfm-autolink-literal/lib/index.js","webpack://prosemirror-remark/./node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","webpack://prosemirror-remark/./src/utils/buildUnifiedExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ExtendedAutolinkExtension.ts","webpack://prosemirror-remark/./node_modules/mdast-util-gfm-strikethrough/lib/index.js","webpack://prosemirror-remark/./node_modules/micromark-util-chunked/index.js","webpack://prosemirror-remark/./node_modules/micromark-util-classify-character/index.js","webpack://prosemirror-remark/./node_modules/micromark-util-resolve-all/index.js","webpack://prosemirror-remark/./node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","webpack://prosemirror-remark/./src/syntax-extensions/StrikethroughExtension.ts","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/break.js","webpack://prosemirror-remark/./node_modules/longest-streak/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-fence.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/code.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-quote.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/definition.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","webpack://prosemirror-remark/./node_modules/unist-util-visit/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-string/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/heading.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/html.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/image.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/link.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-rule.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/list.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/list-item.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","webpack://prosemirror-remark/./node_modules/mdast-util-phrasing/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/root.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-strong.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/strong.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/text.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-gfm-task-list-item/lib/index.js","webpack://prosemirror-remark/./node_modules/micromark-factory-space/index.js","webpack://prosemirror-remark/./node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","webpack://prosemirror-remark/./src/syntax-extensions/TaskListItemExtension.ts","webpack://prosemirror-remark/./src/GFMExtension.ts","webpack://prosemirror-remark/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"Extension\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.Extension), [\"MarkExtension\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.MarkExtension), [\"MarkInputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.MarkInputRule), [\"NodeExtension\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.NodeExtension), [\"createProseMirrorNode\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.createProseMirrorNode) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"default\"]: () => (__WEBPACK_EXTERNAL_MODULE_remark_parse_76724963__[\"default\"]) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"default\"]: () => (__WEBPACK_EXTERNAL_MODULE_remark_stringify_a28ae2a6__[\"default\"]) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"chainCommands\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.chainCommands), [\"exitCode\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.exitCode), [\"setBlockType\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.setBlockType), [\"toggleMark\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.toggleMark), [\"wrapIn\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.wrapIn) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"InputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.InputRule), [\"textblockTypeInputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.textblockTypeInputRule), [\"wrappingInputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.wrappingInputRule) });","import type { BlockContent, Blockquote, DefinitionContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { wrapIn } from \"prosemirror-commands\";\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BlockquoteExtension extends NodeExtension<Blockquote> {\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}>\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Mod->\": wrapIn(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"blockquote\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{ tag: \"blockquote\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"blockquote\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<Blockquote> {\n    return [\n      {\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"blockquote\" {\n    return \"blockquote\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Blockquote,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Emphasis, Strong, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BoldExtension extends MarkExtension<Strong> {\n  public override processConvertedUnistNode(\n    convertedNode: Emphasis | Text,\n  ): Strong {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /\\*\\*([^\\s](?:.*[^\\s])?)\\*\\*([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /__([^\\s](?:.*[^\\s])?)__([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Mod-b\": toggleMark(markType),\n      \"Mod-B\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"strong\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"b\" },\n        { tag: \"strong\" },\n        {\n          getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/u.test(value) && null,\n          style: \"font-weight\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"strong\"];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"strong\" {\n    return \"strong\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Strong,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","import type { Break } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { chainCommands, exitCode } from \"prosemirror-commands\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BreakExtension extends NodeExtension<Break> {\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const command = chainCommands(exitCode, (state, dispatch) => {\n      if (dispatch) {\n        dispatch(\n          state.tr\n            .replaceSelectionWith(\n              proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(),\n            )\n            .scrollIntoView(),\n        );\n      }\n      return true;\n    });\n\n    const isMac =\n      typeof navigator !== \"undefined\"\n        ? /Mac|iP(hone|[oa]d)/u.test(navigator.platform) // eslint-disable-line @typescript-eslint/no-deprecated -- In the tested systems, it will be defined\n        : false;\n\n    return {\n      \"Mod-Enter\": command,\n      \"Shift-Enter\": command,\n      ...(isMac && { \"Ctrl-Enter\": command }),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"hard_break\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"inline\",\n      inline: true,\n      parseDOM: [{ tag: \"br\" }],\n      selectable: false,\n      toDOM(): DOMOutputSpec {\n        return [\"br\"];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<Break> {\n    return [{ type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"break\" {\n    return \"break\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Break,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"Selection\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.Selection) });","import type { Text } from \"mdast\";\nimport type {\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class TextExtension extends NodeExtension<Text> {\n  public override proseMirrorNodeName(): string {\n    return \"text\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"inline\",\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n  ): Array<Text> {\n    return [{ type: this.unistNodeName(), value: node.text ?? \"\" }];\n  }\n\n  public override unistNodeName(): \"text\" {\n    return \"text\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Text,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return [proseMirrorSchema.text(node.value)];\n  }\n}\n","import type { Code, Text } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { setBlockType } from \"prosemirror-commands\";\nimport { type InputRule, textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  type Command,\n  type EditorState,\n  Selection,\n  type Transaction,\n} from \"prosemirror-state\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { TextExtension } from \"./TextExtension\";\n\n/**\n * @public\n */\nexport class CodeBlockExtension extends NodeExtension<Code> {\n  private static liftOutOfCodeBlock() {\n    return (\n      state: EditorState,\n      dispatch?: (tr: Transaction) => void,\n    ): boolean => {\n      const { $from, $to } = state.selection;\n      if (\n        // Mustn't be a complex selection\n        !$from.sameParent($to) ||\n        // Must be in a code block\n        $from.parent.type.name !== \"code_block\" ||\n        // Must be at the end of the code block\n        $from.parentOffset !== $from.parent.content.size ||\n        // There must already be a preceding empty line\n        !$from.parent.textBetween(0, $from.parentOffset).endsWith(\"\\n\\n\")\n      ) {\n        return false;\n      }\n      if (dispatch) {\n        const tr = state.tr;\n        dispatch(\n          tr\n            // Delete the preceding empty line\n            .deleteRange($from.pos - 2, $from.pos)\n            // Insert empty paragraph\n            .insert(\n              $from.pos - 1,\n              tr.doc.type.schema.nodes[\"paragraph\"].create(),\n            )\n            // Put the cursor into the empty paragraph\n            .setSelection(Selection.near(tr.doc.resolve($from.pos), 1))\n            .scrollIntoView(),\n        );\n      }\n      return true;\n    };\n  }\n\n  public override dependencies(): Array<Extension> {\n    return [new TextExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      textblockTypeInputRule(\n        /^\\s{0,3}```$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n      textblockTypeInputRule(\n        /^\\s{4}$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      Enter: CodeBlockExtension.liftOutOfCodeBlock(),\n      \"Shift-Mod-\\\\\": setBlockType(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"code_block\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      code: true,\n      content: \"text*\",\n      defining: true,\n      group: \"block\",\n      marks: \"\",\n      parseDOM: [{ preserveWhitespace: \"full\", tag: \"pre\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"pre\", [\"code\", 0]];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<Text>,\n  ): Array<Code> {\n    return [\n      {\n        type: this.unistNodeName(),\n        value: convertedChildren.map((child) => child.value).join(\"\"),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"code\" {\n    return \"code\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Code,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      [proseMirrorSchema.text(node.value)],\n    );\n  }\n}\n","import type { Definition } from \"mdast\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport interface DefinitionExtensionContext {\n  definitions: Record<\n    string,\n    { title: string | null | undefined; url: string }\n  >;\n}\n\n/**\n * @public\n */\nexport class DefinitionExtension extends NodeExtension<Definition> {\n  public override proseMirrorNodeName(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeSpec(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<Definition> {\n    return [];\n  }\n\n  public override unistNodeName(): \"definition\" {\n    return \"definition\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Definition,\n    _proseMirrorSchema: Schema<string, string>,\n    _convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    if (context.DefinitionExtension === undefined) {\n      context.DefinitionExtension = { definitions: {} };\n    }\n    context.DefinitionExtension.definitions[node.identifier] = {\n      title: node.title,\n      url: node.url,\n    };\n    return [];\n  }\n}\n","import type { Paragraph, PhrasingContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ParagraphExtension extends NodeExtension<Paragraph> {\n  public override proseMirrorNodeName(): string {\n    return \"paragraph\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{ tag: \"p\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"p\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<PhrasingContent>,\n  ): Array<Paragraph> {\n    return [{ children: convertedChildren, type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"paragraph\" {\n    return \"paragraph\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Paragraph,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Heading, PhrasingContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command, EditorState } from \"prosemirror-state\";\nimport type { EditorView } from \"prosemirror-view\";\n\nimport { setBlockType } from \"prosemirror-commands\";\nimport { type InputRule, textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ParagraphExtension } from \"./ParagraphExtension\";\nimport { TextExtension } from \"./TextExtension\";\n\n/**\n * @public\n */\nexport class HeadingExtension extends NodeExtension<Heading> {\n  private static headingLevelCommandBuilder(\n    proseMirrorSchema: Schema<string, string>,\n    levelUpdate: -1 | 1,\n    onlyAtStart: boolean,\n  ): Command {\n    return (state, dispatch, view) => {\n      if (onlyAtStart && !HeadingExtension.isAtStart(state, view)) {\n        return false;\n      }\n\n      const { $anchor } = state.selection;\n      const headingNode = $anchor.parent;\n      if (headingNode.type.name !== \"heading\") {\n        return false;\n      }\n\n      const newHeadingLevel =\n        (headingNode.attrs[\"level\"] as number) + levelUpdate;\n\n      if (newHeadingLevel < 0 || newHeadingLevel > 6) {\n        return false;\n      }\n      if (dispatch === undefined) {\n        return true;\n      }\n\n      const headingPosition = $anchor.before($anchor.depth);\n\n      if (newHeadingLevel > 0) {\n        dispatch(\n          state.tr.setNodeMarkup(headingPosition, undefined, {\n            level: newHeadingLevel,\n          }),\n        );\n      } else {\n        dispatch(\n          state.tr.setNodeMarkup(\n            headingPosition,\n            proseMirrorSchema.nodes[\"paragraph\"],\n          ),\n        );\n      }\n      return true;\n    };\n  }\n\n  private static isAtStart(\n    state: EditorState,\n    view: EditorView | undefined,\n  ): boolean {\n    if (!state.selection.empty) {\n      return false;\n    }\n    if (view !== undefined) {\n      return view.endOfTextblock(\"backward\", state);\n    }\n    return state.selection.$anchor.parentOffset > 0;\n  }\n\n  public override dependencies(): Array<Extension> {\n    return [new ParagraphExtension(), new TextExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      textblockTypeInputRule(\n        /^\\s{0,3}(#{1,6})\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        (match) => ({ level: match[1].length }),\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const keymap: Record<string, Command> = {\n      // eslint-disable-next-line @typescript-eslint/naming-convention -- This is a key\n      \"#\": HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        +1,\n        true,\n      ),\n      Backspace: HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        -1,\n        true,\n      ),\n      \"Shift-Tab\": HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        -1,\n        false,\n      ),\n      Tab: HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        +1,\n        false,\n      ),\n    };\n\n    for (let i = 1; i <= 6; i++) {\n      keymap[`Shift-Mod-${i.toString()}`] = setBlockType(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        { level: i },\n      );\n    }\n    return keymap;\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"heading\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { level: { default: 1 } },\n      content: \"text*\",\n      defining: true,\n      group: \"block\",\n      parseDOM: [\n        { attrs: { level: 1 }, tag: \"h1\" },\n        { attrs: { level: 2 }, tag: \"h2\" },\n        { attrs: { level: 3 }, tag: \"h3\" },\n        { attrs: { level: 4 }, tag: \"h4\" },\n        { attrs: { level: 5 }, tag: \"h5\" },\n        { attrs: { level: 6 }, tag: \"h6\" },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [`h${(node.attrs[\"level\"] as number).toString()}`, 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<PhrasingContent>,\n  ): Array<Heading> {\n    return [\n      {\n        children: convertedChildren,\n        depth: node.attrs[\"level\"] as 1 | 2 | 3 | 4 | 5 | 6,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"heading\" {\n    return \"heading\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Heading,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        level: node.depth,\n      },\n    );\n  }\n}\n","import type { ThematicBreak } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class HorizontalRuleExtension extends NodeExtension<ThematicBreak> {\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new InputRule(/^\\s{0,3}(?:\\*\\*\\*|---|___)\\n$/u, (state, _, start, end) =>\n        state.tr.replaceWith(\n          start,\n          end,\n          createProseMirrorNode(\n            this.proseMirrorNodeName(),\n            proseMirrorSchema,\n            [],\n          ),\n        ),\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Mod-_\": (state, dispatch): true => {\n        if (dispatch) {\n          dispatch(\n            state.tr\n              .replaceSelectionWith(\n                proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(),\n              )\n              .scrollIntoView(),\n          );\n        }\n        return true;\n      },\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"horizontal_rule\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"block\",\n      parseDOM: [{ tag: \"hr\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"div\", [\"hr\"]];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<ThematicBreak> {\n    return [\n      {\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"thematicBreak\" {\n    return \"thematicBreak\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: ThematicBreak,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Image } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ParagraphExtension } from \"./ParagraphExtension\";\n\n/**\n * @public\n */\nexport class ImageExtension extends NodeExtension<Image> {\n  public override dependencies(): Array<Extension> {\n    return [new ParagraphExtension()];\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"image\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: {\n        alt: { default: null },\n        src: {},\n        title: { default: null },\n      },\n      draggable: true,\n      group: \"inline\",\n      inline: true,\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): {\n            alt: string | null;\n            src: string | null;\n            title: string | null;\n          } {\n            return {\n              alt: (dom as HTMLElement).getAttribute(\"alt\"),\n              src: (dom as HTMLElement).getAttribute(\"src\"),\n              title: (dom as HTMLElement).getAttribute(\"title\"),\n            };\n          },\n          tag: \"img[src]\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\"img\", node.attrs];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n  ): Array<Image> {\n    return [\n      {\n        type: this.unistNodeName(),\n        url: node.attrs[\"src\"] as string,\n        ...(node.attrs[\"alt\"] !== null && { alt: node.attrs[\"alt\"] as string }),\n        ...(node.attrs[\"title\"] !== null && {\n          title: node.attrs[\"title\"] as string,\n        }),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"image\" {\n    return \"image\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Image,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        alt: node.alt,\n        src: node.url,\n        title: node.title,\n      },\n    );\n  }\n}\n","import type { ImageReference } from \"mdast\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { type Extension, NodeExtension } from \"prosemirror-unified\";\n\nimport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./DefinitionExtension\";\nimport { ImageExtension } from \"./ImageExtension\";\n\n/**\n * @public\n */\nexport interface ImageReferenceExtensionContext {\n  proseMirrorNodes: Record<string, ProseMirrorNode>;\n}\n\n/**\n * @public\n */\nexport class ImageReferenceExtension extends NodeExtension<ImageReference> {\n  public override dependencies(): Array<Extension> {\n    return [new DefinitionExtension(), new ImageExtension()];\n  }\n\n  public override postUnistToProseMirrorHook(\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n      ImageReferenceExtension: ImageReferenceExtensionContext;\n    }>,\n  ): void {\n    if (\n      context.ImageReferenceExtension === undefined ||\n      context.DefinitionExtension === undefined\n    ) {\n      return;\n    }\n    for (const id in context.ImageReferenceExtension.proseMirrorNodes) {\n      if (!(id in context.DefinitionExtension.definitions)) {\n        continue;\n      }\n      const definition = context.DefinitionExtension.definitions[id];\n      const attrs = context.ImageReferenceExtension.proseMirrorNodes[id]\n        .attrs as Record<\n        string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Attrs can be any\n        any\n      >;\n      attrs[\"src\"] = definition.url;\n      if (definition.title !== undefined) {\n        attrs[\"title\"] = definition.title;\n      }\n    }\n  }\n\n  public override proseMirrorNodeName(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeSpec(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<ImageReference> {\n    return [];\n  }\n\n  public override unistNodeName(): \"imageReference\" {\n    return \"imageReference\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: ImageReference,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      ImageReferenceExtension: ImageReferenceExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    const proseMirrorNode = proseMirrorSchema.nodes[\"image\"].createAndFill(\n      { alt: node.alt, src: \"\", title: node.label },\n      convertedChildren,\n    );\n    if (proseMirrorNode === null) {\n      return [];\n    }\n    if (context.ImageReferenceExtension === undefined) {\n      context.ImageReferenceExtension = { proseMirrorNodes: {} };\n    }\n    context.ImageReferenceExtension.proseMirrorNodes[node.identifier] =\n      proseMirrorNode;\n    return [proseMirrorNode];\n  }\n}\n","import type { InlineCode, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class InlineCodeExtension extends MarkExtension<InlineCode> {\n  public override processConvertedUnistNode(convertedNode: Text): InlineCode {\n    return { type: this.unistNodeName(), value: convertedNode.value };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /`([^\\s](?:.*[^\\s])?)`([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Ctrl-`\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"code\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      inclusive: false,\n      parseDOM: [{ tag: \"code\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"code\"];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"inlineCode\" {\n    return \"inlineCode\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: InlineCode,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return [\n      proseMirrorSchema\n        .text(node.value)\n        .mark([proseMirrorSchema.marks[this.proseMirrorMarkName()].create()]),\n    ];\n  }\n}\n","import type { Emphasis, Strong, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ItalicExtension extends MarkExtension<Emphasis> {\n  public override processConvertedUnistNode(\n    convertedNode: Strong | Text,\n  ): Emphasis {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /(?<!\\*)\\*([^\\s*](?:.*[^\\s])?)\\*([^*])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /(?<!_)_([^\\s_](?:.*[^\\s])?)_([^_])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Mod-i\": toggleMark(markType),\n      \"Mod-I\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"em\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"i\" },\n        { tag: \"em\" },\n        {\n          getAttrs: (value) => value === \"italic\" && null,\n          style: \"font-style\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"em\"];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"emphasis\" {\n    return \"emphasis\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Emphasis,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","import type { Link, Text } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  Mark,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { MarkExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class LinkExtension extends MarkExtension<Link> {\n  public override processConvertedUnistNode(\n    convertedNode: Text,\n    originalMark: Mark,\n  ): Link {\n    return {\n      type: this.unistNodeName(),\n      url: originalMark.attrs[\"href\"] as string,\n      ...(originalMark.attrs[\"title\"] !== null && {\n        title: originalMark.attrs[\"title\"] as string,\n      }),\n      children: [convertedNode],\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"link\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      attrs: { href: {}, title: { default: null } },\n      inclusive: false,\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): {\n            href: string | null;\n            title: string | null;\n          } {\n            return {\n              href: (dom as HTMLElement).getAttribute(\"href\"),\n              title: (dom as HTMLElement).getAttribute(\"title\"),\n            };\n          },\n          tag: \"a[href]\",\n        },\n      ],\n      toDOM(node: Mark): DOMOutputSpec {\n        return [\"a\", node.attrs];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"link\" {\n    return \"link\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Link,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create({\n            href: node.url,\n            title: node.title,\n          }),\n        ]),\n      ),\n    );\n  }\n}\n","import type { LinkReference } from \"mdast\";\nimport type { Mark, Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { type Extension, MarkExtension } from \"prosemirror-unified\";\n\nimport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./DefinitionExtension\";\nimport { LinkExtension } from \"./LinkExtension\";\n\n/**\n * @public\n */\nexport interface LinkReferenceExtensionContext {\n  marks: Record<string, Mark>;\n}\n\n/**\n * @public\n */\nexport class LinkReferenceExtension extends MarkExtension<LinkReference> {\n  public override dependencies(): Array<Extension> {\n    return [new DefinitionExtension(), new LinkExtension()];\n  }\n\n  public override postUnistToProseMirrorHook(\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n      LinkReferenceExtension: LinkReferenceExtensionContext;\n    }>,\n  ): void {\n    if (\n      context.LinkReferenceExtension === undefined ||\n      context.DefinitionExtension === undefined\n    ) {\n      return;\n    }\n    for (const id in context.LinkReferenceExtension.marks) {\n      if (!(id in context.DefinitionExtension.definitions)) {\n        continue;\n      }\n      const definition = context.DefinitionExtension.definitions[id];\n      const attrs = context.LinkReferenceExtension.marks[id].attrs as Record<\n        string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Attrs can be any\n        any\n      >;\n      attrs[\"href\"] = definition.url;\n      if (definition.title !== undefined) {\n        attrs[\"title\"] = definition.title;\n      }\n    }\n  }\n\n  public override processConvertedUnistNode(\n    convertedNode: LinkReference,\n  ): LinkReference {\n    return convertedNode;\n  }\n\n  public override proseMirrorMarkName(): null {\n    return null;\n  }\n\n  public override proseMirrorMarkSpec(): null {\n    return null;\n  }\n\n  public override unistNodeName(): \"linkReference\" {\n    return \"linkReference\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: LinkReference,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      LinkReferenceExtension: LinkReferenceExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    const mark = proseMirrorSchema.marks[\"link\"].create({\n      href: null,\n      title: null,\n    });\n    if (context.LinkReferenceExtension === undefined) {\n      context.LinkReferenceExtension = { marks: {} };\n    }\n    context.LinkReferenceExtension.marks[node.identifier] = mark;\n    return convertedChildren.map((child) =>\n      child.mark(child.marks.concat([mark])),\n    );\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"liftListItem\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.liftListItem), [\"sinkListItem\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.sinkListItem), [\"splitListItem\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.splitListItem), [\"wrapInList\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.wrapInList) });","import type { BlockContent, DefinitionContent, ListItem } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  liftListItem,\n  sinkListItem,\n  splitListItem,\n} from \"prosemirror-schema-list\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ListItemExtension extends NodeExtension<ListItem> {\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const nodeType = proseMirrorSchema.nodes[this.proseMirrorNodeName()];\n    return {\n      Enter: splitListItem(nodeType),\n      \"Shift-Tab\": liftListItem(nodeType),\n      Tab: sinkListItem(nodeType),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"regular_list_item\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"paragraph block*\",\n      defining: true,\n      group: \"list_item\",\n      parseDOM: [{ tag: \"li\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"li\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<ListItem> {\n    return [\n      {\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"listItem\" {\n    return \"listItem\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: ListItem,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() &&\n      (!(\"checked\" in node) || typeof node.checked !== \"boolean\")\n    );\n  }\n}\n","import type { List, ListContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { wrapInList } from \"prosemirror-schema-list\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ListItemExtension } from \"./ListItemExtension\";\n\n/**\n * @public\n */\nexport class OrderedListExtension extends NodeExtension<List> {\n  public override dependencies(): Array<Extension> {\n    return [new ListItemExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}(\\d+)\\.\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        (match) => ({ start: +match[1] }),\n        (match, node) =>\n          node.childCount + (node.attrs[\"start\"] as number) === +match[1],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Shift-Mod-9\": wrapInList(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"ordered_list\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { spread: { default: false }, start: { default: 1 } },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): { spread: boolean; start: number } {\n            const start = (dom as HTMLElement).getAttribute(\"start\");\n            return {\n              spread:\n                (dom as HTMLElement).getAttribute(\"data-spread\") === \"true\",\n              start: start !== null ? parseInt(start, 10) : 1,\n            };\n          },\n          tag: \"ol\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\n          \"ol\",\n          {\n            \"data-spread\": node.attrs[\"spread\"] as boolean,\n            start: node.attrs[\"start\"] as number,\n          },\n          0,\n        ];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<ListContent>,\n  ): Array<List> {\n    const spread = node.attrs[\"spread\"] as boolean;\n    return [\n      {\n        children: convertedChildren.map((child) => {\n          child.spread = spread;\n          return child;\n        }),\n        ordered: true,\n        spread,\n        start: node.attrs[\"start\"] as number,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"list\" {\n    return \"list\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: List,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        spread: node.spread,\n        start: node.start ?? 1,\n      },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() && (node as List).ordered === true\n    );\n  }\n}\n","import type { Root, RootContent } from \"mdast\";\nimport type {\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class RootExtension extends NodeExtension<Root> {\n  public override proseMirrorNodeName(): string {\n    return \"doc\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return { content: \"block+\" };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<RootContent>,\n  ): Array<Root> {\n    return [{ children: convertedChildren, type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"root\" {\n    return \"root\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Root,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { List, ListContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { wrapInList } from \"prosemirror-schema-list\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ListItemExtension } from \"./ListItemExtension\";\n\n/**\n * @public\n */\nexport class UnorderedListExtension extends NodeExtension<List> {\n  public override dependencies(): Array<Extension> {\n    return [new ListItemExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}([-+*])\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Shift-Mod-8\": wrapInList(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"bullet_list\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { spread: { default: false } },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): { spread: boolean } {\n            return {\n              spread:\n                (dom as HTMLElement).getAttribute(\"data-spread\") === \"true\",\n            };\n          },\n          tag: \"ul\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\"ul\", { \"data-spread\": node.attrs[\"spread\"] as boolean }, 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<ListContent>,\n  ): Array<List> {\n    const spread = node.attrs[\"spread\"] as boolean;\n    return [\n      {\n        children: convertedChildren.map((child) => {\n          child.spread = spread;\n          return child;\n        }),\n        ordered: false,\n        spread,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"list\" {\n    return \"list\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: List,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        spread: node.spread,\n      },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() && (node as List).ordered !== true\n    );\n  }\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { Extension } from \"prosemirror-unified\";\nimport remarkParse from \"remark-parse\";\nimport remarkStringify from \"remark-stringify\";\n\nimport { BlockquoteExtension } from \"./syntax-extensions/BlockquoteExtension\";\nimport { BoldExtension } from \"./syntax-extensions/BoldExtension\";\nimport { BreakExtension } from \"./syntax-extensions/BreakExtension\";\nimport { CodeBlockExtension } from \"./syntax-extensions/CodeBlockExtension\";\nimport { DefinitionExtension } from \"./syntax-extensions/DefinitionExtension\";\nimport { HeadingExtension } from \"./syntax-extensions/HeadingExtension\";\nimport { HorizontalRuleExtension } from \"./syntax-extensions/HorizontalRuleExtension\";\nimport { ImageExtension } from \"./syntax-extensions/ImageExtension\";\nimport { ImageReferenceExtension } from \"./syntax-extensions/ImageReferenceExtension\";\nimport { InlineCodeExtension } from \"./syntax-extensions/InlineCodeExtension\";\nimport { ItalicExtension } from \"./syntax-extensions/ItalicExtension\";\nimport { LinkExtension } from \"./syntax-extensions/LinkExtension\";\nimport { LinkReferenceExtension } from \"./syntax-extensions/LinkReferenceExtension\";\nimport { ListItemExtension } from \"./syntax-extensions/ListItemExtension\";\nimport { OrderedListExtension } from \"./syntax-extensions/OrderedListExtension\";\nimport { ParagraphExtension } from \"./syntax-extensions/ParagraphExtension\";\nimport { RootExtension } from \"./syntax-extensions/RootExtension\";\nimport { TextExtension } from \"./syntax-extensions/TextExtension\";\nimport { UnorderedListExtension } from \"./syntax-extensions/UnorderedListExtension\";\n\n/**\n * @public\n */\nexport class MarkdownExtension extends Extension {\n  public override dependencies(): Array<Extension> {\n    return [\n      // ParagraphExtension needs to be first so that it is the default block.\n      new ParagraphExtension(),\n      new BlockquoteExtension(),\n      new BoldExtension(),\n      new BreakExtension(),\n      new CodeBlockExtension(),\n      new DefinitionExtension(),\n      new HeadingExtension(),\n      new HorizontalRuleExtension(),\n      new ImageExtension(),\n      new ImageReferenceExtension(),\n      new InlineCodeExtension(),\n      new ItalicExtension(),\n      new LinkExtension(),\n      new LinkReferenceExtension(),\n      new ListItemExtension(),\n      new OrderedListExtension(),\n      new RootExtension(),\n      new TextExtension(),\n      new UnorderedListExtension(),\n    ];\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(remarkParse).use(remarkStringify, {\n      fences: true,\n      listItemIndent: \"one\",\n      resourceLink: true,\n      rule: \"-\",\n    }) as unknown as Processor<\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      string\n    >;\n  }\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodes parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodes children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isnt a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`)  whole match\n *   * `...capture` (`Array<string>`)  matches from regex capture groups\n *   * `match` (`RegExpMatchObject`)  info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * or when `false`, do not replace at all\n *   * or when `string`, replace with a text node of that value\n *   * or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasnt a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n","/**\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\nimport {ccount} from 'ccount'\nimport {ok as assert} from 'devlop'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '@',\n        before: '[+\\\\-.\\\\w]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: '.',\n        before: '[Ww]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: ':',\n        before: '[ps]',\n        after: '\\\\/',\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'link')\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Array<PhrasingContent> | Link | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    // If its an email, the previous character should not be a slash.\n    (!email || code !== 47)\n  )\n}\n","/**\n * @import {Code, ConstructRecord, Event, Extension, Previous, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nconst wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n};\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nconst trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n};\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n};\nconst wwwAutolink = {\n  name: 'wwwAutolink',\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nconst protocolAutolink = {\n  name: 'protocolAutolink',\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n};\nconst emailAutolink = {\n  name: 'emailAutolink',\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n\n/** @type {ConstructRecord} */\nconst text = {};\n\n/**\n * Create an extension for `micromark` to support GitHub autolink literal\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   autolink literal syntax.\n */\nexport function gfmAutolinkLiteral() {\n  return {\n    text\n  };\n}\n\n/** @type {Code} */\nlet code = 48;\n\n// Add alphanumerics.\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, protocolAutolink];\ntext[104] = [emailAutolink, protocolAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink];\n\n// To do: perform email autolink literals on events, afterwards.\n// Thats where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this;\n  /** @type {boolean | undefined} */\n  let dot;\n  /** @type {boolean} */\n  let data;\n  return start;\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n    if (code === 64) {\n      effects.consume(code);\n      return emailDomain;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === 46) {\n      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {\n      data = true;\n      effects.consume(code);\n      return emailDomain;\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally wed truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isnt trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code);\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code);\n    dot = true;\n    return emailDomain;\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this;\n  return wwwStart;\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (code !== 87 && code !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww');\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this;\n  let buffer = '';\n  let seen = false;\n  return protocolStart;\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if ((code === 72 || code === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n      effects.enter('literalAutolink');\n      effects.enter('literalAutolinkHttp');\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    if (code === 58) {\n      const protocol = buffer.toLowerCase();\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code);\n        return protocolSlashesInside;\n      }\n    }\n    return nok(code);\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === 47) {\n      effects.consume(code);\n      if (seen) {\n        return afterProtocol;\n      }\n      seen = true;\n      return protocolSlashesInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === null || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0;\n  return wwwPrefixInside;\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === 87 || code === 119) && size < 3) {\n      size++;\n      effects.consume(code);\n      return wwwPrefixInside;\n    }\n    if (code === 46 && size === 3) {\n      effects.consume(code);\n      return wwwPrefixAfter;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === null ? nok(code) : ok(code);\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment;\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment;\n  /** @type {boolean | undefined} */\n  let seen;\n  return domainInside;\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === 46 || code === 95) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code);\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {\n      return domainAfter(code);\n    }\n    seen = true;\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === 95) {\n      underscoreInLastSegment = true;\n    }\n    // Otherwise, its a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment;\n      underscoreInLastSegment = undefined;\n    }\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: thats GH says a dot is needed, but its not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code);\n    }\n    return ok(code);\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0;\n  let sizeClose = 0;\n  return pathInside;\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === 40) {\n      sizeOpen++;\n      effects.consume(code);\n      return pathInside;\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we dont check for a trail.\n    if (code === 41 && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code);\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {\n      return effects.check(trail, ok, pathAtPunctuation)(code);\n    }\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === 41) {\n      sizeClose++;\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail;\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {\n      effects.consume(code);\n      return trail;\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === 38) {\n      effects.consume(code);\n      return trailCharacterReferenceStart;\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === 93) {\n      effects.consume(code);\n      return trailBracketAfter;\n    }\n    if (\n    // `<` is an end.\n    code === 60 ||\n    // So is whitespace.\n    code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * >  **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (code === null || code === 40 || code === 91 || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return trail(code);\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceStart(code) {\n    // When non-alpha, its not a trail.\n    return asciiAlpha(code) ? trailCharacterReferenceInside(code) : nok(code);\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === 59) {\n      effects.consume(code);\n      return trail;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return trailCharacterReferenceInside;\n    }\n\n    // Its not a trail.\n    return nok(code);\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start;\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code);\n    return after;\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code);\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || markdownLineEndingOrSpace(code);\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code);\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash inside atext.\n  // The reference code is a bit weird, but thats what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === 47 || gfmAtext(code));\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n  while (index--) {\n    const token = events[index][1];\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    }\n\n    // If weve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n  if (events.length > 0 && !result) {\n    // Mark the last token as walked into w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n  return result;\n}","import type { Extension as FromMarkdownExtension } from \"mdast-util-from-markdown\";\nimport type { Options as ToMarkdownExtension } from \"mdast-util-to-markdown\";\nimport type { Extension as MicromarkExtension } from \"micromark-util-types\";\nimport type { Processor } from \"unified\";\n\nexport function buildUnifiedExtension(\n  micromarkExtensions: Array<MicromarkExtension>,\n  fromMarkdownExtensions: Array<FromMarkdownExtension>,\n  toMarkdownExtensions: Array<ToMarkdownExtension>,\n): () => void {\n  return function (this: Processor) {\n    // eslint-disable-next-line no-invalid-this -- this provided by unified\n    const data = this.data();\n\n    data.micromarkExtensions ??= [];\n    data.fromMarkdownExtensions ??= [];\n    data.toMarkdownExtensions ??= [];\n\n    data.micromarkExtensions.push(...micromarkExtensions);\n    data.fromMarkdownExtensions.push(...fromMarkdownExtensions);\n    data.toMarkdownExtensions.push(...toMarkdownExtensions);\n  };\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown,\n} from \"mdast-util-gfm-autolink-literal\";\nimport { gfmAutolinkLiteral } from \"micromark-extension-gfm-autolink-literal\";\nimport { Extension } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\n/**\n * @public\n */\nexport class ExtendedAutolinkExtension extends Extension {\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmAutolinkLiteral()],\n        [gfmAutolinkLiteralFromMarkdown()],\n        [gfmAutolinkLiteralToMarkdown()],\n      ),\n    );\n  }\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: ['delete'],\n    enter: {strikethrough: enterStrikethrough},\n    exit: {strikethrough: exitStrikethrough}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '~',\n        inConstruct: 'phrasing',\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: {delete: handleDelete}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  const exit = state.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {undefined}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if theres only a couple (10k) items.\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, its fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, its fine.\n      list.splice(...parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * >  **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {Array<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @import {Options} from 'micromark-extension-gfm-strikethrough'\n * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {};\n  let single = options_.singleTilde;\n  const tokenizer = {\n    name: 'strikethrough',\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  };\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1;\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index;\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&\n          // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            };\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];\n            const insideSpan = context.parser.constructs.insideSpan.null;\n            if (insideSpan) {\n              // Between.\n              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan, events.slice(open + 1, index), context));\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = \"data\";\n      }\n    }\n    return events;\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      if (previous === 126 && events[events.length - 1][1].type !== \"characterEscape\") {\n        return nok(code);\n      }\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous);\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = classifyCharacter(code);\n      token._open = !after || after === 2 && Boolean(before);\n      token._close = !before || before === 2 && Boolean(after);\n      return ok(code);\n    }\n  }\n}","import type { Delete, Emphasis, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown,\n} from \"mdast-util-gfm-strikethrough\";\nimport { gfmStrikethrough } from \"micromark-extension-gfm-strikethrough\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\n/**\n * @public\n */\nexport class StrikethroughExtension extends MarkExtension<Delete> {\n  public override processConvertedUnistNode(\n    convertedNode: Emphasis | Text,\n  ): Delete {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /~([^\\s](?:.*[^\\s~])?)~([^~])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /~~([^\\s](?:.*[^\\s])?)~~([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"strikethrough\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"s\" },\n        { tag: \"del\" },\n        {\n          getAttrs: (value) =>\n            /(^|[\\s])line-through([\\s]|$)/u.test(value) && null,\n          style: \"text-decoration\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"s\"];\n      },\n    };\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmStrikethrough()],\n        [gfmStrikethroughFromMarkdown()],\n        [gfmStrikethroughToMarkdown()],\n      ),\n    );\n  }\n\n  public override unistNodeName(): \"delete\" {\n    return \"delete\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Delete,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('../types.js').ConstructName} ConstructName\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we cant put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If theres no info\n      !node.lang &&\n      // And theres a non-whitespace character\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnt start or end in a blank\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If theres no url, or\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot form depending on the\n// previous or next character of sequences.\n// Theres no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when its released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').State} State\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Exit} Exit\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If theres an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If theres a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * >  **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return fn.call(state, node, info)\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot form depending on the\n// previous or next character of sequences.\n// Theres no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `` represents a tab (plus how much it expands) and `` represents a\n * single space.\n *\n * ```markdown\n * \n * \n * \n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nconst tasklistCheck = {\n  name: 'tasklistCheck',\n  tokenize: tokenizeTasklistCheck\n};\n\n/**\n * Create an HTML extension for `micromark` to support GFM task list items\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM task list items when serializing to HTML.\n */\nexport function gfmTaskListItem() {\n  return {\n    text: {\n      [91]: tasklistCheck\n    }\n  };\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this;\n  return open;\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n    // Exit if theres stuff before.\n    self.previous !== null ||\n    // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n    return nok(code);\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return after;\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code);\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok)(code);\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, \"whitespace\");\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means theres content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code);\n  }\n}","import type { BlockContent, DefinitionContent, ListItem } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command, EditorState } from \"prosemirror-state\";\nimport type {\n  EditorView,\n  NodeView,\n  NodeViewConstructor,\n} from \"prosemirror-view\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown,\n} from \"mdast-util-gfm-task-list-item\";\nimport { gfmTaskListItem } from \"micromark-extension-gfm-task-list-item\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\nclass TaskListItemView implements NodeView {\n  public readonly contentDOM: HTMLElement;\n  public readonly dom: HTMLElement;\n\n  public constructor(\n    node: ProseMirrorNode,\n    view: EditorView,\n    getPos: () => number | undefined,\n  ) {\n    const checkbox = document.createElement(\"input\");\n    checkbox.setAttribute(\"type\", \"checkbox\");\n    checkbox.setAttribute(\"style\", \"cursor: pointer;\");\n    if (node.attrs[\"checked\"] === true) {\n      checkbox.setAttribute(\"checked\", \"checked\");\n    }\n    checkbox.addEventListener(\"click\", (e) => {\n      const pos = getPos();\n      if (pos === undefined) {\n        return;\n      }\n      e.preventDefault();\n      view.dispatch(\n        view.state.tr.setNodeAttribute(\n          pos,\n          \"checked\",\n          !(node.attrs[\"checked\"] as boolean),\n        ),\n      );\n    });\n\n    const checkboxContainer = document.createElement(\"span\");\n    checkboxContainer.setAttribute(\"contenteditable\", \"false\");\n    checkboxContainer.setAttribute(\"style\", \"position: absolute; left: 5px;\");\n    checkboxContainer.appendChild(checkbox);\n\n    this.contentDOM = document.createElement(\"span\");\n    this.contentDOM.setAttribute(\"style\", \"position: relative; left: 30px;\");\n\n    this.dom = document.createElement(\"li\");\n    this.dom.setAttribute(\n      \"style\",\n      \"list-style-type: none; margin-left: -30px;\",\n    );\n    this.dom.appendChild(checkboxContainer);\n    this.dom.appendChild(this.contentDOM);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inherited from the NodeView interface\n  public stopEvent(): boolean {\n    return true;\n  }\n}\n\n/**\n * @public\n */\nexport class TaskListItemExtension extends NodeExtension<ListItem> {\n  private static isAtStart(\n    state: EditorState,\n    view: EditorView | undefined,\n  ): boolean {\n    if (!state.selection.empty) {\n      return false;\n    }\n    if (view !== undefined) {\n      return view.endOfTextblock(\"backward\", state);\n    }\n    return state.selection.$anchor.parentOffset > 0;\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new InputRule(/^\\[([x\\s]?)\\][\\s\\S]$/u, (state, match, start) => {\n        const wrappingNode = state.doc.resolve(start).node(-1);\n        if (wrappingNode.type.name !== \"regular_list_item\") {\n          return null;\n        }\n        return state.tr.replaceRangeWith(\n          start - 2,\n          start + wrappingNode.nodeSize,\n          proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(\n            { checked: match[1] === \"x\" },\n            wrappingNode.content.cut(3 + match[1].length),\n          ),\n        );\n      }),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      Backspace: (state, dispatch, view): boolean => {\n        if (!TaskListItemExtension.isAtStart(state, view)) {\n          return false;\n        }\n        const taskListItemNode = state.selection.$anchor.node(-1);\n        if (taskListItemNode.type.name !== \"task_list_item\") {\n          return false;\n        }\n        if (dispatch === undefined) {\n          return true;\n        }\n        dispatch(\n          state.tr.replaceRangeWith(\n            state.selection.$from.before() - 2,\n            state.selection.$from.before() + taskListItemNode.nodeSize,\n            proseMirrorSchema.nodes[\"regular_list_item\"].create(\n              {},\n              taskListItemNode.content,\n            ),\n          ),\n        );\n        return true;\n      },\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"task_list_item\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { checked: { default: false } },\n      content: \"paragraph block*\",\n      defining: true,\n      group: \"list_item\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): false | { checked: boolean } {\n            const checkbox = (dom as HTMLElement).firstChild;\n            if (!(checkbox instanceof HTMLInputElement)) {\n              return false;\n            }\n            return { checked: checkbox.checked };\n          },\n          tag: \"li\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\n          \"li\",\n          { style: \"list-style-type: none;, margin-left: -30px;\" },\n          [\n            \"span\",\n            {\n              contenteditable: \"false\",\n              style: \"position: absolute; left: 5px;\",\n            },\n            [\n              \"input\",\n              {\n                checked: (node.attrs[\"checked\"] as boolean)\n                  ? \"checked\"\n                  : undefined,\n                disabled: \"disabled\",\n                type: \"checkbox\",\n              },\n            ],\n          ],\n          [\"span\", { style: \"position: relative; left: 30px\" }, 0],\n        ];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<ListItem> {\n    return [\n      {\n        checked: node.attrs[\"checked\"] as boolean,\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override proseMirrorNodeView(): NodeViewConstructor | null {\n    return (node, view, getPos) => new TaskListItemView(node, view, getPos);\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmTaskListItem()],\n        [gfmTaskListItemFromMarkdown()],\n        [gfmTaskListItemToMarkdown()],\n      ),\n    );\n  }\n\n  public override unistNodeName(): \"listItem\" {\n    return \"listItem\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: ListItem,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      { checked: node.checked },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() &&\n      \"checked\" in node &&\n      typeof node.checked === \"boolean\"\n    );\n  }\n}\n","import { Extension } from \"prosemirror-unified\";\n\nimport { MarkdownExtension } from \"./MarkdownExtension\";\nimport { ExtendedAutolinkExtension } from \"./syntax-extensions/ExtendedAutolinkExtension\";\nimport { StrikethroughExtension } from \"./syntax-extensions/StrikethroughExtension\";\nimport { TaskListItemExtension } from \"./syntax-extensions/TaskListItemExtension\";\n\n/**\n * @public\n */\nexport class GFMExtension extends Extension {\n  public override dependencies(): Array<Extension> {\n    return [\n      new MarkdownExtension(),\n      new ExtendedAutolinkExtension(),\n      new StrikethroughExtension(),\n      new TaskListItemExtension(),\n    ];\n  }\n}\n","export { GFMExtension } from \"./GFMExtension\";\nexport { MarkdownExtension } from \"./MarkdownExtension\";\nexport { BlockquoteExtension } from \"./syntax-extensions/BlockquoteExtension\";\nexport { BoldExtension } from \"./syntax-extensions/BoldExtension\";\nexport { BreakExtension } from \"./syntax-extensions/BreakExtension\";\nexport { CodeBlockExtension } from \"./syntax-extensions/CodeBlockExtension\";\nexport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./syntax-extensions/DefinitionExtension\";\nexport { ExtendedAutolinkExtension } from \"./syntax-extensions/ExtendedAutolinkExtension\";\nexport { HeadingExtension } from \"./syntax-extensions/HeadingExtension\";\nexport { HorizontalRuleExtension } from \"./syntax-extensions/HorizontalRuleExtension\";\nexport { ImageExtension } from \"./syntax-extensions/ImageExtension\";\nexport {\n  ImageReferenceExtension,\n  type ImageReferenceExtensionContext,\n} from \"./syntax-extensions/ImageReferenceExtension\";\nexport { InlineCodeExtension } from \"./syntax-extensions/InlineCodeExtension\";\nexport { ItalicExtension } from \"./syntax-extensions/ItalicExtension\";\nexport { LinkExtension } from \"./syntax-extensions/LinkExtension\";\nexport {\n  LinkReferenceExtension,\n  type LinkReferenceExtensionContext,\n} from \"./syntax-extensions/LinkReferenceExtension\";\nexport { ListItemExtension } from \"./syntax-extensions/ListItemExtension\";\nexport { OrderedListExtension } from \"./syntax-extensions/OrderedListExtension\";\nexport { ParagraphExtension } from \"./syntax-extensions/ParagraphExtension\";\nexport { RootExtension } from \"./syntax-extensions/RootExtension\";\nexport { StrikethroughExtension } from \"./syntax-extensions/StrikethroughExtension\";\nexport { TaskListItemExtension } from \"./syntax-extensions/TaskListItemExtension\";\nexport { TextExtension } from \"./syntax-extensions/TextExtension\";\nexport { UnorderedListExtension } from \"./syntax-extensions/UnorderedListExtension\";\n"],"names":[],"sourceRoot":""}
\ No newline at end of file
+{"version":3,"file":"prosemirror-remark.cjs","sources":["../src/syntax-extensions/BlockquoteExtension.ts","../src/syntax-extensions/BoldExtension.ts","../src/syntax-extensions/BreakExtension.ts","../src/syntax-extensions/TextExtension.ts","../src/syntax-extensions/CodeBlockExtension.ts","../src/syntax-extensions/DefinitionExtension.ts","../src/syntax-extensions/ParagraphExtension.ts","../src/syntax-extensions/HeadingExtension.ts","../src/syntax-extensions/HorizontalRuleExtension.ts","../src/syntax-extensions/ImageExtension.ts","../src/syntax-extensions/ImageReferenceExtension.ts","../src/syntax-extensions/InlineCodeExtension.ts","../src/syntax-extensions/ItalicExtension.ts","../src/syntax-extensions/LinkExtension.ts","../src/syntax-extensions/LinkReferenceExtension.ts","../src/syntax-extensions/ListItemExtension.ts","../src/syntax-extensions/OrderedListExtension.ts","../src/syntax-extensions/RootExtension.ts","../src/syntax-extensions/UnorderedListExtension.ts","../src/MarkdownExtension.ts","../node_modules/ccount/index.js","../node_modules/devlop/lib/default.js","../node_modules/micromark-util-character/index.js","../node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/color.js","../node_modules/unist-util-visit-parents/lib/index.js","../node_modules/mdast-util-find-and-replace/lib/index.js","../node_modules/mdast-util-gfm-autolink-literal/lib/index.js","../node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","../src/utils/buildUnifiedExtension.ts","../src/syntax-extensions/ExtendedAutolinkExtension.ts","../node_modules/mdast-util-gfm-strikethrough/lib/index.js","../node_modules/micromark-util-chunked/index.js","../node_modules/micromark-util-classify-character/index.js","../node_modules/micromark-util-resolve-all/index.js","../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","../src/syntax-extensions/StrikethroughExtension.ts","../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/handle/break.js","../node_modules/longest-streak/index.js","../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../node_modules/mdast-util-to-markdown/lib/handle/code.js","../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js","../node_modules/mdast-util-to-markdown/lib/util/encode-info.js","../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../node_modules/unist-util-visit/lib/index.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../node_modules/mdast-util-to-markdown/lib/handle/html.js","../node_modules/mdast-util-to-markdown/lib/handle/image.js","../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../node_modules/mdast-util-to-markdown/lib/handle/link.js","../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../node_modules/mdast-util-to-markdown/lib/handle/list.js","../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../node_modules/mdast-util-phrasing/lib/index.js","../node_modules/mdast-util-to-markdown/lib/handle/root.js","../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../node_modules/mdast-util-to-markdown/lib/handle/text.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../node_modules/mdast-util-to-markdown/lib/handle/index.js","../node_modules/mdast-util-gfm-task-list-item/lib/index.js","../node_modules/micromark-factory-space/index.js","../node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","../src/syntax-extensions/TaskListItemExtension.ts","../src/GFMExtension.ts"],"sourcesContent":["import type { BlockContent, Blockquote, DefinitionContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { wrapIn } from \"prosemirror-commands\";\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BlockquoteExtension extends NodeExtension<Blockquote> {\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}>\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Mod->\": wrapIn(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"blockquote\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{ tag: \"blockquote\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"blockquote\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<Blockquote> {\n    return [\n      {\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"blockquote\" {\n    return \"blockquote\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Blockquote,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Emphasis, Strong, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BoldExtension extends MarkExtension<Strong> {\n  public override processConvertedUnistNode(\n    convertedNode: Emphasis | Text,\n  ): Strong {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /\\*\\*([^\\s](?:.*[^\\s])?)\\*\\*([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /__([^\\s](?:.*[^\\s])?)__([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Mod-b\": toggleMark(markType),\n      \"Mod-B\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"strong\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"b\" },\n        { tag: \"strong\" },\n        {\n          getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/u.test(value) && null,\n          style: \"font-weight\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"strong\", 0];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"strong\" {\n    return \"strong\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Strong,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","import type { Break } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { chainCommands, exitCode } from \"prosemirror-commands\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BreakExtension extends NodeExtension<Break> {\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const command = chainCommands(exitCode, (state, dispatch) => {\n      if (dispatch) {\n        dispatch(\n          state.tr\n            .replaceSelectionWith(\n              proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(),\n            )\n            .scrollIntoView(),\n        );\n      }\n      return true;\n    });\n\n    const isMac =\n      typeof navigator !== \"undefined\"\n        ? /Mac|iP(hone|[oa]d)/u.test(navigator.platform) // eslint-disable-line @typescript-eslint/no-deprecated -- In the tested systems, it will be defined\n        : false;\n\n    return {\n      \"Mod-Enter\": command,\n      \"Shift-Enter\": command,\n      ...(isMac && { \"Ctrl-Enter\": command }),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"hard_break\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"inline\",\n      inline: true,\n      parseDOM: [{ tag: \"br\" }],\n      selectable: false,\n      toDOM(): DOMOutputSpec {\n        return [\"br\"];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<Break> {\n    return [{ type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"break\" {\n    return \"break\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Break,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Text } from \"mdast\";\nimport type {\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class TextExtension extends NodeExtension<Text> {\n  public override proseMirrorNodeName(): string {\n    return \"text\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"inline\",\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n  ): Array<Text> {\n    return [{ type: this.unistNodeName(), value: node.text ?? \"\" }];\n  }\n\n  public override unistNodeName(): \"text\" {\n    return \"text\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Text,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return [proseMirrorSchema.text(node.value)];\n  }\n}\n","import type { Code, Text } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { setBlockType } from \"prosemirror-commands\";\nimport { type InputRule, textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  type Command,\n  type EditorState,\n  Selection,\n  type Transaction,\n} from \"prosemirror-state\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { TextExtension } from \"./TextExtension\";\n\n/**\n * @public\n */\nexport class CodeBlockExtension extends NodeExtension<Code> {\n  private static liftOutOfCodeBlock() {\n    return (\n      state: EditorState,\n      dispatch?: (tr: Transaction) => void,\n    ): boolean => {\n      const { $from, $to } = state.selection;\n      if (\n        // Mustn't be a complex selection\n        !$from.sameParent($to) ||\n        // Must be in a code block\n        $from.parent.type.name !== \"code_block\" ||\n        // Must be at the end of the code block\n        $from.parentOffset !== $from.parent.content.size ||\n        // There must already be a preceding empty line\n        !$from.parent.textBetween(0, $from.parentOffset).endsWith(\"\\n\\n\")\n      ) {\n        return false;\n      }\n      if (dispatch) {\n        const tr = state.tr;\n        dispatch(\n          tr\n            // Delete the preceding empty line\n            .deleteRange($from.pos - 2, $from.pos)\n            // Insert empty paragraph\n            .insert(\n              $from.pos - 1,\n              tr.doc.type.schema.nodes[\"paragraph\"].create(),\n            )\n            // Put the cursor into the empty paragraph\n            .setSelection(Selection.near(tr.doc.resolve($from.pos), 1))\n            .scrollIntoView(),\n        );\n      }\n      return true;\n    };\n  }\n\n  public override dependencies(): Array<Extension> {\n    return [new TextExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      textblockTypeInputRule(\n        /^\\s{0,3}```(?! )[^\\n`]*\\n$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n      textblockTypeInputRule(\n        /^\\s{4}$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      Enter: CodeBlockExtension.liftOutOfCodeBlock(),\n      \"Shift-Mod-\\\\\": setBlockType(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"code_block\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      code: true,\n      content: \"text*\",\n      defining: true,\n      group: \"block\",\n      marks: \"\",\n      parseDOM: [{ preserveWhitespace: \"full\", tag: \"pre\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"pre\", [\"code\", 0]];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<Text>,\n  ): Array<Code> {\n    return [\n      {\n        type: this.unistNodeName(),\n        value: convertedChildren.map((child) => child.value).join(\"\"),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"code\" {\n    return \"code\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Code,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      [proseMirrorSchema.text(node.value)],\n    );\n  }\n}\n","import type { Definition } from \"mdast\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport interface DefinitionExtensionContext {\n  definitions: Record<\n    string,\n    { title: string | null | undefined; url: string }\n  >;\n}\n\n/**\n * @public\n */\nexport class DefinitionExtension extends NodeExtension<Definition> {\n  public override proseMirrorNodeName(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeSpec(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<Definition> {\n    return [];\n  }\n\n  public override unistNodeName(): \"definition\" {\n    return \"definition\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Definition,\n    _proseMirrorSchema: Schema<string, string>,\n    _convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    if (context.DefinitionExtension === undefined) {\n      context.DefinitionExtension = { definitions: {} };\n    }\n    context.DefinitionExtension.definitions[node.identifier] = {\n      title: node.title,\n      url: node.url,\n    };\n    return [];\n  }\n}\n","import type { Paragraph, PhrasingContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ParagraphExtension extends NodeExtension<Paragraph> {\n  public override proseMirrorNodeName(): string {\n    return \"paragraph\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{ tag: \"p\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"p\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<PhrasingContent>,\n  ): Array<Paragraph> {\n    return [{ children: convertedChildren, type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"paragraph\" {\n    return \"paragraph\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Paragraph,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Heading, PhrasingContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command, EditorState } from \"prosemirror-state\";\nimport type { EditorView } from \"prosemirror-view\";\n\nimport { setBlockType } from \"prosemirror-commands\";\nimport { type InputRule, textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ParagraphExtension } from \"./ParagraphExtension\";\nimport { TextExtension } from \"./TextExtension\";\n\n/**\n * @public\n */\nexport class HeadingExtension extends NodeExtension<Heading> {\n  private static headingLevelCommandBuilder(\n    proseMirrorSchema: Schema<string, string>,\n    levelUpdate: -1 | 1,\n    onlyAtStart: boolean,\n  ): Command {\n    return (state, dispatch, view) => {\n      if (onlyAtStart && !HeadingExtension.isAtStart(state, view)) {\n        return false;\n      }\n\n      const { $anchor } = state.selection;\n      const headingNode = $anchor.parent;\n      if (headingNode.type.name !== \"heading\") {\n        return false;\n      }\n\n      const newHeadingLevel =\n        (headingNode.attrs[\"level\"] as number) + levelUpdate;\n\n      if (newHeadingLevel < 0 || newHeadingLevel > 6) {\n        return false;\n      }\n      if (dispatch === undefined) {\n        return true;\n      }\n\n      const headingPosition = $anchor.before($anchor.depth);\n\n      if (newHeadingLevel > 0) {\n        dispatch(\n          state.tr.setNodeMarkup(headingPosition, undefined, {\n            level: newHeadingLevel,\n          }),\n        );\n      } else {\n        dispatch(\n          state.tr.setNodeMarkup(\n            headingPosition,\n            proseMirrorSchema.nodes[\"paragraph\"],\n          ),\n        );\n      }\n      return true;\n    };\n  }\n\n  private static isAtStart(\n    state: EditorState,\n    view: EditorView | undefined,\n  ): boolean {\n    if (!state.selection.empty) {\n      return false;\n    }\n    if (view !== undefined) {\n      return view.endOfTextblock(\"backward\", state);\n    }\n    return state.selection.$anchor.parentOffset > 0;\n  }\n\n  public override dependencies(): Array<Extension> {\n    return [new ParagraphExtension(), new TextExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      textblockTypeInputRule(\n        /^\\s{0,3}(#{1,6})\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        (match) => ({ level: match[1].length }),\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const keymap: Record<string, Command> = {\n      \"#\": HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        +1,\n        true,\n      ),\n      Backspace: HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        -1,\n        true,\n      ),\n      \"Shift-Tab\": HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        -1,\n        false,\n      ),\n      Tab: HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        +1,\n        false,\n      ),\n    };\n\n    for (let i = 1; i <= 6; i++) {\n      keymap[`Shift-Mod-${i.toString()}`] = setBlockType(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        { level: i },\n      );\n    }\n    return keymap;\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"heading\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { level: { default: 1 } },\n      content: \"text*\",\n      defining: true,\n      group: \"block\",\n      parseDOM: [\n        { attrs: { level: 1 }, tag: \"h1\" },\n        { attrs: { level: 2 }, tag: \"h2\" },\n        { attrs: { level: 3 }, tag: \"h3\" },\n        { attrs: { level: 4 }, tag: \"h4\" },\n        { attrs: { level: 5 }, tag: \"h5\" },\n        { attrs: { level: 6 }, tag: \"h6\" },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [`h${(node.attrs[\"level\"] as number).toString()}`, 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<PhrasingContent>,\n  ): Array<Heading> {\n    return [\n      {\n        children: convertedChildren,\n        depth: node.attrs[\"level\"] as 1 | 2 | 3 | 4 | 5 | 6,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"heading\" {\n    return \"heading\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Heading,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        level: node.depth,\n      },\n    );\n  }\n}\n","import type { ThematicBreak } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class HorizontalRuleExtension extends NodeExtension<ThematicBreak> {\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new InputRule(/^\\s{0,3}(?:\\*\\*\\*|---|___)\\n$/u, (state, _, start, end) =>\n        state.tr.replaceWith(\n          start,\n          end,\n          createProseMirrorNode(\n            this.proseMirrorNodeName(),\n            proseMirrorSchema,\n            [],\n          ),\n        ),\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Mod-_\": (state, dispatch): true => {\n        if (dispatch) {\n          dispatch(\n            state.tr\n              .replaceSelectionWith(\n                proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(),\n              )\n              .scrollIntoView(),\n          );\n        }\n        return true;\n      },\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"horizontal_rule\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"block\",\n      parseDOM: [{ tag: \"hr\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"div\", [\"hr\"]];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<ThematicBreak> {\n    return [\n      {\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"thematicBreak\" {\n    return \"thematicBreak\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: ThematicBreak,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Image } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ParagraphExtension } from \"./ParagraphExtension\";\n\n/**\n * @public\n */\nexport class ImageExtension extends NodeExtension<Image> {\n  public override dependencies(): Array<Extension> {\n    return [new ParagraphExtension()];\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"image\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: {\n        alt: { default: null },\n        src: {},\n        title: { default: null },\n      },\n      draggable: true,\n      group: \"inline\",\n      inline: true,\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): {\n            alt: string | null;\n            src: string | null;\n            title: string | null;\n          } {\n            return {\n              alt: (dom as HTMLElement).getAttribute(\"alt\"),\n              src: (dom as HTMLElement).getAttribute(\"src\"),\n              title: (dom as HTMLElement).getAttribute(\"title\"),\n            };\n          },\n          tag: \"img[src]\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\"img\", node.attrs];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n  ): Array<Image> {\n    return [\n      {\n        type: this.unistNodeName(),\n        url: node.attrs[\"src\"] as string,\n        ...(node.attrs[\"alt\"] !== null && { alt: node.attrs[\"alt\"] as string }),\n        ...(node.attrs[\"title\"] !== null && {\n          title: node.attrs[\"title\"] as string,\n        }),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"image\" {\n    return \"image\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Image,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        alt: node.alt,\n        src: node.url,\n        title: node.title,\n      },\n    );\n  }\n}\n","import type { ImageReference } from \"mdast\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { type Extension, NodeExtension } from \"prosemirror-unified\";\n\nimport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./DefinitionExtension\";\nimport { ImageExtension } from \"./ImageExtension\";\n\n/**\n * @public\n */\nexport interface ImageReferenceExtensionContext {\n  proseMirrorNodes: Record<string, ProseMirrorNode>;\n}\n\n/**\n * @public\n */\nexport class ImageReferenceExtension extends NodeExtension<ImageReference> {\n  public override dependencies(): Array<Extension> {\n    return [new DefinitionExtension(), new ImageExtension()];\n  }\n\n  public override postUnistToProseMirrorHook(\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n      ImageReferenceExtension: ImageReferenceExtensionContext;\n    }>,\n  ): void {\n    if (\n      context.ImageReferenceExtension === undefined ||\n      context.DefinitionExtension === undefined\n    ) {\n      return;\n    }\n    for (const id in context.ImageReferenceExtension.proseMirrorNodes) {\n      if (!(id in context.DefinitionExtension.definitions)) {\n        continue;\n      }\n      const definition = context.DefinitionExtension.definitions[id];\n      const attrs = context.ImageReferenceExtension.proseMirrorNodes[id]\n        .attrs as Record<\n        string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Attrs can be any\n        any\n      >;\n      attrs[\"src\"] = definition.url;\n      if (definition.title !== undefined) {\n        attrs[\"title\"] = definition.title;\n      }\n    }\n  }\n\n  public override proseMirrorNodeName(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeSpec(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<ImageReference> {\n    return [];\n  }\n\n  public override unistNodeName(): \"imageReference\" {\n    return \"imageReference\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: ImageReference,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      ImageReferenceExtension: ImageReferenceExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    const proseMirrorNode = proseMirrorSchema.nodes[\"image\"].createAndFill(\n      { alt: node.alt, src: \"\", title: node.label },\n      convertedChildren,\n    );\n    if (proseMirrorNode === null) {\n      return [];\n    }\n    if (context.ImageReferenceExtension === undefined) {\n      context.ImageReferenceExtension = { proseMirrorNodes: {} };\n    }\n    context.ImageReferenceExtension.proseMirrorNodes[node.identifier] =\n      proseMirrorNode;\n    return [proseMirrorNode];\n  }\n}\n","import type { InlineCode, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class InlineCodeExtension extends MarkExtension<InlineCode> {\n  public override processConvertedUnistNode(convertedNode: Text): InlineCode {\n    return { type: this.unistNodeName(), value: convertedNode.value };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /(?<!`)(?<b>`+)(?!`)(?<s> ?)(?<i>.*)\\k<s>(?<!`)\\k<b>(?<t>[^`])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Ctrl-`\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"code\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      inclusive: false,\n      parseDOM: [{ tag: \"code\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"code\", 0];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"inlineCode\" {\n    return \"inlineCode\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: InlineCode,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return [\n      proseMirrorSchema\n        .text(node.value)\n        .mark([proseMirrorSchema.marks[this.proseMirrorMarkName()].create()]),\n    ];\n  }\n}\n","import type { Emphasis, Strong, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ItalicExtension extends MarkExtension<Emphasis> {\n  public override processConvertedUnistNode(\n    convertedNode: Strong | Text,\n  ): Emphasis {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /(?<!\\*)\\*([^\\s*](?:.*[^\\s])?)\\*([^*])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /(?<!_)_([^\\s_](?:.*[^\\s])?)_([^_])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Mod-i\": toggleMark(markType),\n      \"Mod-I\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"em\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"i\" },\n        { tag: \"em\" },\n        {\n          getAttrs: (value) => value === \"italic\" && null,\n          style: \"font-style\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"em\", 0];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"emphasis\" {\n    return \"emphasis\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Emphasis,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","import type { Link, Text } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  Mark,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { MarkExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class LinkExtension extends MarkExtension<Link> {\n  public override processConvertedUnistNode(\n    convertedNode: Text,\n    originalMark: Mark,\n  ): Link {\n    return {\n      type: this.unistNodeName(),\n      url: originalMark.attrs[\"href\"] as string,\n      ...(originalMark.attrs[\"title\"] !== null && {\n        title: originalMark.attrs[\"title\"] as string,\n      }),\n      children: [convertedNode],\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"link\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      attrs: { href: {}, title: { default: null } },\n      inclusive: false,\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): {\n            href: string | null;\n            title: string | null;\n          } {\n            return {\n              href: (dom as HTMLElement).getAttribute(\"href\"),\n              title: (dom as HTMLElement).getAttribute(\"title\"),\n            };\n          },\n          tag: \"a[href]\",\n        },\n      ],\n      toDOM(node: Mark): DOMOutputSpec {\n        return [\"a\", node.attrs, 0];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"link\" {\n    return \"link\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Link,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create({\n            href: node.url,\n            title: node.title,\n          }),\n        ]),\n      ),\n    );\n  }\n}\n","import type { LinkReference } from \"mdast\";\nimport type { Mark, Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { type Extension, MarkExtension } from \"prosemirror-unified\";\n\nimport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./DefinitionExtension\";\nimport { LinkExtension } from \"./LinkExtension\";\n\n/**\n * @public\n */\nexport interface LinkReferenceExtensionContext {\n  marks: Record<string, Mark>;\n}\n\n/**\n * @public\n */\nexport class LinkReferenceExtension extends MarkExtension<LinkReference> {\n  public override dependencies(): Array<Extension> {\n    return [new DefinitionExtension(), new LinkExtension()];\n  }\n\n  public override postUnistToProseMirrorHook(\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n      LinkReferenceExtension: LinkReferenceExtensionContext;\n    }>,\n  ): void {\n    if (\n      context.LinkReferenceExtension === undefined ||\n      context.DefinitionExtension === undefined\n    ) {\n      return;\n    }\n    for (const id in context.LinkReferenceExtension.marks) {\n      if (!(id in context.DefinitionExtension.definitions)) {\n        continue;\n      }\n      const definition = context.DefinitionExtension.definitions[id];\n      const attrs = context.LinkReferenceExtension.marks[id].attrs as Record<\n        string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Attrs can be any\n        any\n      >;\n      attrs[\"href\"] = definition.url;\n      if (definition.title !== undefined) {\n        attrs[\"title\"] = definition.title;\n      }\n    }\n  }\n\n  public override processConvertedUnistNode(\n    convertedNode: LinkReference,\n  ): LinkReference {\n    return convertedNode;\n  }\n\n  public override proseMirrorMarkName(): null {\n    return null;\n  }\n\n  public override proseMirrorMarkSpec(): null {\n    return null;\n  }\n\n  public override unistNodeName(): \"linkReference\" {\n    return \"linkReference\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: LinkReference,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      LinkReferenceExtension: LinkReferenceExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    const mark = proseMirrorSchema.marks[\"link\"].create({\n      href: null,\n      title: null,\n    });\n    if (context.LinkReferenceExtension === undefined) {\n      context.LinkReferenceExtension = { marks: {} };\n    }\n    context.LinkReferenceExtension.marks[node.identifier] = mark;\n    return convertedChildren.map((child) =>\n      child.mark(child.marks.concat([mark])),\n    );\n  }\n}\n","import type { BlockContent, DefinitionContent, ListItem } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  liftListItem,\n  sinkListItem,\n  splitListItem,\n} from \"prosemirror-schema-list\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ListItemExtension extends NodeExtension<ListItem> {\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const nodeType = proseMirrorSchema.nodes[this.proseMirrorNodeName()];\n    return {\n      Enter: splitListItem(nodeType),\n      \"Shift-Tab\": liftListItem(nodeType),\n      Tab: sinkListItem(nodeType),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"regular_list_item\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"paragraph block*\",\n      defining: true,\n      group: \"list_item\",\n      parseDOM: [{ tag: \"li\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"li\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<ListItem> {\n    return [\n      {\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"listItem\" {\n    return \"listItem\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: ListItem,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() &&\n      (!(\"checked\" in node) || typeof node.checked !== \"boolean\")\n    );\n  }\n}\n","import type { List, ListContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { wrapInList } from \"prosemirror-schema-list\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ListItemExtension } from \"./ListItemExtension\";\n\n/**\n * @public\n */\nexport class OrderedListExtension extends NodeExtension<List> {\n  public override dependencies(): Array<Extension> {\n    return [new ListItemExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}(\\d+)\\.\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        (match) => ({ start: +match[1] }),\n        (match, node) =>\n          node.childCount + (node.attrs[\"start\"] as number) === +match[1],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Shift-Mod-9\": wrapInList(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"ordered_list\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { spread: { default: false }, start: { default: 1 } },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): { spread: boolean; start: number } {\n            const start = (dom as HTMLElement).getAttribute(\"start\");\n            return {\n              spread:\n                (dom as HTMLElement).getAttribute(\"data-spread\") === \"true\",\n              start: start !== null ? parseInt(start, 10) : 1,\n            };\n          },\n          tag: \"ol\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\n          \"ol\",\n          {\n            \"data-spread\": node.attrs[\"spread\"] as boolean,\n            start: node.attrs[\"start\"] as number,\n          },\n          0,\n        ];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<ListContent>,\n  ): Array<List> {\n    const spread = node.attrs[\"spread\"] as boolean;\n    return [\n      {\n        children: convertedChildren.map((child) => {\n          child.spread = spread;\n          return child;\n        }),\n        ordered: true,\n        spread,\n        start: node.attrs[\"start\"] as number,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"list\" {\n    return \"list\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: List,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        spread: node.spread,\n        start: node.start ?? 1,\n      },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() && (node as List).ordered === true\n    );\n  }\n}\n","import type { Root, RootContent } from \"mdast\";\nimport type {\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class RootExtension extends NodeExtension<Root> {\n  public override proseMirrorNodeName(): string {\n    return \"doc\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return { content: \"block+\" };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<RootContent>,\n  ): Array<Root> {\n    return [{ children: convertedChildren, type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"root\" {\n    return \"root\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Root,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { List, ListContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { wrapInList } from \"prosemirror-schema-list\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ListItemExtension } from \"./ListItemExtension\";\n\n/**\n * @public\n */\nexport class UnorderedListExtension extends NodeExtension<List> {\n  public override dependencies(): Array<Extension> {\n    return [new ListItemExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}([-+*])\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Shift-Mod-8\": wrapInList(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"bullet_list\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { spread: { default: false } },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): { spread: boolean } {\n            return {\n              spread:\n                (dom as HTMLElement).getAttribute(\"data-spread\") === \"true\",\n            };\n          },\n          tag: \"ul\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\"ul\", { \"data-spread\": node.attrs[\"spread\"] as boolean }, 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<ListContent>,\n  ): Array<List> {\n    const spread = node.attrs[\"spread\"] as boolean;\n    return [\n      {\n        children: convertedChildren.map((child) => {\n          child.spread = spread;\n          return child;\n        }),\n        ordered: false,\n        spread,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"list\" {\n    return \"list\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: List,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        spread: node.spread,\n      },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() && (node as List).ordered !== true\n    );\n  }\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { Extension } from \"prosemirror-unified\";\nimport remarkParse from \"remark-parse\";\nimport remarkStringify from \"remark-stringify\";\n\nimport { BlockquoteExtension } from \"./syntax-extensions/BlockquoteExtension\";\nimport { BoldExtension } from \"./syntax-extensions/BoldExtension\";\nimport { BreakExtension } from \"./syntax-extensions/BreakExtension\";\nimport { CodeBlockExtension } from \"./syntax-extensions/CodeBlockExtension\";\nimport { DefinitionExtension } from \"./syntax-extensions/DefinitionExtension\";\nimport { HeadingExtension } from \"./syntax-extensions/HeadingExtension\";\nimport { HorizontalRuleExtension } from \"./syntax-extensions/HorizontalRuleExtension\";\nimport { ImageExtension } from \"./syntax-extensions/ImageExtension\";\nimport { ImageReferenceExtension } from \"./syntax-extensions/ImageReferenceExtension\";\nimport { InlineCodeExtension } from \"./syntax-extensions/InlineCodeExtension\";\nimport { ItalicExtension } from \"./syntax-extensions/ItalicExtension\";\nimport { LinkExtension } from \"./syntax-extensions/LinkExtension\";\nimport { LinkReferenceExtension } from \"./syntax-extensions/LinkReferenceExtension\";\nimport { ListItemExtension } from \"./syntax-extensions/ListItemExtension\";\nimport { OrderedListExtension } from \"./syntax-extensions/OrderedListExtension\";\nimport { ParagraphExtension } from \"./syntax-extensions/ParagraphExtension\";\nimport { RootExtension } from \"./syntax-extensions/RootExtension\";\nimport { TextExtension } from \"./syntax-extensions/TextExtension\";\nimport { UnorderedListExtension } from \"./syntax-extensions/UnorderedListExtension\";\n\n/**\n * @public\n */\nexport class MarkdownExtension extends Extension {\n  public override dependencies(): Array<Extension> {\n    return [\n      // ParagraphExtension needs to be first so that it is the default block.\n      new ParagraphExtension(),\n      new BlockquoteExtension(),\n      new BoldExtension(),\n      new BreakExtension(),\n      new CodeBlockExtension(),\n      new DefinitionExtension(),\n      new HeadingExtension(),\n      new HorizontalRuleExtension(),\n      new ImageExtension(),\n      new ImageReferenceExtension(),\n      new InlineCodeExtension(),\n      new ItalicExtension(),\n      new LinkExtension(),\n      new LinkReferenceExtension(),\n      new ListItemExtension(),\n      new OrderedListExtension(),\n      new RootExtension(),\n      new TextExtension(),\n      new UnorderedListExtension(),\n    ];\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(remarkParse).use(remarkStringify, {\n      fences: true,\n      listItemIndent: \"one\",\n      resourceLink: true,\n      rule: \"-\",\n    }) as unknown as Processor<\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      string\n    >;\n  }\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodes parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodes children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isnt a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`)  whole match\n *   * `...capture` (`Array<string>`)  matches from regex capture groups\n *   * `match` (`RegExpMatchObject`)  info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * or when `false`, do not replace at all\n *   * or when `string`, replace with a text node of that value\n *   * or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasnt a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n","/**\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\nimport {ccount} from 'ccount'\nimport {ok as assert} from 'devlop'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '@',\n        before: '[+\\\\-.\\\\w]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: '.',\n        before: '[Ww]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: ':',\n        before: '[ps]',\n        after: '\\\\/',\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'link')\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Array<PhrasingContent> | Link | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    // If its an email, the previous character should not be a slash.\n    (!email || code !== 47)\n  )\n}\n","/**\n * @import {Code, ConstructRecord, Event, Extension, Previous, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nconst wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n};\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nconst trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n};\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n};\nconst wwwAutolink = {\n  name: 'wwwAutolink',\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nconst protocolAutolink = {\n  name: 'protocolAutolink',\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n};\nconst emailAutolink = {\n  name: 'emailAutolink',\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n\n/** @type {ConstructRecord} */\nconst text = {};\n\n/**\n * Create an extension for `micromark` to support GitHub autolink literal\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   autolink literal syntax.\n */\nexport function gfmAutolinkLiteral() {\n  return {\n    text\n  };\n}\n\n/** @type {Code} */\nlet code = 48;\n\n// Add alphanumerics.\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, protocolAutolink];\ntext[104] = [emailAutolink, protocolAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink];\n\n// To do: perform email autolink literals on events, afterwards.\n// Thats where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this;\n  /** @type {boolean | undefined} */\n  let dot;\n  /** @type {boolean} */\n  let data;\n  return start;\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n    if (code === 64) {\n      effects.consume(code);\n      return emailDomain;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === 46) {\n      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {\n      data = true;\n      effects.consume(code);\n      return emailDomain;\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally wed truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isnt trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code);\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code);\n    dot = true;\n    return emailDomain;\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this;\n  return wwwStart;\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (code !== 87 && code !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww');\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this;\n  let buffer = '';\n  let seen = false;\n  return protocolStart;\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if ((code === 72 || code === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n      effects.enter('literalAutolink');\n      effects.enter('literalAutolinkHttp');\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    if (code === 58) {\n      const protocol = buffer.toLowerCase();\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code);\n        return protocolSlashesInside;\n      }\n    }\n    return nok(code);\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === 47) {\n      effects.consume(code);\n      if (seen) {\n        return afterProtocol;\n      }\n      seen = true;\n      return protocolSlashesInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === null || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0;\n  return wwwPrefixInside;\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === 87 || code === 119) && size < 3) {\n      size++;\n      effects.consume(code);\n      return wwwPrefixInside;\n    }\n    if (code === 46 && size === 3) {\n      effects.consume(code);\n      return wwwPrefixAfter;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === null ? nok(code) : ok(code);\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment;\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment;\n  /** @type {boolean | undefined} */\n  let seen;\n  return domainInside;\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === 46 || code === 95) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code);\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {\n      return domainAfter(code);\n    }\n    seen = true;\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === 95) {\n      underscoreInLastSegment = true;\n    }\n    // Otherwise, its a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment;\n      underscoreInLastSegment = undefined;\n    }\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: thats GH says a dot is needed, but its not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code);\n    }\n    return ok(code);\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0;\n  let sizeClose = 0;\n  return pathInside;\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === 40) {\n      sizeOpen++;\n      effects.consume(code);\n      return pathInside;\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we dont check for a trail.\n    if (code === 41 && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code);\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {\n      return effects.check(trail, ok, pathAtPunctuation)(code);\n    }\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === 41) {\n      sizeClose++;\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail;\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {\n      effects.consume(code);\n      return trail;\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === 38) {\n      effects.consume(code);\n      return trailCharacterReferenceStart;\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === 93) {\n      effects.consume(code);\n      return trailBracketAfter;\n    }\n    if (\n    // `<` is an end.\n    code === 60 ||\n    // So is whitespace.\n    code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * >  **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (code === null || code === 40 || code === 91 || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return trail(code);\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceStart(code) {\n    // When non-alpha, its not a trail.\n    return asciiAlpha(code) ? trailCharacterReferenceInside(code) : nok(code);\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === 59) {\n      effects.consume(code);\n      return trail;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return trailCharacterReferenceInside;\n    }\n\n    // Its not a trail.\n    return nok(code);\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start;\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code);\n    return after;\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code);\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || markdownLineEndingOrSpace(code);\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code);\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash inside atext.\n  // The reference code is a bit weird, but thats what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === 47 || gfmAtext(code));\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n  while (index--) {\n    const token = events[index][1];\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    }\n\n    // If weve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n  if (events.length > 0 && !result) {\n    // Mark the last token as walked into w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n  return result;\n}","import type { Extension as FromMarkdownExtension } from \"mdast-util-from-markdown\";\nimport type { Options as ToMarkdownExtension } from \"mdast-util-to-markdown\";\nimport type { Extension as MicromarkExtension } from \"micromark-util-types\";\nimport type { Processor } from \"unified\";\n\nexport function buildUnifiedExtension(\n  micromarkExtensions: Array<MicromarkExtension>,\n  fromMarkdownExtensions: Array<FromMarkdownExtension>,\n  toMarkdownExtensions: Array<ToMarkdownExtension>,\n): () => void {\n  return function (this: Processor) {\n    // eslint-disable-next-line no-invalid-this -- this provided by unified\n    const data = this.data();\n\n    data.micromarkExtensions ??= [];\n    data.fromMarkdownExtensions ??= [];\n    data.toMarkdownExtensions ??= [];\n\n    data.micromarkExtensions.push(...micromarkExtensions);\n    data.fromMarkdownExtensions.push(...fromMarkdownExtensions);\n    data.toMarkdownExtensions.push(...toMarkdownExtensions);\n  };\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown,\n} from \"mdast-util-gfm-autolink-literal\";\nimport { gfmAutolinkLiteral } from \"micromark-extension-gfm-autolink-literal\";\nimport { Extension } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\n/**\n * @public\n */\nexport class ExtendedAutolinkExtension extends Extension {\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmAutolinkLiteral()],\n        [gfmAutolinkLiteralFromMarkdown()],\n        [gfmAutolinkLiteralToMarkdown()],\n      ),\n    );\n  }\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: ['delete'],\n    enter: {strikethrough: enterStrikethrough},\n    exit: {strikethrough: exitStrikethrough}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '~',\n        inConstruct: 'phrasing',\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: {delete: handleDelete}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  const exit = state.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {undefined}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if theres only a couple (10k) items.\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, its fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, its fine.\n      list.splice(...parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * >  **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {Array<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @import {Options} from 'micromark-extension-gfm-strikethrough'\n * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {};\n  let single = options_.singleTilde;\n  const tokenizer = {\n    name: 'strikethrough',\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  };\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1;\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index;\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&\n          // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            };\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];\n            const insideSpan = context.parser.constructs.insideSpan.null;\n            if (insideSpan) {\n              // Between.\n              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan, events.slice(open + 1, index), context));\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = \"data\";\n      }\n    }\n    return events;\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      if (previous === 126 && events[events.length - 1][1].type !== \"characterEscape\") {\n        return nok(code);\n      }\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous);\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = classifyCharacter(code);\n      token._open = !after || after === 2 && Boolean(before);\n      token._close = !before || before === 2 && Boolean(after);\n      return ok(code);\n    }\n  }\n}","import type { Delete, Emphasis, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown,\n} from \"mdast-util-gfm-strikethrough\";\nimport { gfmStrikethrough } from \"micromark-extension-gfm-strikethrough\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\n/**\n * @public\n */\nexport class StrikethroughExtension extends MarkExtension<Delete> {\n  public override processConvertedUnistNode(\n    convertedNode: Emphasis | Text,\n  ): Delete {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /~([^\\s](?:.*[^\\s~])?)~([^~])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /~~([^\\s](?:.*[^\\s])?)~~([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"strikethrough\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"s\" },\n        { tag: \"del\" },\n        {\n          getAttrs: (value) =>\n            /(^|[\\s])line-through([\\s]|$)/u.test(value) && null,\n          style: \"text-decoration\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"s\", 0];\n      },\n    };\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmStrikethrough()],\n        [gfmStrikethroughFromMarkdown()],\n        [gfmStrikethroughToMarkdown()],\n      ),\n    );\n  }\n\n  public override unistNodeName(): \"delete\" {\n    return \"delete\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Delete,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","/**\n * @import {Blockquote, Parents} from 'mdast'\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @import {Break, Parents} from 'mdast'\n * @import {Info, State} from 'mdast-util-to-markdown'\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we cant put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Code} from 'mdast'\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If theres no info\n      !node.lang &&\n      // And theres a non-whitespace character\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnt start or end in a blank\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {Code, Parents} from 'mdast'\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Definition, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If theres no url, or\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Encode a code point as a character reference.\n *\n * @param {number} code\n *   Code point to encode.\n * @returns {string}\n *   Encoded character reference.\n */\nexport function encodeCharacterReference(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @import {EncodeSides} from '../types.js'\n */\n\nimport {classifyCharacter} from 'micromark-util-classify-character'\n\n/**\n * Check whether to encode (as a character reference) the characters\n * surrounding an attention run.\n *\n * Which characters are around an attention run influence whether it works or\n * not.\n *\n * See <https://github.com/orgs/syntax-tree/discussions/60> for more info.\n * See this markdown in a particular renderer to see what works:\n *\n * ```markdown\n * |                         | A (letter inside) | B (punctuation inside) | C (whitespace inside) | D (nothing inside) |\n * | ----------------------- | ----------------- | ---------------------- | --------------------- | ------------------ |\n * | 1 (letter outside)      | x*y*z             | x*.*z                  | x* *z                 | x**z               |\n * | 2 (punctuation outside) | .*y*.             | .*.*.                  | .* *.                 | .**.               |\n * | 3 (whitespace outside)  | x *y* z           | x *.* z                | x * * z               | x ** z             |\n * | 4 (nothing outside)     | *x*               | *.*                    | * *                   | **                 |\n * ```\n *\n * @param {number} outside\n *   Code point on the outer side of the run.\n * @param {number} inside\n *   Code point on the inner side of the run.\n * @param {'*' | '_'} marker\n *   Marker of the run.\n *   Underscores are handled more strictly (they form less often) than\n *   asterisks.\n * @returns {EncodeSides}\n *   Whether to encode characters.\n */\n// Important: punctuation must never be encoded.\n// Punctuation is solely used by markdown constructs.\n// And by encoding itself.\n// Encoding them will break constructs or double encode things.\nexport function encodeInfo(outside, inside, marker) {\n  const outsideKind = classifyCharacter(outside)\n  const insideKind = classifyCharacter(inside)\n\n  // Letter outside:\n  if (outsideKind === undefined) {\n    return insideKind === undefined\n      ? // Letter inside:\n        // we have to encode *both* letters for `_` as it is looser.\n        // it already forms for `*` (and GFMs `~`).\n        marker === '_'\n        ? {inside: true, outside: true}\n        : {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (letter, whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: encode outer (letter)\n          {inside: false, outside: true}\n  }\n\n  // Whitespace outside:\n  if (outsideKind === 1) {\n    return insideKind === undefined\n      ? // Letter inside: already forms.\n        {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: already forms.\n          {inside: false, outside: false}\n  }\n\n  // Punctuation outside:\n  return insideKind === undefined\n    ? // Letter inside: already forms.\n      {inside: false, outside: false}\n    : insideKind === 1\n      ? // Whitespace inside: encode inner (whitespace).\n        {inside: true, outside: false}\n      : // Punctuation inside: already forms.\n        {inside: false, outside: false}\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Emphasis, Parents} from 'mdast'\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nemphasis.peek = emphasisPeek\n\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when its released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Heading} from 'mdast'\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Heading, Parents} from 'mdast'\n */\n\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @import {Html} from 'mdast'\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Image, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {ImageReference, Parents} from 'mdast'\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Link} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Link, Parents} from 'mdast'\n * @import {Exit} from '../types.js'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {LinkReference, Parents} from 'mdast'\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {List, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If theres an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If theres a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {ListItem, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Paragraph, Parents} from 'mdast'\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * >  **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Root} from 'mdast'\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n\n  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return container.call(state, node, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Strong} from 'mdast'\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nstrong.peek = strongPeek\n\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker + marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker + marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Text} from 'mdast'\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Parents, ThematicBreak} from 'mdast'\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `` represents a tab (plus how much it expands) and `` represents a\n * single space.\n *\n * ```markdown\n * \n * \n * \n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nconst tasklistCheck = {\n  name: 'tasklistCheck',\n  tokenize: tokenizeTasklistCheck\n};\n\n/**\n * Create an HTML extension for `micromark` to support GFM task list items\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM task list items when serializing to HTML.\n */\nexport function gfmTaskListItem() {\n  return {\n    text: {\n      [91]: tasklistCheck\n    }\n  };\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this;\n  return open;\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n    // Exit if theres stuff before.\n    self.previous !== null ||\n    // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n    return nok(code);\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return after;\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code);\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok)(code);\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, \"whitespace\");\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means theres content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code);\n  }\n}","import type { BlockContent, DefinitionContent, ListItem } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command, EditorState } from \"prosemirror-state\";\nimport type {\n  EditorView,\n  NodeView,\n  NodeViewConstructor,\n} from \"prosemirror-view\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown,\n} from \"mdast-util-gfm-task-list-item\";\nimport { gfmTaskListItem } from \"micromark-extension-gfm-task-list-item\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\nclass TaskListItemView implements NodeView {\n  public readonly contentDOM: HTMLElement;\n  public readonly dom: HTMLElement;\n\n  public constructor(\n    node: ProseMirrorNode,\n    view: EditorView,\n    getPos: () => number | undefined,\n  ) {\n    const checkbox = document.createElement(\"input\");\n    checkbox.setAttribute(\"type\", \"checkbox\");\n    checkbox.setAttribute(\"style\", \"cursor: pointer;\");\n    if (node.attrs[\"checked\"] === true) {\n      checkbox.setAttribute(\"checked\", \"checked\");\n    }\n    checkbox.addEventListener(\"click\", (e) => {\n      const pos = getPos();\n      if (pos === undefined) {\n        return;\n      }\n      e.preventDefault();\n      view.dispatch(\n        view.state.tr.setNodeAttribute(\n          pos,\n          \"checked\",\n          !(node.attrs[\"checked\"] as boolean),\n        ),\n      );\n    });\n\n    const checkboxContainer = document.createElement(\"span\");\n    checkboxContainer.setAttribute(\"contenteditable\", \"false\");\n    checkboxContainer.setAttribute(\"style\", \"position: absolute; left: 5px;\");\n    checkboxContainer.appendChild(checkbox);\n\n    this.contentDOM = document.createElement(\"span\");\n    this.contentDOM.setAttribute(\"style\", \"position: relative; left: 30px;\");\n\n    this.dom = document.createElement(\"li\");\n    this.dom.setAttribute(\n      \"style\",\n      \"list-style-type: none; margin-left: -30px;\",\n    );\n    this.dom.appendChild(checkboxContainer);\n    this.dom.appendChild(this.contentDOM);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inherited from the NodeView interface\n  public stopEvent(): boolean {\n    return true;\n  }\n}\n\n/**\n * @public\n */\nexport class TaskListItemExtension extends NodeExtension<ListItem> {\n  private static isAtStart(\n    state: EditorState,\n    view: EditorView | undefined,\n  ): boolean {\n    if (!state.selection.empty) {\n      return false;\n    }\n    if (view !== undefined) {\n      return view.endOfTextblock(\"backward\", state);\n    }\n    return state.selection.$anchor.parentOffset > 0;\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new InputRule(/^\\[([x\\s]?)\\][\\s\\S]$/u, (state, match, start) => {\n        const wrappingNode = state.doc.resolve(start).node(-1);\n        if (wrappingNode.type.name !== \"regular_list_item\") {\n          return null;\n        }\n        return state.tr.replaceRangeWith(\n          start - 2,\n          start + wrappingNode.nodeSize,\n          proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(\n            { checked: match[1] === \"x\" },\n            wrappingNode.content.cut(3 + match[1].length),\n          ),\n        );\n      }),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      Backspace: (state, dispatch, view): boolean => {\n        if (!TaskListItemExtension.isAtStart(state, view)) {\n          return false;\n        }\n        const taskListItemNode = state.selection.$anchor.node(-1);\n        if (taskListItemNode.type.name !== \"task_list_item\") {\n          return false;\n        }\n        if (dispatch === undefined) {\n          return true;\n        }\n        dispatch(\n          state.tr.replaceRangeWith(\n            state.selection.$from.before() - 2,\n            state.selection.$from.before() + taskListItemNode.nodeSize,\n            proseMirrorSchema.nodes[\"regular_list_item\"].create(\n              {},\n              taskListItemNode.content,\n            ),\n          ),\n        );\n        return true;\n      },\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"task_list_item\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { checked: { default: false } },\n      content: \"paragraph block*\",\n      defining: true,\n      group: \"list_item\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): false | { checked: boolean } {\n            const checkbox = (dom as HTMLElement).firstChild;\n            if (!(checkbox instanceof HTMLInputElement)) {\n              return false;\n            }\n            return { checked: checkbox.checked };\n          },\n          tag: \"li\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\n          \"li\",\n          { style: \"list-style-type: none;, margin-left: -30px;\" },\n          [\n            \"span\",\n            {\n              contenteditable: \"false\",\n              style: \"position: absolute; left: 5px;\",\n            },\n            [\n              \"input\",\n              {\n                checked: (node.attrs[\"checked\"] as boolean)\n                  ? \"checked\"\n                  : undefined,\n                disabled: \"disabled\",\n                type: \"checkbox\",\n              },\n            ],\n          ],\n          [\"span\", { style: \"position: relative; left: 30px\" }, 0],\n        ];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<ListItem> {\n    return [\n      {\n        checked: node.attrs[\"checked\"] as boolean,\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override proseMirrorNodeView(): NodeViewConstructor | null {\n    return (node, view, getPos) => new TaskListItemView(node, view, getPos);\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmTaskListItem()],\n        [gfmTaskListItemFromMarkdown()],\n        [gfmTaskListItemToMarkdown()],\n      ),\n    );\n  }\n\n  public override unistNodeName(): \"listItem\" {\n    return \"listItem\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: ListItem,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      { checked: node.checked },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() &&\n      \"checked\" in node &&\n      typeof node.checked === \"boolean\"\n    );\n  }\n}\n","import { Extension } from \"prosemirror-unified\";\n\nimport { MarkdownExtension } from \"./MarkdownExtension\";\nimport { ExtendedAutolinkExtension } from \"./syntax-extensions/ExtendedAutolinkExtension\";\nimport { StrikethroughExtension } from \"./syntax-extensions/StrikethroughExtension\";\nimport { TaskListItemExtension } from \"./syntax-extensions/TaskListItemExtension\";\n\n/**\n * @public\n */\nexport class GFMExtension extends Extension {\n  public override dependencies(): Array<Extension> {\n    return [\n      new MarkdownExtension(),\n      new ExtendedAutolinkExtension(),\n      new StrikethroughExtension(),\n      new TaskListItemExtension(),\n    ];\n  }\n}\n"],"names":["NodeExtension","wrappingInputRule","wrapIn","createProseMirrorNode","MarkExtension","MarkInputRule","toggleMark","chainCommands","exitCode","node","Selection","textblockTypeInputRule","setBlockType","InputRule","definition","splitListItem","liftListItem","sinkListItem","wrapInList","Extension","ok","code","index","all","visit","list","escape","assert","domain","path","trail","text","previous","map","exit","value","subexit","defaultHandlers"],"mappings":"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","x_google_ignoreList":[20,21,22,23,24,25,26,27,28,29,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80]}
\ No newline at end of file
diff --git a/dist/prosemirror-remark.d.ts b/dist/prosemirror-remark.d.ts
index d2888705ba042f34b3e33c008eae5a9b9885552b..605b38171734cbf4a99c9bcf4e7eaef6503f3849 100644
--- a/dist/prosemirror-remark.d.ts
+++ b/dist/prosemirror-remark.d.ts
@@ -1,40 +1,40 @@
-import type { BlockContent } from 'mdast';
-import type { Blockquote } from 'mdast';
-import type { Break } from 'mdast';
-import type { Code } from 'mdast';
+import { BlockContent } from 'mdast';
+import { Blockquote } from 'mdast';
+import { Break } from 'mdast';
+import { Code } from 'mdast';
 import { Command } from 'prosemirror-state';
-import type { Definition } from 'mdast';
-import type { DefinitionContent } from 'mdast';
-import type { Delete } from 'mdast';
-import type { Emphasis } from 'mdast';
+import { Definition } from 'mdast';
+import { DefinitionContent } from 'mdast';
+import { Delete } from 'mdast';
+import { Emphasis } from 'mdast';
 import { Extension } from 'prosemirror-unified';
-import type { Heading } from 'mdast';
-import type { Image as Image_2 } from 'mdast';
-import type { ImageReference } from 'mdast';
-import type { InlineCode } from 'mdast';
+import { Heading } from 'mdast';
+import { Image as Image_2 } from 'mdast';
+import { ImageReference } from 'mdast';
+import { InlineCode } from 'mdast';
 import { InputRule } from 'prosemirror-inputrules';
-import type { Link } from 'mdast';
-import type { LinkReference } from 'mdast';
-import type { List } from 'mdast';
-import type { ListContent } from 'mdast';
-import type { ListItem } from 'mdast';
-import type { Mark } from 'prosemirror-model';
+import { Link } from 'mdast';
+import { LinkReference } from 'mdast';
+import { List } from 'mdast';
+import { ListContent } from 'mdast';
+import { ListItem } from 'mdast';
+import { Mark } from 'prosemirror-model';
 import { MarkExtension } from 'prosemirror-unified';
-import type { MarkSpec } from 'prosemirror-model';
-import type { Node as Node_2 } from 'unist';
-import type { Node as Node_3 } from 'prosemirror-model';
+import { MarkSpec } from 'prosemirror-model';
+import { Node as Node_2 } from 'unist';
+import { Node as Node_3 } from 'prosemirror-model';
 import { NodeExtension } from 'prosemirror-unified';
-import type { NodeSpec } from 'prosemirror-model';
-import type { NodeViewConstructor } from 'prosemirror-view';
-import type { Paragraph } from 'mdast';
-import type { PhrasingContent } from 'mdast';
-import type { Processor } from 'unified';
-import type { Root } from 'mdast';
-import type { RootContent } from 'mdast';
-import type { Schema } from 'prosemirror-model';
-import type { Strong } from 'mdast';
-import type { Text as Text_2 } from 'mdast';
-import type { ThematicBreak } from 'mdast';
+import { NodeSpec } from 'prosemirror-model';
+import { NodeViewConstructor } from 'prosemirror-view';
+import { Paragraph } from 'mdast';
+import { PhrasingContent } from 'mdast';
+import { Processor } from 'unified';
+import { Root } from 'mdast';
+import { RootContent } from 'mdast';
+import { Schema } from 'prosemirror-model';
+import { Strong } from 'mdast';
+import { Text as Text_2 } from 'mdast';
+import { ThematicBreak } from 'mdast';
 
 /**
  * @public
diff --git a/dist/prosemirror-remark.js b/dist/prosemirror-remark.js
index d4ebb3a12532a9db4f3e6c35eacf0fcba94e2303..81f95ce42314cd1ec9430901a3a0e63cbb2242f4 100644
--- a/dist/prosemirror-remark.js
+++ b/dist/prosemirror-remark.js
@@ -1,1618 +1,1110 @@
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__ from "prosemirror-unified";
-import * as __WEBPACK_EXTERNAL_MODULE_remark_parse_76724963__ from "remark-parse";
-import * as __WEBPACK_EXTERNAL_MODULE_remark_stringify_a28ae2a6__ from "remark-stringify";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__ from "prosemirror-commands";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__ from "prosemirror-inputrules";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__ from "prosemirror-state";
-import * as __WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__ from "prosemirror-schema-list";
-/******/ // The require scope
-/******/ var __webpack_require__ = {};
-/******/ 
-/************************************************************************/
-/******/ /* webpack/runtime/define property getters */
-/******/ (() => {
-/******/ 	// define getter functions for harmony exports
-/******/ 	__webpack_require__.d = (exports, definition) => {
-/******/ 		for(var key in definition) {
-/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
-/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
-/******/ 			}
-/******/ 		}
-/******/ 	};
-/******/ })();
-/******/ 
-/******/ /* webpack/runtime/hasOwnProperty shorthand */
-/******/ (() => {
-/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
-/******/ })();
-/******/ 
-/************************************************************************/
-var __webpack_exports__ = {};
-
-// EXPORTS
-__webpack_require__.d(__webpack_exports__, {
-  xT: () => (/* reexport */ BlockquoteExtension),
-  ll: () => (/* reexport */ BoldExtension),
-  j5: () => (/* reexport */ BreakExtension),
-  US: () => (/* reexport */ CodeBlockExtension),
-  rb: () => (/* reexport */ DefinitionExtension),
-  Qh: () => (/* reexport */ ExtendedAutolinkExtension),
-  Om: () => (/* reexport */ GFMExtension),
-  oq: () => (/* reexport */ HeadingExtension),
-  SY: () => (/* reexport */ HorizontalRuleExtension),
-  zS: () => (/* reexport */ ImageExtension),
-  OO: () => (/* reexport */ ImageReferenceExtension),
-  eX: () => (/* reexport */ InlineCodeExtension),
-  A6: () => (/* reexport */ ItalicExtension),
-  O$: () => (/* reexport */ LinkExtension),
-  lt: () => (/* reexport */ LinkReferenceExtension),
-  vs: () => (/* reexport */ ListItemExtension),
-  Db: () => (/* reexport */ MarkdownExtension),
-  XS: () => (/* reexport */ OrderedListExtension),
-  yV: () => (/* reexport */ ParagraphExtension),
-  sY: () => (/* reexport */ RootExtension),
-  zd: () => (/* reexport */ StrikethroughExtension),
-  uG: () => (/* reexport */ TaskListItemExtension),
-  r2: () => (/* reexport */ TextExtension),
-  Mv: () => (/* reexport */ UnorderedListExtension)
-});
-
-;// CONCATENATED MODULE: external "prosemirror-unified"
-var x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var y = (x) => (() => (x))
-const external_prosemirror_unified_namespaceObject = x({ ["Extension"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.Extension), ["MarkExtension"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.MarkExtension), ["MarkInputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.MarkInputRule), ["NodeExtension"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.NodeExtension), ["createProseMirrorNode"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.createProseMirrorNode) });
-;// CONCATENATED MODULE: external "remark-parse"
-var external_remark_parse_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_remark_parse_y = (x) => (() => (x))
-const external_remark_parse_namespaceObject = external_remark_parse_x({ ["default"]: () => (__WEBPACK_EXTERNAL_MODULE_remark_parse_76724963__["default"]) });
-;// CONCATENATED MODULE: external "remark-stringify"
-var external_remark_stringify_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_remark_stringify_y = (x) => (() => (x))
-const external_remark_stringify_namespaceObject = external_remark_stringify_x({ ["default"]: () => (__WEBPACK_EXTERNAL_MODULE_remark_stringify_a28ae2a6__["default"]) });
-;// CONCATENATED MODULE: external "prosemirror-commands"
-var external_prosemirror_commands_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_commands_y = (x) => (() => (x))
-const external_prosemirror_commands_namespaceObject = external_prosemirror_commands_x({ ["chainCommands"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.chainCommands), ["exitCode"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.exitCode), ["setBlockType"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.setBlockType), ["toggleMark"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.toggleMark), ["wrapIn"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.wrapIn) });
-;// CONCATENATED MODULE: external "prosemirror-inputrules"
-var external_prosemirror_inputrules_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_inputrules_y = (x) => (() => (x))
-const external_prosemirror_inputrules_namespaceObject = external_prosemirror_inputrules_x({ ["InputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.InputRule), ["textblockTypeInputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.textblockTypeInputRule), ["wrappingInputRule"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.wrappingInputRule) });
-;// CONCATENATED MODULE: ./src/syntax-extensions/BlockquoteExtension.ts
-
-
-
-/**
- * @public
- */
-class BlockquoteExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.wrappingInputRule)(/^\s{0,3}>\s$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            "Mod->": (0,external_prosemirror_commands_namespaceObject.wrapIn)(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        };
-    }
-    proseMirrorNodeName() {
-        return "blockquote";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            content: "block+",
-            group: "block",
-            parseDOM: [{ tag: "blockquote" }],
-            toDOM() {
-                return ["blockquote", 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [
-            {
-                children: convertedChildren,
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "blockquote";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/BoldExtension.ts
-
-
-/**
- * @public
- */
-class BoldExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode) {
-        return { children: [convertedNode], type: this.unistNodeName() };
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/\*\*([^\s](?:.*[^\s])?)\*\*([\s\S])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/__([^\s](?:.*[^\s])?)__([\s\S])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
-        return {
-            "Mod-b": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-            "Mod-B": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-        };
-    }
-    proseMirrorMarkName() {
-        return "strong";
-    }
-    proseMirrorMarkSpec() {
-        return {
-            parseDOM: [
-                { tag: "b" },
-                { tag: "strong" },
-                {
-                    getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/u.test(value) && null,
-                    style: "font-weight",
-                },
-            ],
-            toDOM() {
-                return ["strong"];
-            },
-        };
-    }
-    unistNodeName() {
-        return "strong";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return convertedChildren.map((child) => child.mark(child.marks.concat([
-            proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),
-        ])));
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/BreakExtension.ts
-
-
-/**
- * @public
- */
-class BreakExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorKeymap(proseMirrorSchema) {
-        const command = (0,external_prosemirror_commands_namespaceObject.chainCommands)(external_prosemirror_commands_namespaceObject.exitCode, (state, dispatch) => {
-            if (dispatch) {
-                dispatch(state.tr
-                    .replaceSelectionWith(proseMirrorSchema.nodes[this.proseMirrorNodeName()].create())
-                    .scrollIntoView());
-            }
-            return true;
-        });
-        const isMac = typeof navigator !== "undefined"
-            ? /Mac|iP(hone|[oa]d)/u.test(navigator.platform) // eslint-disable-line @typescript-eslint/no-deprecated -- In the tested systems, it will be defined
-            : false;
-        return Object.assign({ "Mod-Enter": command, "Shift-Enter": command }, (isMac && { "Ctrl-Enter": command }));
-    }
-    proseMirrorNodeName() {
-        return "hard_break";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            group: "inline",
-            inline: true,
-            parseDOM: [{ tag: "br" }],
-            selectable: false,
-            toDOM() {
-                return ["br"];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes() {
-        return [{ type: this.unistNodeName() }];
-    }
-    unistNodeName() {
-        return "break";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
+import { NodeExtension, createProseMirrorNode, MarkExtension, MarkInputRule, Extension } from "prosemirror-unified";
+import remarkParse from "remark-parse";
+import remarkStringify from "remark-stringify";
+import { wrapIn, toggleMark, chainCommands, exitCode, setBlockType } from "prosemirror-commands";
+import { wrappingInputRule, textblockTypeInputRule, InputRule } from "prosemirror-inputrules";
+import { Selection } from "prosemirror-state";
+import { splitListItem, liftListItem, sinkListItem, wrapInList } from "prosemirror-schema-list";
+class BlockquoteExtension extends NodeExtension {
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      wrappingInputRule(
+        /^\s{0,3}>\s$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      "Mod->": wrapIn(proseMirrorSchema.nodes[this.proseMirrorNodeName()])
+    };
+  }
+  proseMirrorNodeName() {
+    return "blockquote";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      content: "block+",
+      group: "block",
+      parseDOM: [{ tag: "blockquote" }],
+      toDOM() {
+        return ["blockquote", 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [
+      {
+        children: convertedChildren,
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "blockquote";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
+}
+class BoldExtension extends MarkExtension {
+  processConvertedUnistNode(convertedNode) {
+    return { children: [convertedNode], type: this.unistNodeName() };
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new MarkInputRule(
+        /\*\*([^\s](?:.*[^\s])?)\*\*([\s\S])$/u,
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      ),
+      new MarkInputRule(
+        /__([^\s](?:.*[^\s])?)__([\s\S])$/u,
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
+    return {
+      "Mod-b": toggleMark(markType),
+      "Mod-B": toggleMark(markType)
+    };
+  }
+  proseMirrorMarkName() {
+    return "strong";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      parseDOM: [
+        { tag: "b" },
+        { tag: "strong" },
+        {
+          getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/u.test(value) && null,
+          style: "font-weight"
+        }
+      ],
+      toDOM() {
+        return ["strong", 0];
+      }
+    };
+  }
+  unistNodeName() {
+    return "strong";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return convertedChildren.map(
+      (child) => child.mark(
+        child.marks.concat([
+          proseMirrorSchema.marks[this.proseMirrorMarkName()].create()
+        ])
+      )
+    );
+  }
+}
+class BreakExtension extends NodeExtension {
+  proseMirrorKeymap(proseMirrorSchema) {
+    const command = chainCommands(exitCode, (state, dispatch) => {
+      if (dispatch) {
+        dispatch(
+          state.tr.replaceSelectionWith(
+            proseMirrorSchema.nodes[this.proseMirrorNodeName()].create()
+          ).scrollIntoView()
+        );
+      }
+      return true;
+    });
+    const isMac = typeof navigator !== "undefined" ? /Mac|iP(hone|[oa]d)/u.test(navigator.platform) : false;
+    return {
+      "Mod-Enter": command,
+      "Shift-Enter": command,
+      ...isMac && { "Ctrl-Enter": command }
+    };
+  }
+  proseMirrorNodeName() {
+    return "hard_break";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      group: "inline",
+      inline: true,
+      parseDOM: [{ tag: "br" }],
+      selectable: false,
+      toDOM() {
+        return ["br"];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes() {
+    return [{ type: this.unistNodeName() }];
+  }
+  unistNodeName() {
+    return "break";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
 }
-
-;// CONCATENATED MODULE: external "prosemirror-state"
-var external_prosemirror_state_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_state_y = (x) => (() => (x))
-const external_prosemirror_state_namespaceObject = external_prosemirror_state_x({ ["Selection"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.Selection) });
-;// CONCATENATED MODULE: ./src/syntax-extensions/TextExtension.ts
-
-/**
- * @public
- */
-class TextExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorNodeName() {
-        return "text";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            group: "inline",
-        };
-    }
-    proseMirrorNodeToUnistNodes(node) {
-        var _a;
-        return [{ type: this.unistNodeName(), value: (_a = node.text) !== null && _a !== void 0 ? _a : "" }];
-    }
-    unistNodeName() {
-        return "text";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema) {
-        return [proseMirrorSchema.text(node.value)];
-    }
+class TextExtension extends NodeExtension {
+  proseMirrorNodeName() {
+    return "text";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      group: "inline"
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2) {
+    return [{ type: this.unistNodeName(), value: node2.text ?? "" }];
+  }
+  unistNodeName() {
+    return "text";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema) {
+    return [proseMirrorSchema.text(node2.value)];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/CodeBlockExtension.ts
-
-
-
-
-
-/**
- * @public
- */
-class CodeBlockExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    static liftOutOfCodeBlock() {
-        return (state, dispatch) => {
-            const { $from, $to } = state.selection;
-            if (
-            // Mustn't be a complex selection
-            !$from.sameParent($to) ||
-                // Must be in a code block
-                $from.parent.type.name !== "code_block" ||
-                // Must be at the end of the code block
-                $from.parentOffset !== $from.parent.content.size ||
-                // There must already be a preceding empty line
-                !$from.parent.textBetween(0, $from.parentOffset).endsWith("\n\n")) {
-                return false;
-            }
-            if (dispatch) {
-                const tr = state.tr;
-                dispatch(tr
-                    // Delete the preceding empty line
-                    .deleteRange($from.pos - 2, $from.pos)
-                    // Insert empty paragraph
-                    .insert($from.pos - 1, tr.doc.type.schema.nodes["paragraph"].create())
-                    // Put the cursor into the empty paragraph
-                    .setSelection(external_prosemirror_state_namespaceObject.Selection.near(tr.doc.resolve($from.pos), 1))
-                    .scrollIntoView());
-            }
-            return true;
-        };
-    }
-    dependencies() {
-        return [new TextExtension()];
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.textblockTypeInputRule)(/^\s{0,3}```$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-            (0,external_prosemirror_inputrules_namespaceObject.textblockTypeInputRule)(/^\s{4}$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            Enter: CodeBlockExtension.liftOutOfCodeBlock(),
-            "Shift-Mod-\\": (0,external_prosemirror_commands_namespaceObject.setBlockType)(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        };
-    }
-    proseMirrorNodeName() {
-        return "code_block";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            code: true,
-            content: "text*",
-            defining: true,
-            group: "block",
-            marks: "",
-            parseDOM: [{ preserveWhitespace: "full", tag: "pre" }],
-            toDOM() {
-                return ["pre", ["code", 0]];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [
-            {
-                type: this.unistNodeName(),
-                value: convertedChildren.map((child) => child.value).join(""),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "code";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, [proseMirrorSchema.text(node.value)]);
-    }
+class CodeBlockExtension extends NodeExtension {
+  static liftOutOfCodeBlock() {
+    return (state, dispatch) => {
+      const { $from, $to } = state.selection;
+      if (
+        // Mustn't be a complex selection
+        !$from.sameParent($to) || // Must be in a code block
+        $from.parent.type.name !== "code_block" || // Must be at the end of the code block
+        $from.parentOffset !== $from.parent.content.size || // There must already be a preceding empty line
+        !$from.parent.textBetween(0, $from.parentOffset).endsWith("\n\n")
+      ) {
+        return false;
+      }
+      if (dispatch) {
+        const tr = state.tr;
+        dispatch(
+          tr.deleteRange($from.pos - 2, $from.pos).insert(
+            $from.pos - 1,
+            tr.doc.type.schema.nodes["paragraph"].create()
+          ).setSelection(Selection.near(tr.doc.resolve($from.pos), 1)).scrollIntoView()
+        );
+      }
+      return true;
+    };
+  }
+  dependencies() {
+    return [new TextExtension()];
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      textblockTypeInputRule(
+        /^\s{0,3}```(?! )[^\n`]*\n$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      ),
+      textblockTypeInputRule(
+        /^\s{4}$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      Enter: CodeBlockExtension.liftOutOfCodeBlock(),
+      "Shift-Mod-\\": setBlockType(
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    };
+  }
+  proseMirrorNodeName() {
+    return "code_block";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      code: true,
+      content: "text*",
+      defining: true,
+      group: "block",
+      marks: "",
+      parseDOM: [{ preserveWhitespace: "full", tag: "pre" }],
+      toDOM() {
+        return ["pre", ["code", 0]];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [
+      {
+        type: this.unistNodeName(),
+        value: convertedChildren.map((child) => child.value).join("")
+      }
+    ];
+  }
+  unistNodeName() {
+    return "code";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      [proseMirrorSchema.text(node2.value)]
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/DefinitionExtension.ts
-
-/**
- * @public
- */
-class DefinitionExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorNodeName() {
-        return null;
-    }
-    proseMirrorNodeSpec() {
-        return null;
-    }
-    proseMirrorNodeToUnistNodes() {
-        return [];
-    }
-    unistNodeName() {
-        return "definition";
-    }
-    unistNodeToProseMirrorNodes(node, _proseMirrorSchema, _convertedChildren, context) {
-        if (context.DefinitionExtension === undefined) {
-            context.DefinitionExtension = { definitions: {} };
-        }
-        context.DefinitionExtension.definitions[node.identifier] = {
-            title: node.title,
-            url: node.url,
-        };
-        return [];
+class DefinitionExtension extends NodeExtension {
+  proseMirrorNodeName() {
+    return null;
+  }
+  proseMirrorNodeSpec() {
+    return null;
+  }
+  proseMirrorNodeToUnistNodes() {
+    return [];
+  }
+  unistNodeName() {
+    return "definition";
+  }
+  unistNodeToProseMirrorNodes(node2, _proseMirrorSchema, _convertedChildren, context) {
+    if (context.DefinitionExtension === void 0) {
+      context.DefinitionExtension = { definitions: {} };
     }
+    context.DefinitionExtension.definitions[node2.identifier] = {
+      title: node2.title,
+      url: node2.url
+    };
+    return [];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ParagraphExtension.ts
-
-/**
- * @public
- */
-class ParagraphExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorNodeName() {
-        return "paragraph";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            content: "inline*",
-            group: "block",
-            parseDOM: [{ tag: "p" }],
-            toDOM() {
-                return ["p", 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [{ children: convertedChildren, type: this.unistNodeName() }];
-    }
-    unistNodeName() {
-        return "paragraph";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
+class ParagraphExtension extends NodeExtension {
+  proseMirrorNodeName() {
+    return "paragraph";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      content: "inline*",
+      group: "block",
+      parseDOM: [{ tag: "p" }],
+      toDOM() {
+        return ["p", 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [{ children: convertedChildren, type: this.unistNodeName() }];
+  }
+  unistNodeName() {
+    return "paragraph";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/HeadingExtension.ts
-
-
-
-
-
-/**
- * @public
- */
-class HeadingExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    static headingLevelCommandBuilder(proseMirrorSchema, levelUpdate, onlyAtStart) {
-        return (state, dispatch, view) => {
-            if (onlyAtStart && !HeadingExtension.isAtStart(state, view)) {
-                return false;
-            }
-            const { $anchor } = state.selection;
-            const headingNode = $anchor.parent;
-            if (headingNode.type.name !== "heading") {
-                return false;
-            }
-            const newHeadingLevel = headingNode.attrs["level"] + levelUpdate;
-            if (newHeadingLevel < 0 || newHeadingLevel > 6) {
-                return false;
-            }
-            if (dispatch === undefined) {
-                return true;
-            }
-            const headingPosition = $anchor.before($anchor.depth);
-            if (newHeadingLevel > 0) {
-                dispatch(state.tr.setNodeMarkup(headingPosition, undefined, {
-                    level: newHeadingLevel,
-                }));
-            }
-            else {
-                dispatch(state.tr.setNodeMarkup(headingPosition, proseMirrorSchema.nodes["paragraph"]));
-            }
-            return true;
-        };
-    }
-    static isAtStart(state, view) {
-        if (!state.selection.empty) {
-            return false;
-        }
-        if (view !== undefined) {
-            return view.endOfTextblock("backward", state);
-        }
-        return state.selection.$anchor.parentOffset > 0;
-    }
-    dependencies() {
-        return [new ParagraphExtension(), new TextExtension()];
+class HeadingExtension extends NodeExtension {
+  static headingLevelCommandBuilder(proseMirrorSchema, levelUpdate, onlyAtStart) {
+    return (state, dispatch, view) => {
+      if (onlyAtStart && !HeadingExtension.isAtStart(state, view)) {
+        return false;
+      }
+      const { $anchor } = state.selection;
+      const headingNode = $anchor.parent;
+      if (headingNode.type.name !== "heading") {
+        return false;
+      }
+      const newHeadingLevel = headingNode.attrs["level"] + levelUpdate;
+      if (newHeadingLevel < 0 || newHeadingLevel > 6) {
+        return false;
+      }
+      if (dispatch === void 0) {
+        return true;
+      }
+      const headingPosition = $anchor.before($anchor.depth);
+      if (newHeadingLevel > 0) {
+        dispatch(
+          state.tr.setNodeMarkup(headingPosition, void 0, {
+            level: newHeadingLevel
+          })
+        );
+      } else {
+        dispatch(
+          state.tr.setNodeMarkup(
+            headingPosition,
+            proseMirrorSchema.nodes["paragraph"]
+          )
+        );
+      }
+      return true;
+    };
+  }
+  static isAtStart(state, view) {
+    if (!state.selection.empty) {
+      return false;
     }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.textblockTypeInputRule)(/^\s{0,3}(#{1,6})\s$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()], (match) => ({ level: match[1].length })),
-        ];
+    if (view !== void 0) {
+      return view.endOfTextblock("backward", state);
     }
-    proseMirrorKeymap(proseMirrorSchema) {
-        const keymap = {
-            // eslint-disable-next-line @typescript-eslint/naming-convention -- This is a key
-            "#": HeadingExtension.headingLevelCommandBuilder(proseMirrorSchema, +1, true),
-            Backspace: HeadingExtension.headingLevelCommandBuilder(proseMirrorSchema, -1, true),
-            "Shift-Tab": HeadingExtension.headingLevelCommandBuilder(proseMirrorSchema, -1, false),
-            Tab: HeadingExtension.headingLevelCommandBuilder(proseMirrorSchema, +1, false),
-        };
-        for (let i = 1; i <= 6; i++) {
-            keymap[`Shift-Mod-${i.toString()}`] = (0,external_prosemirror_commands_namespaceObject.setBlockType)(proseMirrorSchema.nodes[this.proseMirrorNodeName()], { level: i });
+    return state.selection.$anchor.parentOffset > 0;
+  }
+  dependencies() {
+    return [new ParagraphExtension(), new TextExtension()];
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      textblockTypeInputRule(
+        /^\s{0,3}(#{1,6})\s$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()],
+        (match) => ({ level: match[1].length })
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    const keymap = {
+      "#": HeadingExtension.headingLevelCommandBuilder(
+        proseMirrorSchema,
+        1,
+        true
+      ),
+      Backspace: HeadingExtension.headingLevelCommandBuilder(
+        proseMirrorSchema,
+        -1,
+        true
+      ),
+      "Shift-Tab": HeadingExtension.headingLevelCommandBuilder(
+        proseMirrorSchema,
+        -1,
+        false
+      ),
+      Tab: HeadingExtension.headingLevelCommandBuilder(
+        proseMirrorSchema,
+        1,
+        false
+      )
+    };
+    for (let i = 1; i <= 6; i++) {
+      keymap[`Shift-Mod-${i.toString()}`] = setBlockType(
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()],
+        { level: i }
+      );
+    }
+    return keymap;
+  }
+  proseMirrorNodeName() {
+    return "heading";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: { level: { default: 1 } },
+      content: "text*",
+      defining: true,
+      group: "block",
+      parseDOM: [
+        { attrs: { level: 1 }, tag: "h1" },
+        { attrs: { level: 2 }, tag: "h2" },
+        { attrs: { level: 3 }, tag: "h3" },
+        { attrs: { level: 4 }, tag: "h4" },
+        { attrs: { level: 5 }, tag: "h5" },
+        { attrs: { level: 6 }, tag: "h6" }
+      ],
+      toDOM(node2) {
+        return [`h${node2.attrs["level"].toString()}`, 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2, convertedChildren) {
+    return [
+      {
+        children: convertedChildren,
+        depth: node2.attrs["level"],
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "heading";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      {
+        level: node2.depth
+      }
+    );
+  }
+}
+class HorizontalRuleExtension extends NodeExtension {
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new InputRule(
+        /^\s{0,3}(?:\*\*\*|---|___)\n$/u,
+        (state, _, start, end) => state.tr.replaceWith(
+          start,
+          end,
+          createProseMirrorNode(
+            this.proseMirrorNodeName(),
+            proseMirrorSchema,
+            []
+          )
+        )
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      "Mod-_": (state, dispatch) => {
+        if (dispatch) {
+          dispatch(
+            state.tr.replaceSelectionWith(
+              proseMirrorSchema.nodes[this.proseMirrorNodeName()].create()
+            ).scrollIntoView()
+          );
         }
-        return keymap;
-    }
-    proseMirrorNodeName() {
-        return "heading";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: { level: { default: 1 } },
-            content: "text*",
-            defining: true,
-            group: "block",
-            parseDOM: [
-                { attrs: { level: 1 }, tag: "h1" },
-                { attrs: { level: 2 }, tag: "h2" },
-                { attrs: { level: 3 }, tag: "h3" },
-                { attrs: { level: 4 }, tag: "h4" },
-                { attrs: { level: 5 }, tag: "h5" },
-                { attrs: { level: 6 }, tag: "h6" },
-            ],
-            toDOM(node) {
-                return [`h${node.attrs["level"].toString()}`, 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node, convertedChildren) {
-        return [
-            {
-                children: convertedChildren,
-                depth: node.attrs["level"],
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "heading";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, {
-            level: node.depth,
-        });
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/HorizontalRuleExtension.ts
-
-
-/**
- * @public
- */
-class HorizontalRuleExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_inputrules_namespaceObject.InputRule(/^\s{0,3}(?:\*\*\*|---|___)\n$/u, (state, _, start, end) => state.tr.replaceWith(start, end, (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, []))),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            "Mod-_": (state, dispatch) => {
-                if (dispatch) {
-                    dispatch(state.tr
-                        .replaceSelectionWith(proseMirrorSchema.nodes[this.proseMirrorNodeName()].create())
-                        .scrollIntoView());
-                }
-                return true;
-            },
-        };
-    }
-    proseMirrorNodeName() {
-        return "horizontal_rule";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            group: "block",
-            parseDOM: [{ tag: "hr" }],
-            toDOM() {
-                return ["div", ["hr"]];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes() {
-        return [
-            {
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "thematicBreak";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ImageExtension.ts
-
-
-/**
- * @public
- */
-class ImageExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    dependencies() {
-        return [new ParagraphExtension()];
-    }
-    proseMirrorNodeName() {
-        return "image";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: {
-                alt: { default: null },
-                src: {},
-                title: { default: null },
-            },
-            draggable: true,
-            group: "inline",
-            inline: true,
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        return {
-                            alt: dom.getAttribute("alt"),
-                            src: dom.getAttribute("src"),
-                            title: dom.getAttribute("title"),
-                        };
-                    },
-                    tag: "img[src]",
-                },
-            ],
-            toDOM(node) {
-                return ["img", node.attrs];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node) {
-        return [
-            Object.assign(Object.assign({ type: this.unistNodeName(), url: node.attrs["src"] }, (node.attrs["alt"] !== null && { alt: node.attrs["alt"] })), (node.attrs["title"] !== null && {
-                title: node.attrs["title"],
-            })),
-        ];
-    }
-    unistNodeName() {
-        return "image";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, {
-            alt: node.alt,
-            src: node.url,
-            title: node.title,
-        });
-    }
+        return true;
+      }
+    };
+  }
+  proseMirrorNodeName() {
+    return "horizontal_rule";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      group: "block",
+      parseDOM: [{ tag: "hr" }],
+      toDOM() {
+        return ["div", ["hr"]];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes() {
+    return [
+      {
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "thematicBreak";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ImageReferenceExtension.ts
-
-
-
-/**
- * @public
- */
-class ImageReferenceExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    dependencies() {
-        return [new DefinitionExtension(), new ImageExtension()];
-    }
-    postUnistToProseMirrorHook(context) {
-        if (context.ImageReferenceExtension === undefined ||
-            context.DefinitionExtension === undefined) {
-            return;
-        }
-        for (const id in context.ImageReferenceExtension.proseMirrorNodes) {
-            if (!(id in context.DefinitionExtension.definitions)) {
-                continue;
-            }
-            const definition = context.DefinitionExtension.definitions[id];
-            const attrs = context.ImageReferenceExtension.proseMirrorNodes[id]
-                .attrs;
-            attrs["src"] = definition.url;
-            if (definition.title !== undefined) {
-                attrs["title"] = definition.title;
-            }
-        }
-    }
-    proseMirrorNodeName() {
-        return null;
-    }
-    proseMirrorNodeSpec() {
-        return null;
-    }
-    proseMirrorNodeToUnistNodes() {
-        return [];
-    }
-    unistNodeName() {
-        return "imageReference";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren, context) {
-        const proseMirrorNode = proseMirrorSchema.nodes["image"].createAndFill({ alt: node.alt, src: "", title: node.label }, convertedChildren);
-        if (proseMirrorNode === null) {
-            return [];
+class ImageExtension extends NodeExtension {
+  dependencies() {
+    return [new ParagraphExtension()];
+  }
+  proseMirrorNodeName() {
+    return "image";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: {
+        alt: { default: null },
+        src: {},
+        title: { default: null }
+      },
+      draggable: true,
+      group: "inline",
+      inline: true,
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            return {
+              alt: dom.getAttribute("alt"),
+              src: dom.getAttribute("src"),
+              title: dom.getAttribute("title")
+            };
+          },
+          tag: "img[src]"
         }
-        if (context.ImageReferenceExtension === undefined) {
-            context.ImageReferenceExtension = { proseMirrorNodes: {} };
+      ],
+      toDOM(node2) {
+        return ["img", node2.attrs];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2) {
+    return [
+      {
+        type: this.unistNodeName(),
+        url: node2.attrs["src"],
+        ...node2.attrs["alt"] !== null && { alt: node2.attrs["alt"] },
+        ...node2.attrs["title"] !== null && {
+          title: node2.attrs["title"]
         }
-        context.ImageReferenceExtension.proseMirrorNodes[node.identifier] =
-            proseMirrorNode;
-        return [proseMirrorNode];
-    }
-}
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/InlineCodeExtension.ts
-
-
-/**
- * @public
- */
-class InlineCodeExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode) {
-        return { type: this.unistNodeName(), value: convertedNode.value };
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/`([^\s](?:.*[^\s])?)`([\s\S])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
-        return {
-            "Ctrl-`": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-        };
-    }
-    proseMirrorMarkName() {
-        return "code";
-    }
-    proseMirrorMarkSpec() {
-        return {
-            inclusive: false,
-            parseDOM: [{ tag: "code" }],
-            toDOM() {
-                return ["code"];
-            },
-        };
-    }
-    unistNodeName() {
-        return "inlineCode";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema) {
-        return [
-            proseMirrorSchema
-                .text(node.value)
-                .mark([proseMirrorSchema.marks[this.proseMirrorMarkName()].create()]),
-        ];
-    }
+      }
+    ];
+  }
+  unistNodeName() {
+    return "image";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      {
+        alt: node2.alt,
+        src: node2.url,
+        title: node2.title
+      }
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ItalicExtension.ts
-
-
-/**
- * @public
- */
-class ItalicExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode) {
-        return { children: [convertedNode], type: this.unistNodeName() };
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/(?<!\*)\*([^\s*](?:.*[^\s])?)\*([^*])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/(?<!_)_([^\s_](?:.*[^\s])?)_([^_])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
-        return {
-            "Mod-i": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-            "Mod-I": (0,external_prosemirror_commands_namespaceObject.toggleMark)(markType),
-        };
-    }
-    proseMirrorMarkName() {
-        return "em";
+class ImageReferenceExtension extends NodeExtension {
+  dependencies() {
+    return [new DefinitionExtension(), new ImageExtension()];
+  }
+  postUnistToProseMirrorHook(context) {
+    if (context.ImageReferenceExtension === void 0 || context.DefinitionExtension === void 0) {
+      return;
     }
-    proseMirrorMarkSpec() {
-        return {
-            parseDOM: [
-                { tag: "i" },
-                { tag: "em" },
-                {
-                    getAttrs: (value) => value === "italic" && null,
-                    style: "font-style",
-                },
-            ],
-            toDOM() {
-                return ["em"];
-            },
-        };
+    for (const id in context.ImageReferenceExtension.proseMirrorNodes) {
+      if (!(id in context.DefinitionExtension.definitions)) {
+        continue;
+      }
+      const definition2 = context.DefinitionExtension.definitions[id];
+      const attrs = context.ImageReferenceExtension.proseMirrorNodes[id].attrs;
+      attrs["src"] = definition2.url;
+      if (definition2.title !== void 0) {
+        attrs["title"] = definition2.title;
+      }
     }
-    unistNodeName() {
-        return "emphasis";
+  }
+  proseMirrorNodeName() {
+    return null;
+  }
+  proseMirrorNodeSpec() {
+    return null;
+  }
+  proseMirrorNodeToUnistNodes() {
+    return [];
+  }
+  unistNodeName() {
+    return "imageReference";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren, context) {
+    const proseMirrorNode = proseMirrorSchema.nodes["image"].createAndFill(
+      { alt: node2.alt, src: "", title: node2.label },
+      convertedChildren
+    );
+    if (proseMirrorNode === null) {
+      return [];
     }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return convertedChildren.map((child) => child.mark(child.marks.concat([
-            proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),
-        ])));
+    if (context.ImageReferenceExtension === void 0) {
+      context.ImageReferenceExtension = { proseMirrorNodes: {} };
     }
+    context.ImageReferenceExtension.proseMirrorNodes[node2.identifier] = proseMirrorNode;
+    return [proseMirrorNode];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/LinkExtension.ts
-
-/**
- * @public
- */
-class LinkExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode, originalMark) {
-        return Object.assign(Object.assign({ type: this.unistNodeName(), url: originalMark.attrs["href"] }, (originalMark.attrs["title"] !== null && {
-            title: originalMark.attrs["title"],
-        })), { children: [convertedNode] });
-    }
-    proseMirrorMarkName() {
-        return "link";
-    }
-    proseMirrorMarkSpec() {
-        return {
-            attrs: { href: {}, title: { default: null } },
-            inclusive: false,
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        return {
-                            href: dom.getAttribute("href"),
-                            title: dom.getAttribute("title"),
-                        };
-                    },
-                    tag: "a[href]",
-                },
-            ],
-            toDOM(node) {
-                return ["a", node.attrs];
-            },
-        };
-    }
-    unistNodeName() {
-        return "link";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return convertedChildren.map((child) => child.mark(child.marks.concat([
-            proseMirrorSchema.marks[this.proseMirrorMarkName()].create({
-                href: node.url,
-                title: node.title,
-            }),
-        ])));
-    }
+class InlineCodeExtension extends MarkExtension {
+  processConvertedUnistNode(convertedNode) {
+    return { type: this.unistNodeName(), value: convertedNode.value };
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new MarkInputRule(
+        new RegExp("(?<!`)(?<b>`+)(?!`)(?<s> ?)(?<i>.*)\\k<s>(?<!`)\\k<b>(?<t>[^`])$", "u"),
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
+    return {
+      "Ctrl-`": toggleMark(markType)
+    };
+  }
+  proseMirrorMarkName() {
+    return "code";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      inclusive: false,
+      parseDOM: [{ tag: "code" }],
+      toDOM() {
+        return ["code", 0];
+      }
+    };
+  }
+  unistNodeName() {
+    return "inlineCode";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema) {
+    return [
+      proseMirrorSchema.text(node2.value).mark([proseMirrorSchema.marks[this.proseMirrorMarkName()].create()])
+    ];
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/LinkReferenceExtension.ts
-
-
-
-/**
- * @public
- */
-class LinkReferenceExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    dependencies() {
-        return [new DefinitionExtension(), new LinkExtension()];
-    }
-    postUnistToProseMirrorHook(context) {
-        if (context.LinkReferenceExtension === undefined ||
-            context.DefinitionExtension === undefined) {
-            return;
-        }
-        for (const id in context.LinkReferenceExtension.marks) {
-            if (!(id in context.DefinitionExtension.definitions)) {
-                continue;
-            }
-            const definition = context.DefinitionExtension.definitions[id];
-            const attrs = context.LinkReferenceExtension.marks[id].attrs;
-            attrs["href"] = definition.url;
-            if (definition.title !== undefined) {
-                attrs["title"] = definition.title;
-            }
-        }
-    }
-    processConvertedUnistNode(convertedNode) {
-        return convertedNode;
-    }
-    proseMirrorMarkName() {
-        return null;
-    }
-    proseMirrorMarkSpec() {
-        return null;
-    }
-    unistNodeName() {
-        return "linkReference";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren, context) {
-        const mark = proseMirrorSchema.marks["link"].create({
-            href: null,
-            title: null,
-        });
-        if (context.LinkReferenceExtension === undefined) {
-            context.LinkReferenceExtension = { marks: {} };
+class ItalicExtension extends MarkExtension {
+  processConvertedUnistNode(convertedNode) {
+    return { children: [convertedNode], type: this.unistNodeName() };
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new MarkInputRule(
+        new RegExp("(?<!\\*)\\*([^\\s*](?:.*[^\\s])?)\\*([^*])$", "u"),
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      ),
+      new MarkInputRule(
+        new RegExp("(?<!_)_([^\\s_](?:.*[^\\s])?)_([^_])$", "u"),
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];
+    return {
+      "Mod-i": toggleMark(markType),
+      "Mod-I": toggleMark(markType)
+    };
+  }
+  proseMirrorMarkName() {
+    return "em";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      parseDOM: [
+        { tag: "i" },
+        { tag: "em" },
+        {
+          getAttrs: (value) => value === "italic" && null,
+          style: "font-style"
         }
-        context.LinkReferenceExtension.marks[node.identifier] = mark;
-        return convertedChildren.map((child) => child.mark(child.marks.concat([mark])));
-    }
-}
-
-;// CONCATENATED MODULE: external "prosemirror-schema-list"
-var external_prosemirror_schema_list_x = (y) => {
-	var x = {}; __webpack_require__.d(x, y); return x
-} 
-var external_prosemirror_schema_list_y = (x) => (() => (x))
-const external_prosemirror_schema_list_namespaceObject = external_prosemirror_schema_list_x({ ["liftListItem"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.liftListItem), ["sinkListItem"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.sinkListItem), ["splitListItem"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.splitListItem), ["wrapInList"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.wrapInList) });
-;// CONCATENATED MODULE: ./src/syntax-extensions/ListItemExtension.ts
-
-
-/**
- * @public
- */
-class ListItemExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorKeymap(proseMirrorSchema) {
-        const nodeType = proseMirrorSchema.nodes[this.proseMirrorNodeName()];
-        return {
-            Enter: (0,external_prosemirror_schema_list_namespaceObject.splitListItem)(nodeType),
-            "Shift-Tab": (0,external_prosemirror_schema_list_namespaceObject.liftListItem)(nodeType),
-            Tab: (0,external_prosemirror_schema_list_namespaceObject.sinkListItem)(nodeType),
-        };
-    }
-    proseMirrorNodeName() {
-        return "regular_list_item";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            content: "paragraph block*",
-            defining: true,
-            group: "list_item",
-            parseDOM: [{ tag: "li" }],
-            toDOM() {
-                return ["li", 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [
-            {
-                children: convertedChildren,
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "listItem";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
-    }
-    unistToProseMirrorTest(node) {
-        return (node.type === this.unistNodeName() &&
-            (!("checked" in node) || typeof node.checked !== "boolean"));
-    }
+      ],
+      toDOM() {
+        return ["em", 0];
+      }
+    };
+  }
+  unistNodeName() {
+    return "emphasis";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return convertedChildren.map(
+      (child) => child.mark(
+        child.marks.concat([
+          proseMirrorSchema.marks[this.proseMirrorMarkName()].create()
+        ])
+      )
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/OrderedListExtension.ts
-
-
-
-
-/**
- * @public
- */
-class OrderedListExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    dependencies() {
-        return [new ListItemExtension()];
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.wrappingInputRule)(/^\s{0,3}(\d+)\.\s$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()], (match) => ({ start: +match[1] }), (match, node) => node.childCount + node.attrs["start"] === +match[1]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            "Shift-Mod-9": (0,external_prosemirror_schema_list_namespaceObject.wrapInList)(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        };
-    }
-    proseMirrorNodeName() {
-        return "ordered_list";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: { spread: { default: false }, start: { default: 1 } },
-            content: "list_item+",
-            group: "block",
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        const start = dom.getAttribute("start");
-                        return {
-                            spread: dom.getAttribute("data-spread") === "true",
-                            start: start !== null ? parseInt(start, 10) : 1,
-                        };
-                    },
-                    tag: "ol",
-                },
-            ],
-            toDOM(node) {
-                return [
-                    "ol",
-                    {
-                        "data-spread": node.attrs["spread"],
-                        start: node.attrs["start"],
-                    },
-                    0,
-                ];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node, convertedChildren) {
-        const spread = node.attrs["spread"];
-        return [
-            {
-                children: convertedChildren.map((child) => {
-                    child.spread = spread;
-                    return child;
-                }),
-                ordered: true,
-                spread,
-                start: node.attrs["start"],
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "list";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        var _a;
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, {
-            spread: node.spread,
-            start: (_a = node.start) !== null && _a !== void 0 ? _a : 1,
-        });
-    }
-    unistToProseMirrorTest(node) {
-        return (node.type === this.unistNodeName() && node.ordered === true);
-    }
+class LinkExtension extends MarkExtension {
+  processConvertedUnistNode(convertedNode, originalMark) {
+    return {
+      type: this.unistNodeName(),
+      url: originalMark.attrs["href"],
+      ...originalMark.attrs["title"] !== null && {
+        title: originalMark.attrs["title"]
+      },
+      children: [convertedNode]
+    };
+  }
+  proseMirrorMarkName() {
+    return "link";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      attrs: { href: {}, title: { default: null } },
+      inclusive: false,
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            return {
+              href: dom.getAttribute("href"),
+              title: dom.getAttribute("title")
+            };
+          },
+          tag: "a[href]"
+        }
+      ],
+      toDOM(node2) {
+        return ["a", node2.attrs, 0];
+      }
+    };
+  }
+  unistNodeName() {
+    return "link";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return convertedChildren.map(
+      (child) => child.mark(
+        child.marks.concat([
+          proseMirrorSchema.marks[this.proseMirrorMarkName()].create({
+            href: node2.url,
+            title: node2.title
+          })
+        ])
+      )
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/RootExtension.ts
-
-/**
- * @public
- */
-class RootExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    proseMirrorNodeName() {
-        return "doc";
-    }
-    proseMirrorNodeSpec() {
-        return { content: "block+" };
-    }
-    proseMirrorNodeToUnistNodes(_node, convertedChildren) {
-        return [{ children: convertedChildren, type: this.unistNodeName() }];
+class LinkReferenceExtension extends MarkExtension {
+  dependencies() {
+    return [new DefinitionExtension(), new LinkExtension()];
+  }
+  postUnistToProseMirrorHook(context) {
+    if (context.LinkReferenceExtension === void 0 || context.DefinitionExtension === void 0) {
+      return;
     }
-    unistNodeName() {
-        return "root";
+    for (const id in context.LinkReferenceExtension.marks) {
+      if (!(id in context.DefinitionExtension.definitions)) {
+        continue;
+      }
+      const definition2 = context.DefinitionExtension.definitions[id];
+      const attrs = context.LinkReferenceExtension.marks[id].attrs;
+      attrs["href"] = definition2.url;
+      if (definition2.title !== void 0) {
+        attrs["title"] = definition2.title;
+      }
     }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren);
+  }
+  processConvertedUnistNode(convertedNode) {
+    return convertedNode;
+  }
+  proseMirrorMarkName() {
+    return null;
+  }
+  proseMirrorMarkSpec() {
+    return null;
+  }
+  unistNodeName() {
+    return "linkReference";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren, context) {
+    const mark = proseMirrorSchema.marks["link"].create({
+      href: null,
+      title: null
+    });
+    if (context.LinkReferenceExtension === void 0) {
+      context.LinkReferenceExtension = { marks: {} };
     }
+    context.LinkReferenceExtension.marks[node2.identifier] = mark;
+    return convertedChildren.map(
+      (child) => child.mark(child.marks.concat([mark]))
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/UnorderedListExtension.ts
-
-
-
-
-/**
- * @public
- */
-class UnorderedListExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    dependencies() {
-        return [new ListItemExtension()];
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            (0,external_prosemirror_inputrules_namespaceObject.wrappingInputRule)(/^\s{0,3}([-+*])\s$/u, proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            "Shift-Mod-8": (0,external_prosemirror_schema_list_namespaceObject.wrapInList)(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),
-        };
-    }
-    proseMirrorNodeName() {
-        return "bullet_list";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: { spread: { default: false } },
-            content: "list_item+",
-            group: "block",
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        return {
-                            spread: dom.getAttribute("data-spread") === "true",
-                        };
-                    },
-                    tag: "ul",
-                },
-            ],
-            toDOM(node) {
-                return ["ul", { "data-spread": node.attrs["spread"] }, 0];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node, convertedChildren) {
-        const spread = node.attrs["spread"];
-        return [
-            {
-                children: convertedChildren.map((child) => {
-                    child.spread = spread;
-                    return child;
-                }),
-                ordered: false,
-                spread,
-                type: this.unistNodeName(),
-            },
-        ];
-    }
-    unistNodeName() {
-        return "list";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, {
-            spread: node.spread,
-        });
-    }
-    unistToProseMirrorTest(node) {
-        return (node.type === this.unistNodeName() && node.ordered !== true);
-    }
+class ListItemExtension extends NodeExtension {
+  proseMirrorKeymap(proseMirrorSchema) {
+    const nodeType = proseMirrorSchema.nodes[this.proseMirrorNodeName()];
+    return {
+      Enter: splitListItem(nodeType),
+      "Shift-Tab": liftListItem(nodeType),
+      Tab: sinkListItem(nodeType)
+    };
+  }
+  proseMirrorNodeName() {
+    return "regular_list_item";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      content: "paragraph block*",
+      defining: true,
+      group: "list_item",
+      parseDOM: [{ tag: "li" }],
+      toDOM() {
+        return ["li", 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [
+      {
+        children: convertedChildren,
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "listItem";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
+  unistToProseMirrorTest(node2) {
+    return node2.type === this.unistNodeName() && (!("checked" in node2) || typeof node2.checked !== "boolean");
+  }
 }
-
-;// CONCATENATED MODULE: ./src/MarkdownExtension.ts
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-/**
- * @public
- */
-class MarkdownExtension extends external_prosemirror_unified_namespaceObject.Extension {
-    dependencies() {
+class OrderedListExtension extends NodeExtension {
+  dependencies() {
+    return [new ListItemExtension()];
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      wrappingInputRule(
+        /^\s{0,3}(\d+)\.\s$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()],
+        (match) => ({ start: +match[1] }),
+        (match, node2) => node2.childCount + node2.attrs["start"] === +match[1]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      "Shift-Mod-9": wrapInList(
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    };
+  }
+  proseMirrorNodeName() {
+    return "ordered_list";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: { spread: { default: false }, start: { default: 1 } },
+      content: "list_item+",
+      group: "block",
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            const start = dom.getAttribute("start");
+            return {
+              spread: dom.getAttribute("data-spread") === "true",
+              start: start !== null ? parseInt(start, 10) : 1
+            };
+          },
+          tag: "ol"
+        }
+      ],
+      toDOM(node2) {
         return [
-            // ParagraphExtension needs to be first so that it is the default block.
-            new ParagraphExtension(),
-            new BlockquoteExtension(),
-            new BoldExtension(),
-            new BreakExtension(),
-            new CodeBlockExtension(),
-            new DefinitionExtension(),
-            new HeadingExtension(),
-            new HorizontalRuleExtension(),
-            new ImageExtension(),
-            new ImageReferenceExtension(),
-            new InlineCodeExtension(),
-            new ItalicExtension(),
-            new LinkExtension(),
-            new LinkReferenceExtension(),
-            new ListItemExtension(),
-            new OrderedListExtension(),
-            new RootExtension(),
-            new TextExtension(),
-            new UnorderedListExtension(),
+          "ol",
+          {
+            "data-spread": node2.attrs["spread"],
+            start: node2.attrs["start"]
+          },
+          0
         ];
-    }
-    unifiedInitializationHook(processor) {
-        return processor.use(external_remark_parse_namespaceObject["default"]).use(external_remark_stringify_namespaceObject["default"], {
-            fences: true,
-            listItemIndent: "one",
-            resourceLink: true,
-            rule: "-",
-        });
-    }
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2, convertedChildren) {
+    const spread = node2.attrs["spread"];
+    return [
+      {
+        children: convertedChildren.map((child) => {
+          child.spread = spread;
+          return child;
+        }),
+        ordered: true,
+        spread,
+        start: node2.attrs["start"],
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "list";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      {
+        spread: node2.spread,
+        start: node2.start ?? 1
+      }
+    );
+  }
+  unistToProseMirrorTest(node2) {
+    return node2.type === this.unistNodeName() && node2.ordered === true;
+  }
+}
+class RootExtension extends NodeExtension {
+  proseMirrorNodeName() {
+    return "doc";
+  }
+  proseMirrorNodeSpec() {
+    return { content: "block+" };
+  }
+  proseMirrorNodeToUnistNodes(_node, convertedChildren) {
+    return [{ children: convertedChildren, type: this.unistNodeName() }];
+  }
+  unistNodeName() {
+    return "root";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren
+    );
+  }
+}
+class UnorderedListExtension extends NodeExtension {
+  dependencies() {
+    return [new ListItemExtension()];
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      wrappingInputRule(
+        /^\s{0,3}([-+*])\s$/u,
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      "Shift-Mod-8": wrapInList(
+        proseMirrorSchema.nodes[this.proseMirrorNodeName()]
+      )
+    };
+  }
+  proseMirrorNodeName() {
+    return "bullet_list";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: { spread: { default: false } },
+      content: "list_item+",
+      group: "block",
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            return {
+              spread: dom.getAttribute("data-spread") === "true"
+            };
+          },
+          tag: "ul"
+        }
+      ],
+      toDOM(node2) {
+        return ["ul", { "data-spread": node2.attrs["spread"] }, 0];
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2, convertedChildren) {
+    const spread = node2.attrs["spread"];
+    return [
+      {
+        children: convertedChildren.map((child) => {
+          child.spread = spread;
+          return child;
+        }),
+        ordered: false,
+        spread,
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  unistNodeName() {
+    return "list";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      {
+        spread: node2.spread
+      }
+    );
+  }
+  unistToProseMirrorTest(node2) {
+    return node2.type === this.unistNodeName() && node2.ordered !== true;
+  }
+}
+class MarkdownExtension extends Extension {
+  dependencies() {
+    return [
+      // ParagraphExtension needs to be first so that it is the default block.
+      new ParagraphExtension(),
+      new BlockquoteExtension(),
+      new BoldExtension(),
+      new BreakExtension(),
+      new CodeBlockExtension(),
+      new DefinitionExtension(),
+      new HeadingExtension(),
+      new HorizontalRuleExtension(),
+      new ImageExtension(),
+      new ImageReferenceExtension(),
+      new InlineCodeExtension(),
+      new ItalicExtension(),
+      new LinkExtension(),
+      new LinkReferenceExtension(),
+      new ListItemExtension(),
+      new OrderedListExtension(),
+      new RootExtension(),
+      new TextExtension(),
+      new UnorderedListExtension()
+    ];
+  }
+  unifiedInitializationHook(processor) {
+    return processor.use(remarkParse).use(remarkStringify, {
+      fences: true,
+      listItemIndent: "one",
+      resourceLink: true,
+      rule: "-"
+    });
+  }
 }
-
-;// CONCATENATED MODULE: ./node_modules/ccount/index.js
-/**
- * Count how often a character (or substring) is used in a string.
- *
- * @param {string} value
- *   Value to search in.
- * @param {string} character
- *   Character (or substring) to look for.
- * @return {number}
- *   Number of times `character` occurred in `value`.
- */
 function ccount(value, character) {
-  const source = String(value)
-
-  if (typeof character !== 'string') {
-    throw new TypeError('Expected character')
-  }
-
-  let count = 0
-  let index = source.indexOf(character)
-
+  const source = String(value);
+  if (typeof character !== "string") {
+    throw new TypeError("Expected character");
+  }
+  let count = 0;
+  let index = source.indexOf(character);
   while (index !== -1) {
-    count++
-    index = source.indexOf(character, index + character.length)
-  }
-
-  return count
-}
-
-;// CONCATENATED MODULE: ./node_modules/devlop/lib/default.js
-function deprecate(fn) {
-  return fn
-}
-
-function equal() {}
-
-function ok() {}
-
-function unreachable() {}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-util-character/index.js
-/**
- * @typedef {import('micromark-util-types').Code} Code
- */
-
-/**
- * Check whether the character code represents an ASCII alpha (`a` through `z`,
- * case insensitive).
- *
- * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.
- *
- * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)
- * to U+005A (`Z`).
- *
- * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)
- * to U+007A (`z`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
+    count++;
+    index = source.indexOf(character, index + character.length);
+  }
+  return count;
+}
+function ok$1() {
+}
 const asciiAlpha = regexCheck(/[A-Za-z]/);
-
-/**
- * Check whether the character code represents an ASCII alphanumeric (`a`
- * through `z`, case insensitive, or `0` through `9`).
- *
- * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha
- * (see `asciiAlpha`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
 const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
-
-/**
- * Check whether the character code represents an ASCII atext.
- *
- * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in
- * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),
- * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F
- * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E
- * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE
- * (`{`) to U+007E TILDE (`~`).
- *
- * See:
- * **\[RFC5322]**:
- * [Internet Message Format](https://tools.ietf.org/html/rfc5322).
- * P. Resnick.
- * IETF.
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
-
-/**
- * Check whether a character code is an ASCII control character.
- *
- * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)
- * to U+001F (US), or U+007F (DEL).
- *
- * @param {Code} code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-function asciiControl(code) {
+function asciiControl(code2) {
   return (
     // Special whitespace codes (which have negative values), C0 and Control
     // character DEL
-    code !== null && (code < 32 || code === 127)
+    code2 !== null && (code2 < 32 || code2 === 127)
   );
 }
-
-/**
- * Check whether the character code represents an ASCII digit (`0` through `9`).
- *
- * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to
- * U+0039 (`9`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-const asciiDigit = regexCheck(/\d/);
-
-/**
- * Check whether the character code represents an ASCII hex digit (`a` through
- * `f`, case insensitive, or `0` through `9`).
- *
- * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex
- * digit, or an ASCII lower hex digit.
- *
- * An **ASCII upper hex digit** is a character in the inclusive range U+0041
- * (`A`) to U+0046 (`F`).
- *
- * An **ASCII lower hex digit** is a character in the inclusive range U+0061
- * (`a`) to U+0066 (`f`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
-
-/**
- * Check whether the character code represents ASCII punctuation.
- *
- * An **ASCII punctuation** is a character in the inclusive ranges U+0021
- * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT
- * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT
- * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).
- *
- * @param code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
-
-/**
- * Check whether a character code is a markdown line ending.
- *
- * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN
- * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).
- *
- * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE
- * RETURN (CR) are replaced by these virtual characters depending on whether
- * they occurred together.
- *
- * @param {Code} code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-function markdownLineEnding(code) {
-  return code !== null && code < -2;
-}
-
-/**
- * Check whether a character code is a markdown line ending (see
- * `markdownLineEnding`) or markdown space (see `markdownSpace`).
- *
- * @param {Code} code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-function markdownLineEndingOrSpace(code) {
-  return code !== null && (code < 0 || code === 32);
-}
-
-/**
- * Check whether a character code is a markdown space.
- *
- * A **markdown space** is the concrete character U+0020 SPACE (SP) and the
- * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).
- *
- * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is
- * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL
- * SPACE (VS) characters, depending on the column at which the tab occurred.
- *
- * @param {Code} code
- *   Code.
- * @returns {boolean}
- *   Whether it matches.
- */
-function markdownSpace(code) {
-  return code === -2 || code === -1 || code === 32;
-}
-
-// Size note: removing ASCII from the regex and using `asciiPunctuation` here
-// In fact adds to the bundle size.
-/**
- * Check whether the character code represents Unicode punctuation.
- *
- * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,
- * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`
- * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`
- * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII
- * punctuation (see `asciiPunctuation`).
- *
- * See:
- * **\[UNICODE]**:
- * [The Unicode Standard](https://www.unicode.org/versions/).
- * Unicode Consortium.
- *
- * @param code
- *   Code.
- * @returns
- *   Whether it matches.
- */
-const unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
-
-/**
- * Check whether the character code represents Unicode whitespace.
- *
- * Note that this does handle micromark specific markdown whitespace characters.
- * See `markdownLineEndingOrSpace` to check that.
- *
- * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,
- * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),
- * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\[UNICODE]**).
- *
- * See:
- * **\[UNICODE]**:
- * [The Unicode Standard](https://www.unicode.org/versions/).
- * Unicode Consortium.
- *
- * @param code
- *   Code.
- * @returns
- *   Whether it matches.
- */
+function markdownLineEnding(code2) {
+  return code2 !== null && code2 < -2;
+}
+function markdownLineEndingOrSpace(code2) {
+  return code2 !== null && (code2 < 0 || code2 === 32);
+}
+function markdownSpace(code2) {
+  return code2 === -2 || code2 === -1 || code2 === 32;
+}
+const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
 const unicodeWhitespace = regexCheck(/\s/);
-
-/**
- * Create a code check from a regex.
- *
- * @param {RegExp} regex
- * @returns {(code: Code) => boolean}
- */
 function regexCheck(regex) {
   return check;
-
-  /**
-   * Check whether a code matches the bound regex.
-   *
-   * @param {Code} code
-   *   Character code.
-   * @returns {boolean}
-   *   Whether the character code matches the bound regex.
-   */
-  function check(code) {
-    return code !== null && code > -1 && regex.test(String.fromCharCode(code));
+  function check(code2) {
+    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
   }
 }
-;// CONCATENATED MODULE: ./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
 function escapeStringRegexp(string) {
-	if (typeof string !== 'string') {
-		throw new TypeError('Expected a string');
-	}
-
-	// Escape characters with special meaning either inside or outside character sets.
-	// Use a simple backslash escape when its always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
-	return string
-		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
-		.replace(/-/g, '\\x2d');
-}
-
-;// CONCATENATED MODULE: ./node_modules/unist-util-is/lib/index.js
-/**
- * @typedef {import('unist').Node} Node
- * @typedef {import('unist').Parent} Parent
- */
-
-/**
- * @template Fn
- * @template Fallback
- * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate
- */
-
-/**
- * @callback Check
- *   Check that an arbitrary value is a node.
- * @param {unknown} this
- *   The given context.
- * @param {unknown} [node]
- *   Anything (typically a node).
- * @param {number | null | undefined} [index]
- *   The nodes position in its parent.
- * @param {Parent | null | undefined} [parent]
- *   The nodes parent.
- * @returns {boolean}
- *   Whether this is a node and passes a test.
- *
- * @typedef {Record<string, unknown> | Node} Props
- *   Object to check for equivalence.
- *
- *   Note: `Node` is included as it is common but is not indexable.
- *
- * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test
- *   Check for an arbitrary node.
- *
- * @callback TestFunction
- *   Check if a node passes a test.
- * @param {unknown} this
- *   The given context.
- * @param {Node} node
- *   A node.
- * @param {number | undefined} [index]
- *   The nodes position in its parent.
- * @param {Parent | undefined} [parent]
- *   The nodes parent.
- * @returns {boolean | undefined | void}
- *   Whether this node passes the test.
- *
- *   Note: `void` is included until TS sees no return as `undefined`.
- */
-
-/**
- * Check if `node` is a `Node` and whether it passes the given test.
- *
- * @param {unknown} node
- *   Thing to check, typically `Node`.
- * @param {Test} test
- *   A check for a specific node.
- * @param {number | null | undefined} index
- *   The nodes position in its parent.
- * @param {Parent | null | undefined} parent
- *   The nodes parent.
- * @param {unknown} context
- *   Context object (`this`) to pass to `test` functions.
- * @returns {boolean}
- *   Whether `node` is a node and passes a test.
- */
-const is =
-  // Note: overloads in JSDoc cant yet use different `@template`s.
-  /**
-   * @type {(
-   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
-   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
-   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
-   *   ((node?: null | undefined) => false) &
-   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
-   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)
-   * )}
-   */
-  (
-    /**
-     * @param {unknown} [node]
-     * @param {Test} [test]
-     * @param {number | null | undefined} [index]
-     * @param {Parent | null | undefined} [parent]
-     * @param {unknown} [context]
-     * @returns {boolean}
-     */
-    // eslint-disable-next-line max-params
-    function (node, test, index, parent, context) {
-      const check = convert(test)
-
-      if (
-        index !== undefined &&
-        index !== null &&
-        (typeof index !== 'number' ||
-          index < 0 ||
-          index === Number.POSITIVE_INFINITY)
-      ) {
-        throw new Error('Expected positive finite index')
-      }
-
-      if (
-        parent !== undefined &&
-        parent !== null &&
-        (!is(parent) || !parent.children)
-      ) {
-        throw new Error('Expected parent node')
-      }
-
-      if (
-        (parent === undefined || parent === null) !==
-        (index === undefined || index === null)
-      ) {
-        throw new Error('Expected both parent and index')
-      }
-
-      return looksLikeANode(node)
-        ? check.call(context, node, index, parent)
-        : false
-    }
-  )
-
-/**
- * Generate an assertion from a test.
- *
- * Useful if youre going to test many nodes, for example when creating a
- * utility where something else passes a compatible test.
- *
- * The created function is a bit faster because it expects valid input only:
- * a `node`, `index`, and `parent`.
- *
- * @param {Test} test
- *   *   when nullish, checks if `node` is a `Node`.
- *   *   when `string`, works like passing `(node) => node.type === test`.
- *   *   when `function` checks if function passed the node is true.
- *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
- *   *   when `array`, checks if any one of the subtests pass.
- * @returns {Check}
- *   An assertion.
- */
-const convert =
+  if (typeof string !== "string") {
+    throw new TypeError("Expected a string");
+  }
+  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
+}
+const convert = (
   // Note: overloads in JSDoc cant yet use different `@template`s.
   /**
    * @type {(
@@ -1623,850 +1115,268 @@ const convert =
    *   ((test?: Test) => Check)
    * )}
    */
-  (
-    /**
-     * @param {Test} [test]
-     * @returns {Check}
-     */
-    function (test) {
-      if (test === null || test === undefined) {
-        return lib_ok
-      }
-
-      if (typeof test === 'function') {
-        return castFactory(test)
-      }
-
-      if (typeof test === 'object') {
-        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
-      }
-
-      if (typeof test === 'string') {
-        return typeFactory(test)
-      }
-
-      throw new Error('Expected function, string, or object as test')
+  /**
+   * @param {Test} [test]
+   * @returns {Check}
+   */
+  function(test) {
+    if (test === null || test === void 0) {
+      return ok;
+    }
+    if (typeof test === "function") {
+      return castFactory(test);
+    }
+    if (typeof test === "object") {
+      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
     }
-  )
-
-/**
- * @param {Array<Props | TestFunction | string>} tests
- * @returns {Check}
- */
+    if (typeof test === "string") {
+      return typeFactory(test);
+    }
+    throw new Error("Expected function, string, or object as test");
+  }
+);
 function anyFactory(tests) {
-  /** @type {Array<Check>} */
-  const checks = []
-  let index = -1
-
+  const checks = [];
+  let index = -1;
   while (++index < tests.length) {
-    checks[index] = convert(tests[index])
+    checks[index] = convert(tests[index]);
   }
-
-  return castFactory(any)
-
-  /**
-   * @this {unknown}
-   * @type {TestFunction}
-   */
+  return castFactory(any);
   function any(...parameters) {
-    let index = -1
-
-    while (++index < checks.length) {
-      if (checks[index].apply(this, parameters)) return true
+    let index2 = -1;
+    while (++index2 < checks.length) {
+      if (checks[index2].apply(this, parameters)) return true;
     }
-
-    return false
+    return false;
   }
 }
-
-/**
- * Turn an object into a test for a node with a certain fields.
- *
- * @param {Props} check
- * @returns {Check}
- */
 function propsFactory(check) {
-  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)
-
-  return castFactory(all)
-
-  /**
-   * @param {Node} node
-   * @returns {boolean}
-   */
-  function all(node) {
-    const nodeAsRecord = /** @type {Record<string, unknown>} */ (
-      /** @type {unknown} */ (node)
-    )
-
-    /** @type {string} */
-    let key
-
+  const checkAsRecord = (
+    /** @type {Record<string, unknown>} */
+    check
+  );
+  return castFactory(all2);
+  function all2(node2) {
+    const nodeAsRecord = (
+      /** @type {Record<string, unknown>} */
+      /** @type {unknown} */
+      node2
+    );
+    let key;
     for (key in check) {
-      if (nodeAsRecord[key] !== checkAsRecord[key]) return false
+      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
     }
-
-    return true
+    return true;
   }
 }
-
-/**
- * Turn a string into a test for a node with a certain type.
- *
- * @param {string} check
- * @returns {Check}
- */
 function typeFactory(check) {
-  return castFactory(type)
-
-  /**
-   * @param {Node} node
-   */
-  function type(node) {
-    return node && node.type === check
+  return castFactory(type);
+  function type(node2) {
+    return node2 && node2.type === check;
   }
 }
-
-/**
- * Turn a custom test into a test for a node that passes that test.
- *
- * @param {TestFunction} testFunction
- * @returns {Check}
- */
 function castFactory(testFunction) {
-  return check
-
-  /**
-   * @this {unknown}
-   * @type {Check}
-   */
+  return check;
   function check(value, index, parent) {
     return Boolean(
-      looksLikeANode(value) &&
-        testFunction.call(
-          this,
-          value,
-          typeof index === 'number' ? index : undefined,
-          parent || undefined
-        )
-    )
+      looksLikeANode(value) && testFunction.call(
+        this,
+        value,
+        typeof index === "number" ? index : void 0,
+        parent || void 0
+      )
+    );
   }
 }
-
-function lib_ok() {
-  return true
+function ok() {
+  return true;
 }
-
-/**
- * @param {unknown} value
- * @returns {value is Node}
- */
 function looksLikeANode(value) {
-  return value !== null && typeof value === 'object' && 'type' in value
-}
-
-;// CONCATENATED MODULE: ./node_modules/unist-util-visit-parents/lib/color.js
-/**
- * @param {string} d
- * @returns {string}
- */
+  return value !== null && typeof value === "object" && "type" in value;
+}
 function color(d) {
-  return d
-}
-
-;// CONCATENATED MODULE: ./node_modules/unist-util-visit-parents/lib/index.js
-/**
- * @typedef {import('unist').Node} UnistNode
- * @typedef {import('unist').Parent} UnistParent
- */
-
-/**
- * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test
- *   Test from `unist-util-is`.
- *
- *   Note: we have remove and add `undefined`, because otherwise when generating
- *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,
- *   which doesnt work when publishing on npm.
- */
-
-/**
- * @typedef {(
- *   Fn extends (value: any) => value is infer Thing
- *   ? Thing
- *   : Fallback
- * )} Predicate
- *   Get the value of a type guard `Fn`.
- * @template Fn
- *   Value; typically function that is a type guard (such as `(x): x is Y`).
- * @template Fallback
- *   Value to yield if `Fn` is not a type guard.
- */
-
-/**
- * @typedef {(
- *   Check extends null | undefined // No test.
- *   ? Value
- *   : Value extends {type: Check} // String (type) test.
- *   ? Value
- *   : Value extends Check // Partial test.
- *   ? Value
- *   : Check extends Function // Function test.
- *   ? Predicate<Check, Value> extends Value
- *     ? Predicate<Check, Value>
- *     : never
- *   : never // Some other test?
- * )} MatchesOne
- *   Check whether a node matches a primitive check in the type system.
- * @template Value
- *   Value; typically unist `Node`.
- * @template Check
- *   Value; typically `unist-util-is`-compatible test, but not arrays.
- */
-
-/**
- * @typedef {(
- *   Check extends Array<any>
- *   ? MatchesOne<Value, Check[keyof Check]>
- *   : MatchesOne<Value, Check>
- * )} Matches
- *   Check whether a node matches a check in the type system.
- * @template Value
- *   Value; typically unist `Node`.
- * @template Check
- *   Value; typically `unist-util-is`-compatible test.
- */
-
-/**
- * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint
- *   Number; capped reasonably.
- */
-
-/**
- * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment
- *   Increment a number in the type system.
- * @template {Uint} [I=0]
- *   Index.
- */
-
-/**
- * @typedef {(
- *   Node extends UnistParent
- *   ? Node extends {children: Array<infer Children>}
- *     ? Child extends Children ? Node : never
- *     : never
- *   : never
- * )} InternalParent
- *   Collect nodes that can be parents of `Child`.
- * @template {UnistNode} Node
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent
- *   Collect nodes in `Tree` that can be parents of `Child`.
- * @template {UnistNode} Tree
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {(
- *   Depth extends Max
- *   ? never
- *   :
- *     | InternalParent<Node, Child>
- *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>
- * )} InternalAncestor
- *   Collect nodes in `Tree` that can be ancestors of `Child`.
- * @template {UnistNode} Node
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- * @template {Uint} [Max=10]
- *   Max; searches up to this depth.
- * @template {Uint} [Depth=0]
- *   Current depth.
- */
-
-/**
- * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor
- *   Collect nodes in `Tree` that can be ancestors of `Child`.
- * @template {UnistNode} Tree
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {(
- *   Tree extends UnistParent
- *     ? Depth extends Max
- *       ? Tree
- *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>
- *     : Tree
- * )} InclusiveDescendant
- *   Collect all (inclusive) descendants of `Tree`.
- *
- *   >  **Note**: for performance reasons, this seems to be the fastest way to
- *   > recurse without actually running into an infinite loop, which the
- *   > previous version did.
- *   >
- *   > Practically, a max of `2` is typically enough assuming a `Root` is
- *   > passed, but it doesnt improve performance.
- *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.
- *   > Using up to `10` doesnt hurt or help either.
- * @template {UnistNode} Tree
- *   Tree type.
- * @template {Uint} [Max=10]
- *   Max; searches up to this depth.
- * @template {Uint} [Depth=0]
- *   Current depth.
- */
-
-/**
- * @typedef {'skip' | boolean} Action
- *   Union of the action types.
- *
- * @typedef {number} Index
- *   Move to the sibling at `index` next (after node itself is completely
- *   traversed).
- *
- *   Useful if mutating the tree, such as removing the node the visitor is
- *   currently on, or any of its previous siblings.
- *   Results less than 0 or greater than or equal to `children.length` stop
- *   traversing the parent.
- *
- * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple
- *   List with one or two values, the first an action, the second an index.
- *
- * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult
- *   Any value that can be returned from a visitor.
- */
-
-/**
- * @callback Visitor
- *   Handle a node (matching `test`, if given).
- *
- *   Visitors are free to transform `node`.
- *   They can also transform the parent of node (the last of `ancestors`).
- *
- *   Replacing `node` itself, if `SKIP` is not returned, still causes its
- *   descendants to be walked (which is a bug).
- *
- *   When adding or removing previous siblings of `node` (or next siblings, in
- *   case of reverse), the `Visitor` should return a new `Index` to specify the
- *   sibling to traverse after `node` is traversed.
- *   Adding or removing next siblings of `node` (or previous siblings, in case
- *   of reverse) is handled as expected without needing to return a new `Index`.
- *
- *   Removing the children property of an ancestor still results in them being
- *   traversed.
- * @param {Visited} node
- *   Found node.
- * @param {Array<VisitedParents>} ancestors
- *   Ancestors of `node`.
- * @returns {VisitorResult}
- *   What to do next.
- *
- *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
- *   An `Action` is treated as a tuple of `[Action]`.
- *
- *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
- *   When the `Action` is `EXIT`, that action can be returned.
- *   When the `Action` is `CONTINUE`, `Index` can be returned.
- * @template {UnistNode} [Visited=UnistNode]
- *   Visited node type.
- * @template {UnistParent} [VisitedParents=UnistParent]
- *   Ancestor type.
- */
-
-/**
- * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor
- *   Build a typed `Visitor` function from a tree and a test.
- *
- *   It will infer which values are passed as `node` and which as `parents`.
- * @template {UnistNode} [Tree=UnistNode]
- *   Tree type.
- * @template {Test} [Check=Test]
- *   Test type.
- */
-
-
-
-
-/** @type {Readonly<ActionTuple>} */
-const empty = []
-
-/**
- * Continue traversing as normal.
- */
-const CONTINUE = true
-
-/**
- * Stop traversing immediately.
- */
-const EXIT = false
-
-/**
- * Do not traverse this nodes children.
- */
-const SKIP = 'skip'
-
-/**
- * Visit nodes, with ancestral information.
- *
- * This algorithm performs *depth-first* *tree traversal* in *preorder*
- * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
- *
- * You can choose for which nodes `visitor` is called by passing a `test`.
- * For complex tests, you should test yourself in `visitor`, as it will be
- * faster and will have improved type information.
- *
- * Walking the tree is an intensive task.
- * Make use of the return values of the visitor when possible.
- * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
- * to check if a node matches, and then perform different operations.
- *
- * You can change the tree.
- * See `Visitor` for more info.
- *
- * @overload
- * @param {Tree} tree
- * @param {Check} check
- * @param {BuildVisitor<Tree, Check>} visitor
- * @param {boolean | null | undefined} [reverse]
- * @returns {undefined}
- *
- * @overload
- * @param {Tree} tree
- * @param {BuildVisitor<Tree>} visitor
- * @param {boolean | null | undefined} [reverse]
- * @returns {undefined}
- *
- * @param {UnistNode} tree
- *   Tree to traverse.
- * @param {Visitor | Test} test
- *   `unist-util-is`-compatible test
- * @param {Visitor | boolean | null | undefined} [visitor]
- *   Handle each node.
- * @param {boolean | null | undefined} [reverse]
- *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
- * @returns {undefined}
- *   Nothing.
- *
- * @template {UnistNode} Tree
- *   Node type.
- * @template {Test} Check
- *   `unist-util-is`-compatible test.
- */
+  return d;
+}
+const empty = [];
+const CONTINUE = true;
+const EXIT = false;
+const SKIP = "skip";
 function visitParents(tree, test, visitor, reverse) {
-  /** @type {Test} */
-  let check
-
-  if (typeof test === 'function' && typeof visitor !== 'function') {
-    reverse = visitor
-    // @ts-expect-error no visitor given, so `visitor` is test.
-    visitor = test
+  let check;
+  if (typeof test === "function" && typeof visitor !== "function") {
+    reverse = visitor;
+    visitor = test;
   } else {
-    // @ts-expect-error visitor given, so `test` isnt a visitor.
-    check = test
-  }
-
-  const is = convert(check)
-  const step = reverse ? -1 : 1
-
-  factory(tree, undefined, [])()
-
-  /**
-   * @param {UnistNode} node
-   * @param {number | undefined} index
-   * @param {Array<UnistParent>} parents
-   */
-  function factory(node, index, parents) {
-    const value = /** @type {Record<string, unknown>} */ (
-      node && typeof node === 'object' ? node : {}
-    )
-
-    if (typeof value.type === 'string') {
-      const name =
+    check = test;
+  }
+  const is = convert(check);
+  const step = reverse ? -1 : 1;
+  factory(tree, void 0, [])();
+  function factory(node2, index, parents) {
+    const value = (
+      /** @type {Record<string, unknown>} */
+      node2 && typeof node2 === "object" ? node2 : {}
+    );
+    if (typeof value.type === "string") {
+      const name = (
         // `hast`
-        typeof value.tagName === 'string'
-          ? value.tagName
-          : // `xast`
-          typeof value.name === 'string'
-          ? value.name
-          : undefined
-
-      Object.defineProperty(visit, 'name', {
-        value:
-          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'
-      })
-    }
-
-    return visit
-
-    function visit() {
-      /** @type {Readonly<ActionTuple>} */
-      let result = empty
-      /** @type {Readonly<ActionTuple>} */
-      let subresult
-      /** @type {number} */
-      let offset
-      /** @type {Array<UnistParent>} */
-      let grandparents
-
-      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {
-        // @ts-expect-error: `visitor` is now a visitor.
-        result = toResult(visitor(node, parents))
-
+        typeof value.tagName === "string" ? value.tagName : (
+          // `xast`
+          typeof value.name === "string" ? value.name : void 0
+        )
+      );
+      Object.defineProperty(visit2, "name", {
+        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
+      });
+    }
+    return visit2;
+    function visit2() {
+      let result = empty;
+      let subresult;
+      let offset;
+      let grandparents;
+      if (!test || is(node2, index, parents[parents.length - 1] || void 0)) {
+        result = toResult(visitor(node2, parents));
         if (result[0] === EXIT) {
-          return result
+          return result;
         }
       }
-
-      if ('children' in node && node.children) {
-        const nodeAsParent = /** @type {UnistParent} */ (node)
-
+      if ("children" in node2 && node2.children) {
+        const nodeAsParent = (
+          /** @type {UnistParent} */
+          node2
+        );
         if (nodeAsParent.children && result[0] !== SKIP) {
-          offset = (reverse ? nodeAsParent.children.length : -1) + step
-          grandparents = parents.concat(nodeAsParent)
-
+          offset = (reverse ? nodeAsParent.children.length : -1) + step;
+          grandparents = parents.concat(nodeAsParent);
           while (offset > -1 && offset < nodeAsParent.children.length) {
-            const child = nodeAsParent.children[offset]
-
-            subresult = factory(child, offset, grandparents)()
-
+            const child = nodeAsParent.children[offset];
+            subresult = factory(child, offset, grandparents)();
             if (subresult[0] === EXIT) {
-              return subresult
+              return subresult;
             }
-
-            offset =
-              typeof subresult[1] === 'number' ? subresult[1] : offset + step
+            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
           }
         }
       }
-
-      return result
+      return result;
     }
   }
 }
-
-/**
- * Turn a return value into a clean result.
- *
- * @param {VisitorResult} value
- *   Valid return values from visitors.
- * @returns {Readonly<ActionTuple>}
- *   Clean result.
- */
 function toResult(value) {
   if (Array.isArray(value)) {
-    return value
-  }
-
-  if (typeof value === 'number') {
-    return [CONTINUE, value]
-  }
-
-  return value === null || value === undefined ? empty : [value]
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-find-and-replace/lib/index.js
-/**
- * @typedef {import('mdast').Nodes} Nodes
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').PhrasingContent} PhrasingContent
- * @typedef {import('mdast').Root} Root
- * @typedef {import('mdast').Text} Text
- * @typedef {import('unist-util-visit-parents').Test} Test
- * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
- */
-
-/**
- * @typedef RegExpMatchObject
- *   Info on the match.
- * @property {number} index
- *   The index of the search at which the result was found.
- * @property {string} input
- *   A copy of the search string in the text node.
- * @property {[...Array<Parents>, Text]} stack
- *   All ancestors of the text node, where the last node is the text itself.
- *
- * @typedef {RegExp | string} Find
- *   Pattern to find.
- *
- *   Strings are escaped and then turned into global expressions.
- *
- * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList
- *   Several find and replaces, in array form.
- *
- * @typedef {[Find, Replace?]} FindAndReplaceTuple
- *   Find and replace in tuple form.
- *
- * @typedef {ReplaceFunction | string | null | undefined} Replace
- *   Thing to replace with.
- *
- * @callback ReplaceFunction
- *   Callback called when a search matches.
- * @param {...any} parameters
- *   The parameters are the result of corresponding search expression:
- *
- *   * `value` (`string`)  whole match
- *   * `...capture` (`Array<string>`)  matches from regex capture groups
- *   * `match` (`RegExpMatchObject`)  info on the match
- * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}
- *   Thing to replace with.
- *
- *   * when `null`, `undefined`, `''`, remove the match
- *   * or when `false`, do not replace at all
- *   * or when `string`, replace with a text node of that value
- *   * or when `Node` or `Array<Node>`, replace with those nodes
- *
- * @typedef {[RegExp, ReplaceFunction]} Pair
- *   Normalized find and replace.
- *
- * @typedef {Array<Pair>} Pairs
- *   All find and replaced.
- *
- * @typedef Options
- *   Configuration.
- * @property {Test | null | undefined} [ignore]
- *   Test for which nodes to ignore (optional).
- */
-
-
-
-
-
-/**
- * Find patterns in a tree and replace them.
- *
- * The algorithm searches the tree in *preorder* for complete values in `Text`
- * nodes.
- * Partial matches are not supported.
- *
- * @param {Nodes} tree
- *   Tree to change.
- * @param {FindAndReplaceList | FindAndReplaceTuple} list
- *   Patterns to find.
- * @param {Options | null | undefined} [options]
- *   Configuration (when `find` is not `Find`).
- * @returns {undefined}
- *   Nothing.
- */
-function findAndReplace(tree, list, options) {
-  const settings = options || {}
-  const ignored = convert(settings.ignore || [])
-  const pairs = toPairs(list)
-  let pairIndex = -1
-
+    return value;
+  }
+  if (typeof value === "number") {
+    return [CONTINUE, value];
+  }
+  return value === null || value === void 0 ? empty : [value];
+}
+function findAndReplace(tree, list2, options) {
+  const settings = options;
+  const ignored = convert(settings.ignore || []);
+  const pairs = toPairs(list2);
+  let pairIndex = -1;
   while (++pairIndex < pairs.length) {
-    visitParents(tree, 'text', visitor)
-  }
-
-  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */
-  function visitor(node, parents) {
-    let index = -1
-    /** @type {Parents | undefined} */
-    let grandparent
-
+    visitParents(tree, "text", visitor);
+  }
+  function visitor(node2, parents) {
+    let index = -1;
+    let grandparent;
     while (++index < parents.length) {
-      const parent = parents[index]
-      /** @type {Array<Nodes> | undefined} */
-      const siblings = grandparent ? grandparent.children : undefined
-
-      if (
-        ignored(
-          parent,
-          siblings ? siblings.indexOf(parent) : undefined,
-          grandparent
-        )
-      ) {
-        return
+      const parent = parents[index];
+      const siblings = grandparent ? grandparent.children : void 0;
+      if (ignored(
+        parent,
+        siblings ? siblings.indexOf(parent) : void 0,
+        grandparent
+      )) {
+        return;
       }
-
-      grandparent = parent
+      grandparent = parent;
     }
-
     if (grandparent) {
-      return handler(node, parents)
-    }
-  }
-
-  /**
-   * Handle a text node which is not in an ignored parent.
-   *
-   * @param {Text} node
-   *   Text node.
-   * @param {Array<Parents>} parents
-   *   Parents.
-   * @returns {VisitorResult}
-   *   Result.
-   */
-  function handler(node, parents) {
-    const parent = parents[parents.length - 1]
-    const find = pairs[pairIndex][0]
-    const replace = pairs[pairIndex][1]
-    let start = 0
-    /** @type {Array<Nodes>} */
-    const siblings = parent.children
-    const index = siblings.indexOf(node)
-    let change = false
-    /** @type {Array<PhrasingContent>} */
-    let nodes = []
-
-    find.lastIndex = 0
-
-    let match = find.exec(node.value)
-
+      return handler(node2, parents);
+    }
+  }
+  function handler(node2, parents) {
+    const parent = parents[parents.length - 1];
+    const find = pairs[pairIndex][0];
+    const replace = pairs[pairIndex][1];
+    let start = 0;
+    const siblings = parent.children;
+    const index = siblings.indexOf(node2);
+    let change = false;
+    let nodes = [];
+    find.lastIndex = 0;
+    let match = find.exec(node2.value);
     while (match) {
-      const position = match.index
-      /** @type {RegExpMatchObject} */
+      const position = match.index;
       const matchObject = {
         index: match.index,
         input: match.input,
-        stack: [...parents, node]
-      }
-      let value = replace(...match, matchObject)
-
-      if (typeof value === 'string') {
-        value = value.length > 0 ? {type: 'text', value} : undefined
+        stack: [...parents, node2]
+      };
+      let value = replace(...match, matchObject);
+      if (typeof value === "string") {
+        value = value.length > 0 ? { type: "text", value } : void 0;
       }
-
-      // It wasnt a match after all.
       if (value === false) {
-        // False acts as if there was no match.
-        // So we need to reset `lastIndex`, which currently being at the end of
-        // the current match, to the beginning.
-        find.lastIndex = position + 1
+        find.lastIndex = position + 1;
       } else {
         if (start !== position) {
           nodes.push({
-            type: 'text',
-            value: node.value.slice(start, position)
-          })
+            type: "text",
+            value: node2.value.slice(start, position)
+          });
         }
-
         if (Array.isArray(value)) {
-          nodes.push(...value)
+          nodes.push(...value);
         } else if (value) {
-          nodes.push(value)
+          nodes.push(value);
         }
-
-        start = position + match[0].length
-        change = true
+        start = position + match[0].length;
+        change = true;
       }
-
       if (!find.global) {
-        break
+        break;
       }
-
-      match = find.exec(node.value)
+      match = find.exec(node2.value);
     }
-
     if (change) {
-      if (start < node.value.length) {
-        nodes.push({type: 'text', value: node.value.slice(start)})
+      if (start < node2.value.length) {
+        nodes.push({ type: "text", value: node2.value.slice(start) });
       }
-
-      parent.children.splice(index, 1, ...nodes)
+      parent.children.splice(index, 1, ...nodes);
     } else {
-      nodes = [node]
+      nodes = [node2];
     }
-
-    return index + nodes.length
-  }
-}
-
-/**
- * Turn a tuple or a list of tuples into pairs.
- *
- * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList
- *   Schema.
- * @returns {Pairs}
- *   Clean pairs.
- */
+    return index + nodes.length;
+  }
+}
 function toPairs(tupleOrList) {
-  /** @type {Pairs} */
-  const result = []
-
+  const result = [];
   if (!Array.isArray(tupleOrList)) {
-    throw new TypeError('Expected find and replace tuple or list of tuples')
-  }
-
-  /** @type {FindAndReplaceList} */
-  // @ts-expect-error: correct.
-  const list =
-    !tupleOrList[0] || Array.isArray(tupleOrList[0])
-      ? tupleOrList
-      : [tupleOrList]
-
-  let index = -1
-
-  while (++index < list.length) {
-    const tuple = list[index]
-    result.push([toExpression(tuple[0]), toFunction(tuple[1])])
-  }
-
-  return result
-}
-
-/**
- * Turn a find into an expression.
- *
- * @param {Find} find
- *   Find.
- * @returns {RegExp}
- *   Expression.
- */
+    throw new TypeError("Expected find and replace tuple or list of tuples");
+  }
+  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
+  let index = -1;
+  while (++index < list2.length) {
+    const tuple = list2[index];
+    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
+  }
+  return result;
+}
 function toExpression(find) {
-  return typeof find === 'string' ? new RegExp(escapeStringRegexp(find), 'g') : find
-}
-
-/**
- * Turn a replace into a function.
- *
- * @param {Replace} replace
- *   Replace.
- * @returns {ReplaceFunction}
- *   Function.
- */
+  return typeof find === "string" ? new RegExp(escapeStringRegexp(find), "g") : find;
+}
 function toFunction(replace) {
-  return typeof replace === 'function'
-    ? replace
-    : function () {
-        return replace
-      }
+  return typeof replace === "function" ? replace : function() {
+    return replace;
+  };
 }
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-gfm-autolink-literal/lib/index.js
-/**
- * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'
- * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'
- * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'
- * @import {Link, PhrasingContent} from 'mdast'
- */
-
-
-
-
-
-
-/** @type {ConstructName} */
-const inConstruct = 'phrasing'
-/** @type {Array<ConstructName>} */
-const notInConstruct = ['autolink', 'link', 'image', 'label']
-
-/**
- * Create an extension for `mdast-util-from-markdown` to enable GFM autolink
- * literals in markdown.
- *
- * @returns {FromMarkdownExtension}
- *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.
- */
+const inConstruct = "phrasing";
+const notInConstruct = ["autolink", "link", "image", "label"];
 function gfmAutolinkLiteralFromMarkdown() {
   return {
     transforms: [transformGfmAutolinkLiterals],
@@ -2482,254 +1392,137 @@ function gfmAutolinkLiteralFromMarkdown() {
       literalAutolinkHttp: exitLiteralAutolinkHttp,
       literalAutolinkWww: exitLiteralAutolinkWww
     }
-  }
+  };
 }
-
-/**
- * Create an extension for `mdast-util-to-markdown` to enable GFM autolink
- * literals in markdown.
- *
- * @returns {ToMarkdownExtension}
- *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.
- */
 function gfmAutolinkLiteralToMarkdown() {
   return {
     unsafe: [
       {
-        character: '@',
-        before: '[+\\-.\\w]',
-        after: '[\\-.\\w]',
+        character: "@",
+        before: "[+\\-.\\w]",
+        after: "[\\-.\\w]",
         inConstruct,
         notInConstruct
       },
       {
-        character: '.',
-        before: '[Ww]',
-        after: '[\\-.\\w]',
+        character: ".",
+        before: "[Ww]",
+        after: "[\\-.\\w]",
         inConstruct,
         notInConstruct
       },
       {
-        character: ':',
-        before: '[ps]',
-        after: '\\/',
+        character: ":",
+        before: "[ps]",
+        after: "\\/",
         inConstruct,
         notInConstruct
       }
     ]
-  }
+  };
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function enterLiteralAutolink(token) {
-  this.enter({type: 'link', title: null, url: '', children: []}, token)
+  this.enter({ type: "link", title: null, url: "", children: [] }, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function enterLiteralAutolinkValue(token) {
-  this.config.enter.autolinkProtocol.call(this, token)
+  this.config.enter.autolinkProtocol.call(this, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitLiteralAutolinkHttp(token) {
-  this.config.exit.autolinkProtocol.call(this, token)
+  this.config.exit.autolinkProtocol.call(this, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitLiteralAutolinkWww(token) {
-  this.config.exit.data.call(this, token)
-  const node = this.stack[this.stack.length - 1]
-  ok(node.type === 'link')
-  node.url = 'http://' + this.sliceSerialize(token)
-}
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
+  this.config.exit.data.call(this, token);
+  const node2 = this.stack[this.stack.length - 1];
+  ok$1(node2.type === "link");
+  node2.url = "http://" + this.sliceSerialize(token);
+}
 function exitLiteralAutolinkEmail(token) {
-  this.config.exit.autolinkEmail.call(this, token)
+  this.config.exit.autolinkEmail.call(this, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitLiteralAutolink(token) {
-  this.exit(token)
+  this.exit(token);
 }
-
-/** @type {FromMarkdownTransform} */
 function transformGfmAutolinkLiterals(tree) {
   findAndReplace(
     tree,
     [
       [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
-      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, findEmail]
+      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]
     ],
-    {ignore: ['link', 'linkReference']}
-  )
-}
-
-/**
- * @type {ReplaceFunction}
- * @param {string} _
- * @param {string} protocol
- * @param {string} domain
- * @param {string} path
- * @param {RegExpMatchObject} match
- * @returns {Array<PhrasingContent> | Link | false}
- */
-// eslint-disable-next-line max-params
-function findUrl(_, protocol, domain, path, match) {
-  let prefix = ''
-
-  // Not an expected previous character.
+    { ignore: ["link", "linkReference"] }
+  );
+}
+function findUrl(_, protocol, domain2, path2, match) {
+  let prefix = "";
   if (!previous(match)) {
-    return false
+    return false;
   }
-
-  // Treat `www` as part of the domain.
   if (/^w/i.test(protocol)) {
-    domain = protocol + domain
-    protocol = ''
-    prefix = 'http://'
-  }
-
-  if (!isCorrectDomain(domain)) {
-    return false
-  }
-
-  const parts = splitUrl(domain + path)
-
-  if (!parts[0]) return false
-
-  /** @type {Link} */
+    domain2 = protocol + domain2;
+    protocol = "";
+    prefix = "http://";
+  }
+  if (!isCorrectDomain(domain2)) {
+    return false;
+  }
+  const parts = splitUrl(domain2 + path2);
+  if (!parts[0]) return false;
   const result = {
-    type: 'link',
+    type: "link",
     title: null,
     url: prefix + protocol + parts[0],
-    children: [{type: 'text', value: protocol + parts[0]}]
-  }
-
+    children: [{ type: "text", value: protocol + parts[0] }]
+  };
   if (parts[1]) {
-    return [result, {type: 'text', value: parts[1]}]
-  }
-
-  return result
-}
-
-/**
- * @type {ReplaceFunction}
- * @param {string} _
- * @param {string} atext
- * @param {string} label
- * @param {RegExpMatchObject} match
- * @returns {Link | false}
- */
+    return [result, { type: "text", value: parts[1] }];
+  }
+  return result;
+}
 function findEmail(_, atext, label, match) {
   if (
     // Not an expected previous character.
-    !previous(match, true) ||
-    // Label ends in not allowed character.
+    !previous(match, true) || // Label ends in not allowed character.
     /[-\d_]$/.test(label)
   ) {
-    return false
+    return false;
   }
-
   return {
-    type: 'link',
+    type: "link",
     title: null,
-    url: 'mailto:' + atext + '@' + label,
-    children: [{type: 'text', value: atext + '@' + label}]
-  }
-}
-
-/**
- * @param {string} domain
- * @returns {boolean}
- */
-function isCorrectDomain(domain) {
-  const parts = domain.split('.')
-
-  if (
-    parts.length < 2 ||
-    (parts[parts.length - 1] &&
-      (/_/.test(parts[parts.length - 1]) ||
-        !/[a-zA-Z\d]/.test(parts[parts.length - 1]))) ||
-    (parts[parts.length - 2] &&
-      (/_/.test(parts[parts.length - 2]) ||
-        !/[a-zA-Z\d]/.test(parts[parts.length - 2])))
-  ) {
-    return false
+    url: "mailto:" + atext + "@" + label,
+    children: [{ type: "text", value: atext + "@" + label }]
+  };
+}
+function isCorrectDomain(domain2) {
+  const parts = domain2.split(".");
+  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
+    return false;
   }
-
-  return true
+  return true;
 }
-
-/**
- * @param {string} url
- * @returns {[string, string | undefined]}
- */
 function splitUrl(url) {
-  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url)
-
+  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
   if (!trailExec) {
-    return [url, undefined]
-  }
-
-  url = url.slice(0, trailExec.index)
-
-  let trail = trailExec[0]
-  let closingParenIndex = trail.indexOf(')')
-  const openingParens = ccount(url, '(')
-  let closingParens = ccount(url, ')')
-
+    return [url, void 0];
+  }
+  url = url.slice(0, trailExec.index);
+  let trail2 = trailExec[0];
+  let closingParenIndex = trail2.indexOf(")");
+  const openingParens = ccount(url, "(");
+  let closingParens = ccount(url, ")");
   while (closingParenIndex !== -1 && openingParens > closingParens) {
-    url += trail.slice(0, closingParenIndex + 1)
-    trail = trail.slice(closingParenIndex + 1)
-    closingParenIndex = trail.indexOf(')')
-    closingParens++
-  }
-
-  return [url, trail]
-}
-
-/**
- * @param {RegExpMatchObject} match
- * @param {boolean | null | undefined} [email=false]
- * @returns {boolean}
- */
+    url += trail2.slice(0, closingParenIndex + 1);
+    trail2 = trail2.slice(closingParenIndex + 1);
+    closingParenIndex = trail2.indexOf(")");
+    closingParens++;
+  }
+  return [url, trail2];
+}
 function previous(match, email) {
-  const code = match.input.charCodeAt(match.index - 1)
-
-  return (
-    (match.index === 0 ||
-      unicodeWhitespace(code) ||
-      unicodePunctuation(code)) &&
-    // If its an email, the previous character should not be a slash.
-    (!email || code !== 47)
-  )
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
-/**
- * @import {Code, ConstructRecord, Event, Extension, Previous, State, TokenizeContext, Tokenizer} from 'micromark-util-types'
- */
-
-
+  const code2 = match.input.charCodeAt(match.index - 1);
+  return (match.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && // If its an email, the previous character should not be a slash.
+  (!email || code2 !== 47);
+}
 const wwwPrefix = {
   tokenize: tokenizeWwwPrefix,
   partial: true
@@ -2751,1150 +1544,451 @@ const emailDomainDotTrail = {
   partial: true
 };
 const wwwAutolink = {
-  name: 'wwwAutolink',
+  name: "wwwAutolink",
   tokenize: tokenizeWwwAutolink,
   previous: previousWww
 };
 const protocolAutolink = {
-  name: 'protocolAutolink',
+  name: "protocolAutolink",
   tokenize: tokenizeProtocolAutolink,
   previous: previousProtocol
 };
 const emailAutolink = {
-  name: 'emailAutolink',
+  name: "emailAutolink",
   tokenize: tokenizeEmailAutolink,
   previous: previousEmail
 };
-
-/** @type {ConstructRecord} */
-const syntax_text = {};
-
-/**
- * Create an extension for `micromark` to support GitHub autolink literal
- * syntax.
- *
- * @returns {Extension}
- *   Extension for `micromark` that can be passed in `extensions` to enable GFM
- *   autolink literal syntax.
- */
+const text$1 = {};
 function gfmAutolinkLiteral() {
   return {
-    text: syntax_text
+    text: text$1
   };
 }
-
-/** @type {Code} */
-let code = 48;
-
-// Add alphanumerics.
-while (code < 123) {
-  syntax_text[code] = emailAutolink;
-  code++;
-  if (code === 58) code = 65;else if (code === 91) code = 97;
-}
-syntax_text[43] = emailAutolink;
-syntax_text[45] = emailAutolink;
-syntax_text[46] = emailAutolink;
-syntax_text[95] = emailAutolink;
-syntax_text[72] = [emailAutolink, protocolAutolink];
-syntax_text[104] = [emailAutolink, protocolAutolink];
-syntax_text[87] = [emailAutolink, wwwAutolink];
-syntax_text[119] = [emailAutolink, wwwAutolink];
-
-// To do: perform email autolink literals on events, afterwards.
-// Thats where `markdown-rs` and `cmark-gfm` perform it.
-// It should look for `@`, then for atext backwards, and then for a label
-// forwards.
-// To do: `mailto:`, `xmpp:` protocol as prefix.
-
-/**
- * Email autolink literal.
- *
- * ```markdown
- * > | a contact@example.org b
- *       ^^^^^^^^^^^^^^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeEmailAutolink(effects, ok, nok) {
+let code$1 = 48;
+while (code$1 < 123) {
+  text$1[code$1] = emailAutolink;
+  code$1++;
+  if (code$1 === 58) code$1 = 65;
+  else if (code$1 === 91) code$1 = 97;
+}
+text$1[43] = emailAutolink;
+text$1[45] = emailAutolink;
+text$1[46] = emailAutolink;
+text$1[95] = emailAutolink;
+text$1[72] = [emailAutolink, protocolAutolink];
+text$1[104] = [emailAutolink, protocolAutolink];
+text$1[87] = [emailAutolink, wwwAutolink];
+text$1[119] = [emailAutolink, wwwAutolink];
+function tokenizeEmailAutolink(effects, ok2, nok) {
   const self = this;
-  /** @type {boolean | undefined} */
   let dot;
-  /** @type {boolean} */
   let data;
   return start;
-
-  /**
-   * Start of email autolink literal.
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *       ^
-   * ```
-   *
-   * @type {State}
-   */
-  function start(code) {
-    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {
-      return nok(code);
+  function start(code2) {
+    if (!gfmAtext(code2) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {
+      return nok(code2);
     }
-    effects.enter('literalAutolink');
-    effects.enter('literalAutolinkEmail');
-    return atext(code);
+    effects.enter("literalAutolink");
+    effects.enter("literalAutolinkEmail");
+    return atext(code2);
   }
-
-  /**
-   * In email atext.
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *       ^
-   * ```
-   *
-   * @type {State}
-   */
-  function atext(code) {
-    if (gfmAtext(code)) {
-      effects.consume(code);
+  function atext(code2) {
+    if (gfmAtext(code2)) {
+      effects.consume(code2);
       return atext;
     }
-    if (code === 64) {
-      effects.consume(code);
+    if (code2 === 64) {
+      effects.consume(code2);
       return emailDomain;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * In email domain.
-   *
-   * The reference code is a bit overly complex as it handles the `@`, of which
-   * there may be just one.
-   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *               ^
-   * ```
-   *
-   * @type {State}
-   */
-  function emailDomain(code) {
-    // Dot followed by alphanumerical (not `-` or `_`).
-    if (code === 46) {
-      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);
+  function emailDomain(code2) {
+    if (code2 === 46) {
+      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code2);
     }
-
-    // Alphanumerical, `-`, and `_`.
-    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {
+    if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
       data = true;
-      effects.consume(code);
+      effects.consume(code2);
       return emailDomain;
     }
-
-    // To do: `/` if xmpp.
-
-    // Note: normally wed truncate trailing punctuation from the link.
-    // However, email autolink literals cannot contain any of those markers,
-    // except for `.`, but that can only occur if it isnt trailing.
-    // So we can ignore truncating!
-    return emailDomainAfter(code);
-  }
-
-  /**
-   * In email domain, on dot that is not a trail.
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *                      ^
-   * ```
-   *
-   * @type {State}
-   */
-  function emailDomainDot(code) {
-    effects.consume(code);
+    return emailDomainAfter(code2);
+  }
+  function emailDomainDot(code2) {
+    effects.consume(code2);
     dot = true;
     return emailDomain;
   }
-
-  /**
-   * After email domain.
-   *
-   * ```markdown
-   * > | a contact@example.org b
-   *                          ^
-   * ```
-   *
-   * @type {State}
-   */
-  function emailDomainAfter(code) {
-    // Domain must not be empty, must include a dot, and must end in alphabetical.
-    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.
+  function emailDomainAfter(code2) {
     if (data && dot && asciiAlpha(self.previous)) {
-      effects.exit('literalAutolinkEmail');
-      effects.exit('literalAutolink');
-      return ok(code);
+      effects.exit("literalAutolinkEmail");
+      effects.exit("literalAutolink");
+      return ok2(code2);
     }
-    return nok(code);
-  }
-}
-
-/**
- * `www` autolink literal.
- *
- * ```markdown
- * > | a www.example.org b
- *       ^^^^^^^^^^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeWwwAutolink(effects, ok, nok) {
+    return nok(code2);
+  }
+}
+function tokenizeWwwAutolink(effects, ok2, nok) {
   const self = this;
   return wwwStart;
-
-  /**
-   * Start of www autolink literal.
-   *
-   * ```markdown
-   * > | www.example.com/a?b#c
-   *     ^
-   * ```
-   *
-   * @type {State}
-   */
-  function wwwStart(code) {
-    if (code !== 87 && code !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {
-      return nok(code);
+  function wwwStart(code2) {
+    if (code2 !== 87 && code2 !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {
+      return nok(code2);
     }
-    effects.enter('literalAutolink');
-    effects.enter('literalAutolinkWww');
-    // Note: we *check*, so we can discard the `www.` we parsed.
-    // If it worked, we consider it as a part of the domain.
-    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);
+    effects.enter("literalAutolink");
+    effects.enter("literalAutolinkWww");
+    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code2);
   }
-
-  /**
-   * After a www autolink literal.
-   *
-   * ```markdown
-   * > | www.example.com/a?b#c
-   *                          ^
-   * ```
-   *
-   * @type {State}
-   */
-  function wwwAfter(code) {
-    effects.exit('literalAutolinkWww');
-    effects.exit('literalAutolink');
-    return ok(code);
-  }
-}
-
-/**
- * Protocol autolink literal.
- *
- * ```markdown
- * > | a https://example.org b
- *       ^^^^^^^^^^^^^^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeProtocolAutolink(effects, ok, nok) {
+  function wwwAfter(code2) {
+    effects.exit("literalAutolinkWww");
+    effects.exit("literalAutolink");
+    return ok2(code2);
+  }
+}
+function tokenizeProtocolAutolink(effects, ok2, nok) {
   const self = this;
-  let buffer = '';
+  let buffer = "";
   let seen = false;
   return protocolStart;
-
-  /**
-   * Start of protocol autolink literal.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *     ^
-   * ```
-   *
-   * @type {State}
-   */
-  function protocolStart(code) {
-    if ((code === 72 || code === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {
-      effects.enter('literalAutolink');
-      effects.enter('literalAutolinkHttp');
-      buffer += String.fromCodePoint(code);
-      effects.consume(code);
+  function protocolStart(code2) {
+    if ((code2 === 72 || code2 === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {
+      effects.enter("literalAutolink");
+      effects.enter("literalAutolinkHttp");
+      buffer += String.fromCodePoint(code2);
+      effects.consume(code2);
       return protocolPrefixInside;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * In protocol.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *     ^^^^^
-   * ```
-   *
-   * @type {State}
-   */
-  function protocolPrefixInside(code) {
-    // `5` is size of `https`
-    if (asciiAlpha(code) && buffer.length < 5) {
-      // @ts-expect-error: definitely number.
-      buffer += String.fromCodePoint(code);
-      effects.consume(code);
+  function protocolPrefixInside(code2) {
+    if (asciiAlpha(code2) && buffer.length < 5) {
+      buffer += String.fromCodePoint(code2);
+      effects.consume(code2);
       return protocolPrefixInside;
     }
-    if (code === 58) {
+    if (code2 === 58) {
       const protocol = buffer.toLowerCase();
-      if (protocol === 'http' || protocol === 'https') {
-        effects.consume(code);
+      if (protocol === "http" || protocol === "https") {
+        effects.consume(code2);
         return protocolSlashesInside;
       }
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * In slashes.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *           ^^
-   * ```
-   *
-   * @type {State}
-   */
-  function protocolSlashesInside(code) {
-    if (code === 47) {
-      effects.consume(code);
+  function protocolSlashesInside(code2) {
+    if (code2 === 47) {
+      effects.consume(code2);
       if (seen) {
         return afterProtocol;
       }
       seen = true;
       return protocolSlashesInside;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * After protocol, before domain.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *             ^
-   * ```
-   *
-   * @type {State}
-   */
-  function afterProtocol(code) {
-    // To do: this is different from `markdown-rs`:
-    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182
-    return code === null || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);
+  function afterProtocol(code2) {
+    return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code2);
   }
-
-  /**
-   * After a protocol autolink literal.
-   *
-   * ```markdown
-   * > | https://example.com/a?b#c
-   *                              ^
-   * ```
-   *
-   * @type {State}
-   */
-  function protocolAfter(code) {
-    effects.exit('literalAutolinkHttp');
-    effects.exit('literalAutolink');
-    return ok(code);
-  }
-}
-
-/**
- * `www` prefix.
- *
- * ```markdown
- * > | a www.example.org b
- *       ^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeWwwPrefix(effects, ok, nok) {
+  function protocolAfter(code2) {
+    effects.exit("literalAutolinkHttp");
+    effects.exit("literalAutolink");
+    return ok2(code2);
+  }
+}
+function tokenizeWwwPrefix(effects, ok2, nok) {
   let size = 0;
   return wwwPrefixInside;
-
-  /**
-   * In www prefix.
-   *
-   * ```markdown
-   * > | www.example.com
-   *     ^^^^
-   * ```
-   *
-   * @type {State}
-   */
-  function wwwPrefixInside(code) {
-    if ((code === 87 || code === 119) && size < 3) {
+  function wwwPrefixInside(code2) {
+    if ((code2 === 87 || code2 === 119) && size < 3) {
       size++;
-      effects.consume(code);
+      effects.consume(code2);
       return wwwPrefixInside;
     }
-    if (code === 46 && size === 3) {
-      effects.consume(code);
+    if (code2 === 46 && size === 3) {
+      effects.consume(code2);
       return wwwPrefixAfter;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * After www prefix.
-   *
-   * ```markdown
-   * > | www.example.com
-   *         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function wwwPrefixAfter(code) {
-    // If there is *anything*, we can link.
-    return code === null ? nok(code) : ok(code);
-  }
-}
-
-/**
- * Domain.
- *
- * ```markdown
- * > | a https://example.org b
- *               ^^^^^^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeDomain(effects, ok, nok) {
-  /** @type {boolean | undefined} */
+  function wwwPrefixAfter(code2) {
+    return code2 === null ? nok(code2) : ok2(code2);
+  }
+}
+function tokenizeDomain(effects, ok2, nok) {
   let underscoreInLastSegment;
-  /** @type {boolean | undefined} */
   let underscoreInLastLastSegment;
-  /** @type {boolean | undefined} */
   let seen;
   return domainInside;
-
-  /**
-   * In domain.
-   *
-   * ```markdown
-   * > | https://example.com/a
-   *             ^^^^^^^^^^^
-   * ```
-   *
-   * @type {State}
-   */
-  function domainInside(code) {
-    // Check whether this marker, which is a trailing punctuation
-    // marker, optionally followed by more trailing markers, and then
-    // followed by an end.
-    if (code === 46 || code === 95) {
-      return effects.check(trail, domainAfter, domainAtPunctuation)(code);
+  function domainInside(code2) {
+    if (code2 === 46 || code2 === 95) {
+      return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
     }
-
-    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can
-    // occur, which sounds like ASCII only, but they also support `www..com`,
-    // so thats Unicode.
-    // Instead of some new production for Unicode alphanumerics, markdown
-    // already has that for Unicode punctuation and whitespace, so use those.
-    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.
-    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {
-      return domainAfter(code);
+    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
+      return domainAfter(code2);
     }
     seen = true;
-    effects.consume(code);
+    effects.consume(code2);
     return domainInside;
   }
-
-  /**
-   * In domain, at potential trailing punctuation, that was not trailing.
-   *
-   * ```markdown
-   * > | https://example.com
-   *                    ^
-   * ```
-   *
-   * @type {State}
-   */
-  function domainAtPunctuation(code) {
-    // There is an underscore in the last segment of the domain
-    if (code === 95) {
+  function domainAtPunctuation(code2) {
+    if (code2 === 95) {
       underscoreInLastSegment = true;
-    }
-    // Otherwise, its a `.`: save the last segment underscore in the
-    // penultimate segment slot.
-    else {
+    } else {
       underscoreInLastLastSegment = underscoreInLastSegment;
-      underscoreInLastSegment = undefined;
+      underscoreInLastSegment = void 0;
     }
-    effects.consume(code);
+    effects.consume(code2);
     return domainInside;
   }
-
-  /**
-   * After domain.
-   *
-   * ```markdown
-   * > | https://example.com/a
-   *                        ^
-   * ```
-   *
-   * @type {State} */
-  function domainAfter(code) {
-    // Note: thats GH says a dot is needed, but its not true:
-    // <https://github.com/github/cmark-gfm/issues/279>
+  function domainAfter(code2) {
     if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
-      return nok(code);
+      return nok(code2);
     }
-    return ok(code);
-  }
-}
-
-/**
- * Path.
- *
- * ```markdown
- * > | a https://example.org/stuff b
- *                          ^^^^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizePath(effects, ok) {
+    return ok2(code2);
+  }
+}
+function tokenizePath(effects, ok2) {
   let sizeOpen = 0;
   let sizeClose = 0;
   return pathInside;
-
-  /**
-   * In path.
-   *
-   * ```markdown
-   * > | https://example.com/a
-   *                        ^^
-   * ```
-   *
-   * @type {State}
-   */
-  function pathInside(code) {
-    if (code === 40) {
+  function pathInside(code2) {
+    if (code2 === 40) {
       sizeOpen++;
-      effects.consume(code);
+      effects.consume(code2);
       return pathInside;
     }
-
-    // To do: `markdown-rs` also needs this.
-    // If this is a paren, and there are less closings than openings,
-    // we dont check for a trail.
-    if (code === 41 && sizeClose < sizeOpen) {
-      return pathAtPunctuation(code);
+    if (code2 === 41 && sizeClose < sizeOpen) {
+      return pathAtPunctuation(code2);
     }
-
-    // Check whether this trailing punctuation marker is optionally
-    // followed by more trailing markers, and then followed
-    // by an end.
-    if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {
-      return effects.check(trail, ok, pathAtPunctuation)(code);
+    if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
+      return effects.check(trail, ok2, pathAtPunctuation)(code2);
     }
-    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
-      return ok(code);
+    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+      return ok2(code2);
     }
-    effects.consume(code);
+    effects.consume(code2);
     return pathInside;
   }
-
-  /**
-   * In path, at potential trailing punctuation, that was not trailing.
-   *
-   * ```markdown
-   * > | https://example.com/a"b
-   *                          ^
-   * ```
-   *
-   * @type {State}
-   */
-  function pathAtPunctuation(code) {
-    // Count closing parens.
-    if (code === 41) {
+  function pathAtPunctuation(code2) {
+    if (code2 === 41) {
       sizeClose++;
     }
-    effects.consume(code);
+    effects.consume(code2);
     return pathInside;
   }
 }
-
-/**
- * Trail.
- *
- * This calls `ok` if this *is* the trail, followed by an end, which means
- * the entire trail is not part of the link.
- * It calls `nok` if this *is* part of the link.
- *
- * ```markdown
- * > | https://example.com").
- *                        ^^^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeTrail(effects, ok, nok) {
-  return trail;
-
-  /**
-   * In trail of domain or path.
-   *
-   * ```markdown
-   * > | https://example.com").
-   *                        ^
-   * ```
-   *
-   * @type {State}
-   */
-  function trail(code) {
-    // Regular trailing punctuation.
-    if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {
-      effects.consume(code);
-      return trail;
+function tokenizeTrail(effects, ok2, nok) {
+  return trail2;
+  function trail2(code2) {
+    if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
+      effects.consume(code2);
+      return trail2;
     }
-
-    // `&` followed by one or more alphabeticals and then a `;`, is
-    // as a whole considered as trailing punctuation.
-    // In all other cases, it is considered as continuation of the URL.
-    if (code === 38) {
-      effects.consume(code);
+    if (code2 === 38) {
+      effects.consume(code2);
       return trailCharacterReferenceStart;
     }
-
-    // Needed because we allow literals after `[`, as we fix:
-    // <https://github.com/github/cmark-gfm/issues/278>.
-    // Check that it is not followed by `(` or `[`.
-    if (code === 93) {
-      effects.consume(code);
+    if (code2 === 93) {
+      effects.consume(code2);
       return trailBracketAfter;
     }
     if (
-    // `<` is an end.
-    code === 60 ||
-    // So is whitespace.
-    code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
-      return ok(code);
+      // `<` is an end.
+      code2 === 60 || // So is whitespace.
+      code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)
+    ) {
+      return ok2(code2);
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * In trail, after `]`.
-   *
-   * >  **Note**: this deviates from `cmark-gfm` to fix a bug.
-   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.
-   *
-   * ```markdown
-   * > | https://example.com](
-   *                         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function trailBracketAfter(code) {
-    // Whitespace or something that could start a resource or reference is the end.
-    // Switch back to trail otherwise.
-    if (code === null || code === 40 || code === 91 || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
-      return ok(code);
+  function trailBracketAfter(code2) {
+    if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+      return ok2(code2);
     }
-    return trail(code);
+    return trail2(code2);
   }
-
-  /**
-   * In character-reference like trail, after `&`.
-   *
-   * ```markdown
-   * > | https://example.com&amp;).
-   *                         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function trailCharacterReferenceStart(code) {
-    // When non-alpha, its not a trail.
-    return asciiAlpha(code) ? trailCharacterReferenceInside(code) : nok(code);
+  function trailCharacterReferenceStart(code2) {
+    return asciiAlpha(code2) ? trailCharacterReferenceInside(code2) : nok(code2);
   }
-
-  /**
-   * In character-reference like trail.
-   *
-   * ```markdown
-   * > | https://example.com&amp;).
-   *                         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function trailCharacterReferenceInside(code) {
-    // Switch back to trail if this is well-formed.
-    if (code === 59) {
-      effects.consume(code);
-      return trail;
+  function trailCharacterReferenceInside(code2) {
+    if (code2 === 59) {
+      effects.consume(code2);
+      return trail2;
     }
-    if (asciiAlpha(code)) {
-      effects.consume(code);
+    if (asciiAlpha(code2)) {
+      effects.consume(code2);
       return trailCharacterReferenceInside;
     }
-
-    // Its not a trail.
-    return nok(code);
-  }
-}
-
-/**
- * Dot in email domain trail.
- *
- * This calls `ok` if this *is* the trail, followed by an end, which means
- * the trail is not part of the link.
- * It calls `nok` if this *is* part of the link.
- *
- * ```markdown
- * > | contact@example.org.
- *                        ^
- * ```
- *
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeEmailDomainDotTrail(effects, ok, nok) {
+    return nok(code2);
+  }
+}
+function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
   return start;
-
-  /**
-   * Dot.
-   *
-   * ```markdown
-   * > | contact@example.org.
-   *                    ^   ^
-   * ```
-   *
-   * @type {State}
-   */
-  function start(code) {
-    // Must be dot.
-    effects.consume(code);
+  function start(code2) {
+    effects.consume(code2);
     return after;
   }
-
-  /**
-   * After dot.
-   *
-   * ```markdown
-   * > | contact@example.org.
-   *                     ^   ^
-   * ```
-   *
-   * @type {State}
-   */
-  function after(code) {
-    // Not a trail if alphanumeric.
-    return asciiAlphanumeric(code) ? nok(code) : ok(code);
-  }
-}
-
-/**
- * See:
- * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.
- *
- * @type {Previous}
- */
-function previousWww(code) {
-  return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || markdownLineEndingOrSpace(code);
-}
-
-/**
- * See:
- * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.
- *
- * @type {Previous}
- */
-function previousProtocol(code) {
-  return !asciiAlpha(code);
-}
-
-/**
- * @this {TokenizeContext}
- * @type {Previous}
- */
-function previousEmail(code) {
-  // Do not allow a slash inside atext.
-  // The reference code is a bit weird, but thats what it results in.
-  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.
-  // Other than slash, every preceding character is allowed.
-  return !(code === 47 || gfmAtext(code));
-}
-
-/**
- * @param {Code} code
- * @returns {boolean}
- */
-function gfmAtext(code) {
-  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);
-}
-
-/**
- * @param {Array<Event>} events
- * @returns {boolean}
- */
+  function after(code2) {
+    return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
+  }
+}
+function previousWww(code2) {
+  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
+}
+function previousProtocol(code2) {
+  return !asciiAlpha(code2);
+}
+function previousEmail(code2) {
+  return !(code2 === 47 || gfmAtext(code2));
+}
+function gfmAtext(code2) {
+  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
+}
 function previousUnbalanced(events) {
   let index = events.length;
   let result = false;
   while (index--) {
     const token = events[index][1];
-    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {
+    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
       result = true;
       break;
     }
-
-    // If weve seen this token, and it was marked as not having any unbalanced
-    // bracket before it, we can exit.
     if (token._gfmAutolinkLiteralWalkedInto) {
       result = false;
       break;
     }
   }
   if (events.length > 0 && !result) {
-    // Mark the last token as walked into w/o finding
-    // anything.
     events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
   }
   return result;
 }
-;// CONCATENATED MODULE: ./src/utils/buildUnifiedExtension.ts
 function buildUnifiedExtension(micromarkExtensions, fromMarkdownExtensions, toMarkdownExtensions) {
-    return function () {
-        var _a, _b, _c;
-        // eslint-disable-next-line no-invalid-this -- this provided by unified
-        const data = this.data();
-        (_a = data.micromarkExtensions) !== null && _a !== void 0 ? _a : (data.micromarkExtensions = []);
-        (_b = data.fromMarkdownExtensions) !== null && _b !== void 0 ? _b : (data.fromMarkdownExtensions = []);
-        (_c = data.toMarkdownExtensions) !== null && _c !== void 0 ? _c : (data.toMarkdownExtensions = []);
-        data.micromarkExtensions.push(...micromarkExtensions);
-        data.fromMarkdownExtensions.push(...fromMarkdownExtensions);
-        data.toMarkdownExtensions.push(...toMarkdownExtensions);
-    };
+  return function() {
+    const data = this.data();
+    data.micromarkExtensions ?? (data.micromarkExtensions = []);
+    data.fromMarkdownExtensions ?? (data.fromMarkdownExtensions = []);
+    data.toMarkdownExtensions ?? (data.toMarkdownExtensions = []);
+    data.micromarkExtensions.push(...micromarkExtensions);
+    data.fromMarkdownExtensions.push(...fromMarkdownExtensions);
+    data.toMarkdownExtensions.push(...toMarkdownExtensions);
+  };
 }
-
-;// CONCATENATED MODULE: ./src/syntax-extensions/ExtendedAutolinkExtension.ts
-
-
-
-
-/**
- * @public
- */
-class ExtendedAutolinkExtension extends external_prosemirror_unified_namespaceObject.Extension {
-    unifiedInitializationHook(processor) {
-        return processor.use(buildUnifiedExtension([gfmAutolinkLiteral()], [gfmAutolinkLiteralFromMarkdown()], [gfmAutolinkLiteralToMarkdown()]));
-    }
+class ExtendedAutolinkExtension extends Extension {
+  unifiedInitializationHook(processor) {
+    return processor.use(
+      buildUnifiedExtension(
+        [gfmAutolinkLiteral()],
+        [gfmAutolinkLiteralFromMarkdown()],
+        [gfmAutolinkLiteralToMarkdown()]
+      )
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-gfm-strikethrough/lib/index.js
-/**
- * @typedef {import('mdast').Delete} Delete
- *
- * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
- * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
- * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
- *
- * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName
- * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
- * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
- */
-
-/**
- * List of constructs that occur in phrasing (paragraphs, headings), but cannot
- * contain strikethrough.
- * So they sort of cancel each other out.
- * Note: could use a better name.
- *
- * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>
- *
- * @type {Array<ConstructName>}
- */
 const constructsWithoutStrikethrough = [
-  'autolink',
-  'destinationLiteral',
-  'destinationRaw',
-  'reference',
-  'titleQuote',
-  'titleApostrophe'
-]
-
-handleDelete.peek = peekDelete
-
-/**
- * Create an extension for `mdast-util-from-markdown` to enable GFM
- * strikethrough in markdown.
- *
- * @returns {FromMarkdownExtension}
- *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.
- */
+  "autolink",
+  "destinationLiteral",
+  "destinationRaw",
+  "reference",
+  "titleQuote",
+  "titleApostrophe"
+];
+handleDelete.peek = peekDelete;
 function gfmStrikethroughFromMarkdown() {
   return {
-    canContainEols: ['delete'],
-    enter: {strikethrough: enterStrikethrough},
-    exit: {strikethrough: exitStrikethrough}
-  }
-}
-
-/**
- * Create an extension for `mdast-util-to-markdown` to enable GFM
- * strikethrough in markdown.
- *
- * @returns {ToMarkdownExtension}
- *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.
- */
+    canContainEols: ["delete"],
+    enter: { strikethrough: enterStrikethrough },
+    exit: { strikethrough: exitStrikethrough }
+  };
+}
 function gfmStrikethroughToMarkdown() {
   return {
     unsafe: [
       {
-        character: '~',
-        inConstruct: 'phrasing',
+        character: "~",
+        inConstruct: "phrasing",
         notInConstruct: constructsWithoutStrikethrough
       }
     ],
-    handlers: {delete: handleDelete}
-  }
+    handlers: { delete: handleDelete }
+  };
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function enterStrikethrough(token) {
-  this.enter({type: 'delete', children: []}, token)
+  this.enter({ type: "delete", children: [] }, token);
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitStrikethrough(token) {
-  this.exit(token)
-}
-
-/**
- * @type {ToMarkdownHandle}
- * @param {Delete} node
- */
-function handleDelete(node, _, state, info) {
-  const tracker = state.createTracker(info)
-  const exit = state.enter('strikethrough')
-  let value = tracker.move('~~')
-  value += state.containerPhrasing(node, {
+  this.exit(token);
+}
+function handleDelete(node2, _, state, info) {
+  const tracker = state.createTracker(info);
+  const exit = state.enter("strikethrough");
+  let value = tracker.move("~~");
+  value += state.containerPhrasing(node2, {
     ...tracker.current(),
     before: value,
-    after: '~'
-  })
-  value += tracker.move('~~')
-  exit()
-  return value
-}
-
-/** @type {ToMarkdownHandle} */
+    after: "~"
+  });
+  value += tracker.move("~~");
+  exit();
+  return value;
+}
 function peekDelete() {
-  return '~'
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-util-chunked/index.js
-/**
- * Like `Array#splice`, but smarter for giant arrays.
- *
- * `Array#splice` takes all items to be inserted as individual argument which
- * causes a stack overflow in V8 when trying to insert 100k items for instance.
- *
- * Otherwise, this does not return the removed items, and takes `items` as an
- * array instead of rest parameters.
- *
- * @template {unknown} T
- *   Item type.
- * @param {Array<T>} list
- *   List to operate on.
- * @param {number} start
- *   Index to remove/insert at (can be negative).
- * @param {number} remove
- *   Number of items to remove.
- * @param {Array<T>} items
- *   Items to inject into `list`.
- * @returns {undefined}
- *   Nothing.
- */
-function splice(list, start, remove, items) {
-  const end = list.length
-  let chunkStart = 0
-  /** @type {Array<unknown>} */
-  let parameters
-
-  // Make start between zero and `end` (included).
+  return "~";
+}
+function splice(list2, start, remove, items) {
+  const end = list2.length;
+  let chunkStart = 0;
+  let parameters;
   if (start < 0) {
-    start = -start > end ? 0 : end + start
+    start = -start > end ? 0 : end + start;
   } else {
-    start = start > end ? end : start
-  }
-  remove = remove > 0 ? remove : 0
-
-  // No need to chunk the items if theres only a couple (10k) items.
-  if (items.length < 10000) {
-    parameters = Array.from(items)
-    parameters.unshift(start, remove)
-    // @ts-expect-error Hush, its fine.
-    list.splice(...parameters)
+    start = start > end ? end : start;
+  }
+  remove = remove > 0 ? remove : 0;
+  if (items.length < 1e4) {
+    parameters = Array.from(items);
+    parameters.unshift(start, remove);
+    list2.splice(...parameters);
   } else {
-    // Delete `remove` items starting from `start`
-    if (remove) list.splice(start, remove)
-
-    // Insert the items in chunks to not cause stack overflows.
+    if (remove) list2.splice(start, remove);
     while (chunkStart < items.length) {
-      parameters = items.slice(chunkStart, chunkStart + 10000)
-      parameters.unshift(start, 0)
-      // @ts-expect-error Hush, its fine.
-      list.splice(...parameters)
-      chunkStart += 10000
-      start += 10000
+      parameters = items.slice(chunkStart, chunkStart + 1e4);
+      parameters.unshift(start, 0);
+      list2.splice(...parameters);
+      chunkStart += 1e4;
+      start += 1e4;
     }
   }
 }
-
-/**
- * Append `items` (an array) at the end of `list` (another array).
- * When `list` was empty, returns `items` instead.
- *
- * This prevents a potentially expensive operation when `list` is empty,
- * and adds items in batches to prevent V8 from hanging.
- *
- * @template {unknown} T
- *   Item type.
- * @param {Array<T>} list
- *   List to operate on.
- * @param {Array<T>} items
- *   Items to add to `list`.
- * @returns {Array<T>}
- *   Either `list` or `items`.
- */
-function push(list, items) {
-  if (list.length > 0) {
-    splice(list, list.length, 0, items)
-    return list
-  }
-  return items
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-util-classify-character/index.js
-/**
- * @typedef {import('micromark-util-types').Code} Code
- */
-
-
-/**
- * Classify whether a code represents whitespace, punctuation, or something
- * else.
- *
- * Used for attention (emphasis, strong), whose sequences can open or close
- * based on the class of surrounding characters.
- *
- * >  **Note**: eof (`null`) is seen as whitespace.
- *
- * @param {Code} code
- *   Code.
- * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}
- *   Group.
- */
-function classifyCharacter(code) {
-  if (
-    code === null ||
-    markdownLineEndingOrSpace(code) ||
-    unicodeWhitespace(code)
-  ) {
-    return 1
-  }
-  if (unicodePunctuation(code)) {
-    return 2
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-util-resolve-all/index.js
-/**
- * @typedef {import('micromark-util-types').Event} Event
- * @typedef {import('micromark-util-types').Resolver} Resolver
- * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
- */
-
-/**
- * Call all `resolveAll`s.
- *
- * @param {Array<{resolveAll?: Resolver | undefined}>} constructs
- *   List of constructs, optionally with `resolveAll`s.
- * @param {Array<Event>} events
- *   List of events.
- * @param {TokenizeContext} context
- *   Context used by `tokenize`.
- * @returns {Array<Event>}
- *   Changed events.
- */
+function classifyCharacter(code2) {
+  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
+    return 1;
+  }
+  if (unicodePunctuation(code2)) {
+    return 2;
+  }
+}
 function resolveAll(constructs, events, context) {
-  /** @type {Array<Resolver>} */
-  const called = []
-  let index = -1
-
+  const called = [];
+  let index = -1;
   while (++index < constructs.length) {
-    const resolve = constructs[index].resolveAll
-
+    const resolve = constructs[index].resolveAll;
     if (resolve && !called.includes(resolve)) {
-      events = resolve(events, context)
-      called.push(resolve)
+      events = resolve(events, context);
+      called.push(resolve);
     }
   }
-
-  return events
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
-/**
- * @import {Options} from 'micromark-extension-gfm-strikethrough'
- * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'
- */
-
-
-
-
-/**
- * Create an extension for `micromark` to enable GFM strikethrough syntax.
- *
- * @param {Options | null | undefined} [options={}]
- *   Configuration.
- * @returns {Extension}
- *   Extension for `micromark` that can be passed in `extensions`, to
- *   enable GFM strikethrough syntax.
- */
+  return events;
+}
 function gfmStrikethrough(options) {
-  const options_ = options || {};
+  const options_ = {};
   let single = options_.singleTilde;
   const tokenizer = {
-    name: 'strikethrough',
+    name: "strikethrough",
     tokenize: tokenizeStrikethrough,
     resolveAll: resolveAllStrikethrough
   };
-  if (single === null || single === undefined) {
+  if (single === null || single === void 0) {
     single = true;
   }
   return {
@@ -3908,55 +2002,32 @@ function gfmStrikethrough(options) {
       null: [126]
     }
   };
-
-  /**
-   * Take events and resolve strikethrough.
-   *
-   * @type {Resolver}
-   */
   function resolveAllStrikethrough(events, context) {
     let index = -1;
-
-    // Walk through all events.
     while (++index < events.length) {
-      // Find a token that can close.
-      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {
+      if (events[index][0] === "enter" && events[index][1].type === "strikethroughSequenceTemporary" && events[index][1]._close) {
         let open = index;
-
-        // Now walk back to find an opener.
         while (open--) {
-          // Find a token that can open the closer.
-          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&
-          // If the sizes are the same:
+          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
           events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
-            events[index][1].type = 'strikethroughSequence';
-            events[open][1].type = 'strikethroughSequence';
-
-            /** @type {Token} */
+            events[index][1].type = "strikethroughSequence";
+            events[open][1].type = "strikethroughSequence";
             const strikethrough = {
-              type: 'strikethrough',
+              type: "strikethrough",
               start: Object.assign({}, events[open][1].start),
               end: Object.assign({}, events[index][1].end)
             };
-
-            /** @type {Token} */
-            const text = {
-              type: 'strikethroughText',
+            const text2 = {
+              type: "strikethroughText",
               start: Object.assign({}, events[open][1].end),
               end: Object.assign({}, events[index][1].start)
             };
-
-            // Opening.
-            /** @type {Array<Event>} */
-            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];
+            const nextEvents = [["enter", strikethrough, context], ["enter", events[open][1], context], ["exit", events[open][1], context], ["enter", text2, context]];
             const insideSpan = context.parser.constructs.insideSpan.null;
             if (insideSpan) {
-              // Between.
               splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan, events.slice(open + 1, index), context));
             }
-
-            // Closing.
-            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);
+            splice(nextEvents, nextEvents.length, 0, [["exit", text2, context], ["enter", events[index][1], context], ["exit", events[index][1], context], ["exit", strikethrough, context]]);
             splice(events, open - 1, index - open + 3, nextEvents);
             index = open + nextEvents.length - 2;
             break;
@@ -3966,2188 +2037,989 @@ function gfmStrikethrough(options) {
     }
     index = -1;
     while (++index < events.length) {
-      if (events[index][1].type === 'strikethroughSequenceTemporary') {
+      if (events[index][1].type === "strikethroughSequenceTemporary") {
         events[index][1].type = "data";
       }
     }
     return events;
   }
-
-  /**
-   * @this {TokenizeContext}
-   * @type {Tokenizer}
-   */
-  function tokenizeStrikethrough(effects, ok, nok) {
-    const previous = this.previous;
+  function tokenizeStrikethrough(effects, ok2, nok) {
+    const previous2 = this.previous;
     const events = this.events;
     let size = 0;
     return start;
-
-    /** @type {State} */
-    function start(code) {
-      if (previous === 126 && events[events.length - 1][1].type !== "characterEscape") {
-        return nok(code);
+    function start(code2) {
+      if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
+        return nok(code2);
       }
-      effects.enter('strikethroughSequenceTemporary');
-      return more(code);
-    }
-
-    /** @type {State} */
-    function more(code) {
-      const before = classifyCharacter(previous);
-      if (code === 126) {
-        // If this is the third marker, exit.
-        if (size > 1) return nok(code);
-        effects.consume(code);
+      effects.enter("strikethroughSequenceTemporary");
+      return more(code2);
+    }
+    function more(code2) {
+      const before = classifyCharacter(previous2);
+      if (code2 === 126) {
+        if (size > 1) return nok(code2);
+        effects.consume(code2);
         size++;
         return more;
       }
-      if (size < 2 && !single) return nok(code);
-      const token = effects.exit('strikethroughSequenceTemporary');
-      const after = classifyCharacter(code);
+      if (size < 2 && !single) return nok(code2);
+      const token = effects.exit("strikethroughSequenceTemporary");
+      const after = classifyCharacter(code2);
       token._open = !after || after === 2 && Boolean(before);
       token._close = !before || before === 2 && Boolean(after);
-      return ok(code);
+      return ok2(code2);
     }
   }
 }
-;// CONCATENATED MODULE: ./src/syntax-extensions/StrikethroughExtension.ts
-
-
-
-
-/**
- * @public
- */
-class StrikethroughExtension extends external_prosemirror_unified_namespaceObject.MarkExtension {
-    processConvertedUnistNode(convertedNode) {
-        return { children: [convertedNode], type: this.unistNodeName() };
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/~([^\s](?:.*[^\s~])?)~([^~])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-            new external_prosemirror_unified_namespaceObject.MarkInputRule(/~~([^\s](?:.*[^\s])?)~~([\s\S])$/u, proseMirrorSchema.marks[this.proseMirrorMarkName()]),
-        ];
-    }
-    proseMirrorMarkName() {
-        return "strikethrough";
-    }
-    proseMirrorMarkSpec() {
-        return {
-            parseDOM: [
-                { tag: "s" },
-                { tag: "del" },
-                {
-                    getAttrs: (value) => /(^|[\s])line-through([\s]|$)/u.test(value) && null,
-                    style: "text-decoration",
-                },
-            ],
-            toDOM() {
-                return ["s"];
-            },
-        };
-    }
-    unifiedInitializationHook(processor) {
-        return processor.use(buildUnifiedExtension([gfmStrikethrough()], [gfmStrikethroughFromMarkdown()], [gfmStrikethroughToMarkdown()]));
-    }
-    unistNodeName() {
-        return "delete";
-    }
-    unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
-        return convertedChildren.map((child) => child.mark(child.marks.concat([
-            proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),
-        ])));
-    }
+class StrikethroughExtension extends MarkExtension {
+  processConvertedUnistNode(convertedNode) {
+    return { children: [convertedNode], type: this.unistNodeName() };
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new MarkInputRule(
+        /~([^\s](?:.*[^\s~])?)~([^~])$/u,
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      ),
+      new MarkInputRule(
+        /~~([^\s](?:.*[^\s])?)~~([\s\S])$/u,
+        proseMirrorSchema.marks[this.proseMirrorMarkName()]
+      )
+    ];
+  }
+  proseMirrorMarkName() {
+    return "strikethrough";
+  }
+  proseMirrorMarkSpec() {
+    return {
+      parseDOM: [
+        { tag: "s" },
+        { tag: "del" },
+        {
+          getAttrs: (value) => /(^|[\s])line-through([\s]|$)/u.test(value) && null,
+          style: "text-decoration"
+        }
+      ],
+      toDOM() {
+        return ["s", 0];
+      }
+    };
+  }
+  unifiedInitializationHook(processor) {
+    return processor.use(
+      buildUnifiedExtension(
+        [gfmStrikethrough()],
+        [gfmStrikethroughFromMarkdown()],
+        [gfmStrikethroughToMarkdown()]
+      )
+    );
+  }
+  unistNodeName() {
+    return "delete";
+  }
+  unistNodeToProseMirrorNodes(_node, proseMirrorSchema, convertedChildren) {
+    return convertedChildren.map(
+      (child) => child.mark(
+        child.marks.concat([
+          proseMirrorSchema.marks[this.proseMirrorMarkName()].create()
+        ])
+      )
+    );
+  }
 }
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
-/**
- * @typedef {import('mdast').Blockquote} Blockquote
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').Map} Map
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {Blockquote} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function blockquote(node, _, state, info) {
-  const exit = state.enter('blockquote')
-  const tracker = state.createTracker(info)
-  tracker.move('> ')
-  tracker.shift(2)
+function blockquote(node2, _, state, info) {
+  const exit = state.enter("blockquote");
+  const tracker = state.createTracker(info);
+  tracker.move("> ");
+  tracker.shift(2);
   const value = state.indentLines(
-    state.containerFlow(node, tracker.current()),
-    map
-  )
-  exit()
-  return value
-}
-
-/** @type {Map} */
-function map(line, _, blank) {
-  return '>' + (blank ? '' : ' ') + line
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
-/**
- * @typedef {import('../types.js').ConstructName} ConstructName
- * @typedef {import('../types.js').Unsafe} Unsafe
- */
-
-/**
- * @param {Array<ConstructName>} stack
- * @param {Unsafe} pattern
- * @returns {boolean}
- */
+    state.containerFlow(node2, tracker.current()),
+    map$1
+  );
+  exit();
+  return value;
+}
+function map$1(line, _, blank) {
+  return ">" + (blank ? "" : " ") + line;
+}
 function patternInScope(stack, pattern) {
-  return (
-    listInScope(stack, pattern.inConstruct, true) &&
-    !listInScope(stack, pattern.notInConstruct, false)
-  )
-}
-
-/**
- * @param {Array<ConstructName>} stack
- * @param {Unsafe['inConstruct']} list
- * @param {boolean} none
- * @returns {boolean}
- */
-function listInScope(stack, list, none) {
-  if (typeof list === 'string') {
-    list = [list]
-  }
-
-  if (!list || list.length === 0) {
-    return none
-  }
-
-  let index = -1
-
-  while (++index < list.length) {
-    if (stack.includes(list[index])) {
-      return true
+  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
+}
+function listInScope(stack, list2, none) {
+  if (typeof list2 === "string") {
+    list2 = [list2];
+  }
+  if (!list2 || list2.length === 0) {
+    return none;
+  }
+  let index = -1;
+  while (++index < list2.length) {
+    if (stack.includes(list2[index])) {
+      return true;
     }
   }
-
-  return false
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/break.js
-/**
- * @typedef {import('mdast').Break} Break
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Break} _
- * @param {Parents | undefined} _1
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
+  return false;
+}
 function hardBreak(_, _1, state, info) {
-  let index = -1
-
+  let index = -1;
   while (++index < state.unsafe.length) {
-    // If we cant put eols in this construct (setext headings, tables), use a
-    // space instead.
-    if (
-      state.unsafe[index].character === '\n' &&
-      patternInScope(state.stack, state.unsafe[index])
-    ) {
-      return /[ \t]/.test(info.before) ? '' : ' '
+    if (state.unsafe[index].character === "\n" && patternInScope(state.stack, state.unsafe[index])) {
+      return /[ \t]/.test(info.before) ? "" : " ";
     }
   }
-
-  return '\\\n'
-}
-
-;// CONCATENATED MODULE: ./node_modules/longest-streak/index.js
-/**
- * Get the count of the longest repeating streak of `substring` in `value`.
- *
- * @param {string} value
- *   Content to search in.
- * @param {string} substring
- *   Substring to look for, typically one character.
- * @returns {number}
- *   Count of most frequent adjacent `substring`s in `value`.
- */
+  return "\\\n";
+}
 function longestStreak(value, substring) {
-  const source = String(value)
-  let index = source.indexOf(substring)
-  let expected = index
-  let count = 0
-  let max = 0
-
-  if (typeof substring !== 'string') {
-    throw new TypeError('Expected substring')
-  }
-
+  const source = String(value);
+  let index = source.indexOf(substring);
+  let expected = index;
+  let count = 0;
+  let max = 0;
+  if (typeof substring !== "string") {
+    throw new TypeError("Expected substring");
+  }
   while (index !== -1) {
     if (index === expected) {
       if (++count > max) {
-        max = count
+        max = count;
       }
     } else {
-      count = 1
+      count = 1;
     }
-
-    expected = index + substring.length
-    index = source.indexOf(substring, expected)
-  }
-
-  return max
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
-/**
- * @typedef {import('mdast').Code} Code
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {Code} node
- * @param {State} state
- * @returns {boolean}
- */
-function formatCodeAsIndented(node, state) {
+    expected = index + substring.length;
+    index = source.indexOf(substring, expected);
+  }
+  return max;
+}
+function formatCodeAsIndented(node2, state) {
   return Boolean(
-    state.options.fences === false &&
-      node.value &&
-      // If theres no info
-      !node.lang &&
-      // And theres a non-whitespace character
-      /[^ \r\n]/.test(node.value) &&
-      // And the value doesnt start or end in a blank
-      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node.value)
-  )
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-fence.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['fence'], null | undefined>}
- */
+    state.options.fences === false && node2.value && // If theres no info
+    !node2.lang && // And theres a non-whitespace character
+    /[^ \r\n]/.test(node2.value) && // And the value doesnt start or end in a blank
+    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
+  );
+}
 function checkFence(state) {
-  const marker = state.options.fence || '`'
-
-  if (marker !== '`' && marker !== '~') {
+  const marker = state.options.fence || "`";
+  if (marker !== "`" && marker !== "~") {
     throw new Error(
-      'Cannot serialize code with `' +
-        marker +
-        '` for `options.fence`, expected `` ` `` or `~`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/code.js
-/**
- * @typedef {import('mdast').Code} Code
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').Map} Map
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-
-/**
- * @param {Code} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function code_code(node, _, state, info) {
-  const marker = checkFence(state)
-  const raw = node.value || ''
-  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'
-
-  if (formatCodeAsIndented(node, state)) {
-    const exit = state.enter('codeIndented')
-    const value = state.indentLines(raw, code_map)
-    exit()
-    return value
-  }
-
-  const tracker = state.createTracker(info)
-  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))
-  const exit = state.enter('codeFenced')
-  let value = tracker.move(sequence)
-
-  if (node.lang) {
-    const subexit = state.enter(`codeFencedLang${suffix}`)
+      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
+    );
+  }
+  return marker;
+}
+function code(node2, _, state, info) {
+  const marker = checkFence(state);
+  const raw = node2.value || "";
+  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
+  if (formatCodeAsIndented(node2, state)) {
+    const exit2 = state.enter("codeIndented");
+    const value2 = state.indentLines(raw, map);
+    exit2();
+    return value2;
+  }
+  const tracker = state.createTracker(info);
+  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
+  const exit = state.enter("codeFenced");
+  let value = tracker.move(sequence);
+  if (node2.lang) {
+    const subexit = state.enter(`codeFencedLang${suffix}`);
     value += tracker.move(
-      state.safe(node.lang, {
+      state.safe(node2.lang, {
         before: value,
-        after: ' ',
-        encode: ['`'],
+        after: " ",
+        encode: ["`"],
         ...tracker.current()
       })
-    )
-    subexit()
+    );
+    subexit();
   }
-
-  if (node.lang && node.meta) {
-    const subexit = state.enter(`codeFencedMeta${suffix}`)
-    value += tracker.move(' ')
+  if (node2.lang && node2.meta) {
+    const subexit = state.enter(`codeFencedMeta${suffix}`);
+    value += tracker.move(" ");
     value += tracker.move(
-      state.safe(node.meta, {
+      state.safe(node2.meta, {
         before: value,
-        after: '\n',
-        encode: ['`'],
+        after: "\n",
+        encode: ["`"],
         ...tracker.current()
       })
-    )
-    subexit()
+    );
+    subexit();
   }
-
-  value += tracker.move('\n')
-
+  value += tracker.move("\n");
   if (raw) {
-    value += tracker.move(raw + '\n')
-  }
-
-  value += tracker.move(sequence)
-  exit()
-  return value
-}
-
-/** @type {Map} */
-function code_map(line, _, blank) {
-  return (blank ? '' : '    ') + line
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-quote.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['quote'], null | undefined>}
- */
+    value += tracker.move(raw + "\n");
+  }
+  value += tracker.move(sequence);
+  exit();
+  return value;
+}
+function map(line, _, blank) {
+  return (blank ? "" : "    ") + line;
+}
 function checkQuote(state) {
-  const marker = state.options.quote || '"'
-
+  const marker = state.options.quote || '"';
   if (marker !== '"' && marker !== "'") {
     throw new Error(
-      'Cannot serialize title with `' +
-        marker +
-        '` for `options.quote`, expected `"`, or `\'`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/definition.js
-/**
- * @typedef {import('mdast').Definition} Definition
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Definition} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function definition(node, _, state, info) {
-  const quote = checkQuote(state)
-  const suffix = quote === '"' ? 'Quote' : 'Apostrophe'
-  const exit = state.enter('definition')
-  let subexit = state.enter('label')
-  const tracker = state.createTracker(info)
-  let value = tracker.move('[')
+      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
+    );
+  }
+  return marker;
+}
+function definition(node2, _, state, info) {
+  const quote = checkQuote(state);
+  const suffix = quote === '"' ? "Quote" : "Apostrophe";
+  const exit = state.enter("definition");
+  let subexit = state.enter("label");
+  const tracker = state.createTracker(info);
+  let value = tracker.move("[");
   value += tracker.move(
-    state.safe(state.associationId(node), {
+    state.safe(state.associationId(node2), {
       before: value,
-      after: ']',
+      after: "]",
       ...tracker.current()
     })
-  )
-  value += tracker.move(']: ')
-
-  subexit()
-
+  );
+  value += tracker.move("]: ");
+  subexit();
   if (
     // If theres no url, or
-    !node.url ||
-    // If there are control characters or whitespace.
-    /[\0- \u007F]/.test(node.url)
+    !node2.url || // If there are control characters or whitespace.
+    /[\0- \u007F]/.test(node2.url)
   ) {
-    subexit = state.enter('destinationLiteral')
-    value += tracker.move('<')
+    subexit = state.enter("destinationLiteral");
+    value += tracker.move("<");
     value += tracker.move(
-      state.safe(node.url, {before: value, after: '>', ...tracker.current()})
-    )
-    value += tracker.move('>')
+      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
+    );
+    value += tracker.move(">");
   } else {
-    // No whitespace, raw is prettier.
-    subexit = state.enter('destinationRaw')
+    subexit = state.enter("destinationRaw");
     value += tracker.move(
-      state.safe(node.url, {
+      state.safe(node2.url, {
         before: value,
-        after: node.title ? ' ' : '\n',
+        after: node2.title ? " " : "\n",
         ...tracker.current()
       })
-    )
-  }
-
-  subexit()
-
-  if (node.title) {
-    subexit = state.enter(`title${suffix}`)
-    value += tracker.move(' ' + quote)
+    );
+  }
+  subexit();
+  if (node2.title) {
+    subexit = state.enter(`title${suffix}`);
+    value += tracker.move(" " + quote);
     value += tracker.move(
-      state.safe(node.title, {
+      state.safe(node2.title, {
         before: value,
         after: quote,
         ...tracker.current()
       })
-    )
-    value += tracker.move(quote)
-    subexit()
-  }
-
-  exit()
-
-  return value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['emphasis'], null | undefined>}
- */
+    );
+    value += tracker.move(quote);
+    subexit();
+  }
+  exit();
+  return value;
+}
 function checkEmphasis(state) {
-  const marker = state.options.emphasis || '*'
-
-  if (marker !== '*' && marker !== '_') {
+  const marker = state.options.emphasis || "*";
+  if (marker !== "*" && marker !== "_") {
     throw new Error(
-      'Cannot serialize emphasis with `' +
-        marker +
-        '` for `options.emphasis`, expected `*`, or `_`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
-/**
- * @typedef {import('mdast').Emphasis} Emphasis
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-emphasis.peek = emphasisPeek
-
-// To do: there are cases where emphasis cannot form depending on the
-// previous or next character of sequences.
-// Theres no way around that though, except for injecting zero-width stuff.
-// Do we need to safeguard against that?
-/**
- * @param {Emphasis} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function emphasis(node, _, state, info) {
-  const marker = checkEmphasis(state)
-  const exit = state.enter('emphasis')
-  const tracker = state.createTracker(info)
-  let value = tracker.move(marker)
-  value += tracker.move(
-    state.containerPhrasing(node, {
-      before: value,
+      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
+    );
+  }
+  return marker;
+}
+function encodeCharacterReference(code2) {
+  return "&#x" + code2.toString(16).toUpperCase() + ";";
+}
+function encodeInfo(outside, inside, marker) {
+  const outsideKind = classifyCharacter(outside);
+  const insideKind = classifyCharacter(inside);
+  if (outsideKind === void 0) {
+    return insideKind === void 0 ? (
+      // Letter inside:
+      // we have to encode *both* letters for `_` as it is looser.
+      // it already forms for `*` (and GFMs `~`).
+      marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
+    ) : insideKind === 1 ? (
+      // Whitespace inside: encode both (letter, whitespace).
+      { inside: true, outside: true }
+    ) : (
+      // Punctuation inside: encode outer (letter)
+      { inside: false, outside: true }
+    );
+  }
+  if (outsideKind === 1) {
+    return insideKind === void 0 ? (
+      // Letter inside: already forms.
+      { inside: false, outside: false }
+    ) : insideKind === 1 ? (
+      // Whitespace inside: encode both (whitespace).
+      { inside: true, outside: true }
+    ) : (
+      // Punctuation inside: already forms.
+      { inside: false, outside: false }
+    );
+  }
+  return insideKind === void 0 ? (
+    // Letter inside: already forms.
+    { inside: false, outside: false }
+  ) : insideKind === 1 ? (
+    // Whitespace inside: encode inner (whitespace).
+    { inside: true, outside: false }
+  ) : (
+    // Punctuation inside: already forms.
+    { inside: false, outside: false }
+  );
+}
+emphasis.peek = emphasisPeek;
+function emphasis(node2, _, state, info) {
+  const marker = checkEmphasis(state);
+  const exit = state.enter("emphasis");
+  const tracker = state.createTracker(info);
+  const before = tracker.move(marker);
+  let between = tracker.move(
+    state.containerPhrasing(node2, {
       after: marker,
+      before,
       ...tracker.current()
     })
-  )
-  value += tracker.move(marker)
-  exit()
-  return value
-}
-
-/**
- * @param {Emphasis} _
- * @param {Parents | undefined} _1
- * @param {State} state
- * @returns {string}
- */
+  );
+  const betweenHead = between.charCodeAt(0);
+  const open = encodeInfo(
+    info.before.charCodeAt(info.before.length - 1),
+    betweenHead,
+    marker
+  );
+  if (open.inside) {
+    between = encodeCharacterReference(betweenHead) + between.slice(1);
+  }
+  const betweenTail = between.charCodeAt(between.length - 1);
+  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
+  if (close.inside) {
+    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
+  }
+  const after = tracker.move(marker);
+  exit();
+  state.attentionEncodeSurroundingInfo = {
+    after: close.outside,
+    before: open.outside
+  };
+  return before + between + after;
+}
 function emphasisPeek(_, _1, state) {
-  return state.options.emphasis || '*'
-}
-
-;// CONCATENATED MODULE: ./node_modules/unist-util-visit/lib/index.js
-/**
- * @typedef {import('unist').Node} UnistNode
- * @typedef {import('unist').Parent} UnistParent
- * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
- */
-
-/**
- * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test
- *   Test from `unist-util-is`.
- *
- *   Note: we have remove and add `undefined`, because otherwise when generating
- *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,
- *   which doesnt work when publishing on npm.
- */
-
-// To do: use types from `unist-util-visit-parents` when its released.
-
-/**
- * @typedef {(
- *   Fn extends (value: any) => value is infer Thing
- *   ? Thing
- *   : Fallback
- * )} Predicate
- *   Get the value of a type guard `Fn`.
- * @template Fn
- *   Value; typically function that is a type guard (such as `(x): x is Y`).
- * @template Fallback
- *   Value to yield if `Fn` is not a type guard.
- */
-
-/**
- * @typedef {(
- *   Check extends null | undefined // No test.
- *   ? Value
- *   : Value extends {type: Check} // String (type) test.
- *   ? Value
- *   : Value extends Check // Partial test.
- *   ? Value
- *   : Check extends Function // Function test.
- *   ? Predicate<Check, Value> extends Value
- *     ? Predicate<Check, Value>
- *     : never
- *   : never // Some other test?
- * )} MatchesOne
- *   Check whether a node matches a primitive check in the type system.
- * @template Value
- *   Value; typically unist `Node`.
- * @template Check
- *   Value; typically `unist-util-is`-compatible test, but not arrays.
- */
-
-/**
- * @typedef {(
- *   Check extends Array<any>
- *   ? MatchesOne<Value, Check[keyof Check]>
- *   : MatchesOne<Value, Check>
- * )} Matches
- *   Check whether a node matches a check in the type system.
- * @template Value
- *   Value; typically unist `Node`.
- * @template Check
- *   Value; typically `unist-util-is`-compatible test.
- */
-
-/**
- * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint
- *   Number; capped reasonably.
- */
-
-/**
- * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment
- *   Increment a number in the type system.
- * @template {Uint} [I=0]
- *   Index.
- */
-
-/**
- * @typedef {(
- *   Node extends UnistParent
- *   ? Node extends {children: Array<infer Children>}
- *     ? Child extends Children ? Node : never
- *     : never
- *   : never
- * )} InternalParent
- *   Collect nodes that can be parents of `Child`.
- * @template {UnistNode} Node
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent
- *   Collect nodes in `Tree` that can be parents of `Child`.
- * @template {UnistNode} Tree
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- */
-
-/**
- * @typedef {(
- *   Depth extends Max
- *   ? never
- *   :
- *     | InternalParent<Node, Child>
- *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>
- * )} InternalAncestor
- *   Collect nodes in `Tree` that can be ancestors of `Child`.
- * @template {UnistNode} Node
- *   All node types in a tree.
- * @template {UnistNode} Child
- *   Node to search for.
- * @template {Uint} [Max=10]
- *   Max; searches up to this depth.
- * @template {Uint} [Depth=0]
- *   Current depth.
- */
-
-/**
- * @typedef {(
- *   Tree extends UnistParent
- *     ? Depth extends Max
- *       ? Tree
- *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>
- *     : Tree
- * )} InclusiveDescendant
- *   Collect all (inclusive) descendants of `Tree`.
- *
- *   >  **Note**: for performance reasons, this seems to be the fastest way to
- *   > recurse without actually running into an infinite loop, which the
- *   > previous version did.
- *   >
- *   > Practically, a max of `2` is typically enough assuming a `Root` is
- *   > passed, but it doesnt improve performance.
- *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.
- *   > Using up to `10` doesnt hurt or help either.
- * @template {UnistNode} Tree
- *   Tree type.
- * @template {Uint} [Max=10]
- *   Max; searches up to this depth.
- * @template {Uint} [Depth=0]
- *   Current depth.
- */
-
-/**
- * @callback Visitor
- *   Handle a node (matching `test`, if given).
- *
- *   Visitors are free to transform `node`.
- *   They can also transform `parent`.
- *
- *   Replacing `node` itself, if `SKIP` is not returned, still causes its
- *   descendants to be walked (which is a bug).
- *
- *   When adding or removing previous siblings of `node` (or next siblings, in
- *   case of reverse), the `Visitor` should return a new `Index` to specify the
- *   sibling to traverse after `node` is traversed.
- *   Adding or removing next siblings of `node` (or previous siblings, in case
- *   of reverse) is handled as expected without needing to return a new `Index`.
- *
- *   Removing the children property of `parent` still results in them being
- *   traversed.
- * @param {Visited} node
- *   Found node.
- * @param {Visited extends UnistNode ? number | undefined : never} index
- *   Index of `node` in `parent`.
- * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent
- *   Parent of `node`.
- * @returns {VisitorResult}
- *   What to do next.
- *
- *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.
- *   An `Action` is treated as a tuple of `[Action]`.
- *
- *   Passing a tuple back only makes sense if the `Action` is `SKIP`.
- *   When the `Action` is `EXIT`, that action can be returned.
- *   When the `Action` is `CONTINUE`, `Index` can be returned.
- * @template {UnistNode} [Visited=UnistNode]
- *   Visited node type.
- * @template {UnistParent} [Ancestor=UnistParent]
- *   Ancestor type.
- */
-
-/**
- * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch
- *   Build a typed `Visitor` function from a node and all possible parents.
- *
- *   It will infer which values are passed as `node` and which as `parent`.
- * @template {UnistNode} Visited
- *   Node type.
- * @template {UnistParent} Ancestor
- *   Parent type.
- */
-
-/**
- * @typedef {(
- *   BuildVisitorFromMatch<
- *     Matches<Descendant, Check>,
- *     Extract<Descendant, UnistParent>
- *   >
- * )} BuildVisitorFromDescendants
- *   Build a typed `Visitor` function from a list of descendants and a test.
- *
- *   It will infer which values are passed as `node` and which as `parent`.
- * @template {UnistNode} Descendant
- *   Node type.
- * @template {Test} Check
- *   Test type.
- */
-
-/**
- * @typedef {(
- *   BuildVisitorFromDescendants<
- *     InclusiveDescendant<Tree>,
- *     Check
- *   >
- * )} BuildVisitor
- *   Build a typed `Visitor` function from a tree and a test.
- *
- *   It will infer which values are passed as `node` and which as `parent`.
- * @template {UnistNode} [Tree=UnistNode]
- *   Node type.
- * @template {Test} [Check=Test]
- *   Test type.
- */
-
-
-
-
-
-/**
- * Visit nodes.
- *
- * This algorithm performs *depth-first* *tree traversal* in *preorder*
- * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
- *
- * You can choose for which nodes `visitor` is called by passing a `test`.
- * For complex tests, you should test yourself in `visitor`, as it will be
- * faster and will have improved type information.
- *
- * Walking the tree is an intensive task.
- * Make use of the return values of the visitor when possible.
- * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
- * to check if a node matches, and then perform different operations.
- *
- * You can change the tree.
- * See `Visitor` for more info.
- *
- * @overload
- * @param {Tree} tree
- * @param {Check} check
- * @param {BuildVisitor<Tree, Check>} visitor
- * @param {boolean | null | undefined} [reverse]
- * @returns {undefined}
- *
- * @overload
- * @param {Tree} tree
- * @param {BuildVisitor<Tree>} visitor
- * @param {boolean | null | undefined} [reverse]
- * @returns {undefined}
- *
- * @param {UnistNode} tree
- *   Tree to traverse.
- * @param {Visitor | Test} testOrVisitor
- *   `unist-util-is`-compatible test (optional, omit to pass a visitor).
- * @param {Visitor | boolean | null | undefined} [visitorOrReverse]
- *   Handle each node (when test is omitted, pass `reverse`).
- * @param {boolean | null | undefined} [maybeReverse=false]
- *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
- * @returns {undefined}
- *   Nothing.
- *
- * @template {UnistNode} Tree
- *   Node type.
- * @template {Test} Check
- *   `unist-util-is`-compatible test.
- */
+  return state.options.emphasis || "*";
+}
 function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
-  /** @type {boolean | null | undefined} */
-  let reverse
-  /** @type {Test} */
-  let test
-  /** @type {Visitor} */
-  let visitor
-
-  if (
-    typeof testOrVisitor === 'function' &&
-    typeof visitorOrReverse !== 'function'
-  ) {
-    test = undefined
-    visitor = testOrVisitor
-    reverse = visitorOrReverse
+  let reverse;
+  let test;
+  let visitor;
+  if (typeof testOrVisitor === "function" && true) {
+    test = void 0;
+    visitor = testOrVisitor;
+    reverse = visitorOrReverse;
   } else {
-    // @ts-expect-error: assume the overload with test was given.
-    test = testOrVisitor
-    // @ts-expect-error: assume the overload with test was given.
-    visitor = visitorOrReverse
-    reverse = maybeReverse
-  }
-
-  visitParents(tree, test, overload, reverse)
-
-  /**
-   * @param {UnistNode} node
-   * @param {Array<UnistParent>} parents
-   */
-  function overload(node, parents) {
-    const parent = parents[parents.length - 1]
-    const index = parent ? parent.children.indexOf(node) : undefined
-    return visitor(node, index, parent)
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-string/lib/index.js
-/**
- * @typedef {import('mdast').Nodes} Nodes
- *
- * @typedef Options
- *   Configuration (optional).
- * @property {boolean | null | undefined} [includeImageAlt=true]
- *   Whether to use `alt` for `image`s (default: `true`).
- * @property {boolean | null | undefined} [includeHtml=true]
- *   Whether to use `value` of HTML (default: `true`).
- */
-
-/** @type {Options} */
-const emptyOptions = {}
-
-/**
- * Get the text content of a node or list of nodes.
- *
- * Prefers the nodes plain-text fields, otherwise serializes its children,
- * and if the given value is an array, serialize the nodes in it.
- *
- * @param {unknown} [value]
- *   Thing to serialize, typically `Node`.
- * @param {Options | null | undefined} [options]
- *   Configuration (optional).
- * @returns {string}
- *   Serialized `value`.
- */
-function lib_toString(value, options) {
-  const settings = options || emptyOptions
-  const includeImageAlt =
-    typeof settings.includeImageAlt === 'boolean'
-      ? settings.includeImageAlt
-      : true
-  const includeHtml =
-    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true
-
-  return one(value, includeImageAlt, includeHtml)
-}
-
-/**
- * One node or several nodes.
- *
- * @param {unknown} value
- *   Thing to serialize.
- * @param {boolean} includeImageAlt
- *   Include image `alt`s.
- * @param {boolean} includeHtml
- *   Include HTML.
- * @returns {string}
- *   Serialized node.
- */
+    test = testOrVisitor;
+    visitor = visitorOrReverse;
+    reverse = maybeReverse;
+  }
+  visitParents(tree, test, overload, reverse);
+  function overload(node2, parents) {
+    const parent = parents[parents.length - 1];
+    const index = parent ? parent.children.indexOf(node2) : void 0;
+    return visitor(node2, index, parent);
+  }
+}
+const emptyOptions = {};
+function toString(value, options) {
+  const settings = emptyOptions;
+  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
+  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
+  return one(value, includeImageAlt, includeHtml);
+}
 function one(value, includeImageAlt, includeHtml) {
   if (node(value)) {
-    if ('value' in value) {
-      return value.type === 'html' && !includeHtml ? '' : value.value
+    if ("value" in value) {
+      return value.type === "html" && !includeHtml ? "" : value.value;
     }
-
-    if (includeImageAlt && 'alt' in value && value.alt) {
-      return value.alt
+    if (includeImageAlt && "alt" in value && value.alt) {
+      return value.alt;
     }
-
-    if ('children' in value) {
-      return lib_all(value.children, includeImageAlt, includeHtml)
+    if ("children" in value) {
+      return all(value.children, includeImageAlt, includeHtml);
     }
   }
-
   if (Array.isArray(value)) {
-    return lib_all(value, includeImageAlt, includeHtml)
-  }
-
-  return ''
-}
-
-/**
- * Serialize a list of nodes.
- *
- * @param {Array<unknown>} values
- *   Thing to serialize.
- * @param {boolean} includeImageAlt
- *   Include image `alt`s.
- * @param {boolean} includeHtml
- *   Include HTML.
- * @returns {string}
- *   Serialized nodes.
- */
-function lib_all(values, includeImageAlt, includeHtml) {
-  /** @type {Array<string>} */
-  const result = []
-  let index = -1
-
+    return all(value, includeImageAlt, includeHtml);
+  }
+  return "";
+}
+function all(values, includeImageAlt, includeHtml) {
+  const result = [];
+  let index = -1;
   while (++index < values.length) {
-    result[index] = one(values[index], includeImageAlt, includeHtml)
-  }
-
-  return result.join('')
-}
-
-/**
- * Check if `value` looks like a node.
- *
- * @param {unknown} value
- *   Thing.
- * @returns {value is Nodes}
- *   Whether `value` is a node.
- */
+    result[index] = one(values[index], includeImageAlt, includeHtml);
+  }
+  return result.join("");
+}
 function node(value) {
-  return Boolean(value && typeof value === 'object')
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
-/**
- * @typedef {import('mdast').Heading} Heading
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-/**
- * @param {Heading} node
- * @param {State} state
- * @returns {boolean}
- */
-function formatHeadingAsSetext(node, state) {
-  let literalWithBreak = false
-
-  // Look for literals with a line break.
-  // Note that this also
-  visit(node, function (node) {
-    if (
-      ('value' in node && /\r?\n|\r/.test(node.value)) ||
-      node.type === 'break'
-    ) {
-      literalWithBreak = true
-      return EXIT
+  return Boolean(value && typeof value === "object");
+}
+function formatHeadingAsSetext(node2, state) {
+  let literalWithBreak = false;
+  visit(node2, function(node3) {
+    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
+      literalWithBreak = true;
+      return EXIT;
     }
-  })
-
+  });
   return Boolean(
-    (!node.depth || node.depth < 3) &&
-      lib_toString(node) &&
-      (state.options.setext || literalWithBreak)
-  )
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/heading.js
-/**
- * @typedef {import('mdast').Heading} Heading
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Heading} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function heading(node, _, state, info) {
-  const rank = Math.max(Math.min(6, node.depth || 1), 1)
-  const tracker = state.createTracker(info)
-
-  if (formatHeadingAsSetext(node, state)) {
-    const exit = state.enter('headingSetext')
-    const subexit = state.enter('phrasing')
-    const value = state.containerPhrasing(node, {
+    (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
+  );
+}
+function heading(node2, _, state, info) {
+  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
+  const tracker = state.createTracker(info);
+  if (formatHeadingAsSetext(node2, state)) {
+    const exit2 = state.enter("headingSetext");
+    const subexit2 = state.enter("phrasing");
+    const value2 = state.containerPhrasing(node2, {
       ...tracker.current(),
-      before: '\n',
-      after: '\n'
-    })
-    subexit()
-    exit()
-
-    return (
-      value +
-      '\n' +
-      (rank === 1 ? '=' : '-').repeat(
-        // The whole size
-        value.length -
-          // Minus the position of the character after the last EOL (or
-          // 0 if there is none)
-          (Math.max(value.lastIndexOf('\r'), value.lastIndexOf('\n')) + 1)
-      )
-    )
-  }
-
-  const sequence = '#'.repeat(rank)
-  const exit = state.enter('headingAtx')
-  const subexit = state.enter('phrasing')
-
-  // Note: for proper tracking, we should reset the output positions when there
-  // is no content returned, because then the space is not output.
-  // Practically, in that case, there is no content, so it doesnt matter that
-  // weve tracked one too many characters.
-  tracker.move(sequence + ' ')
-
-  let value = state.containerPhrasing(node, {
-    before: '# ',
-    after: '\n',
+      before: "\n",
+      after: "\n"
+    });
+    subexit2();
+    exit2();
+    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
+      // The whole size
+      value2.length - // Minus the position of the character after the last EOL (or
+      // 0 if there is none)
+      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
+    );
+  }
+  const sequence = "#".repeat(rank);
+  const exit = state.enter("headingAtx");
+  const subexit = state.enter("phrasing");
+  tracker.move(sequence + " ");
+  let value = state.containerPhrasing(node2, {
+    before: "# ",
+    after: "\n",
     ...tracker.current()
-  })
-
+  });
   if (/^[\t ]/.test(value)) {
-    // To do: what effect has the character reference on tracking?
-    value =
-      '&#x' +
-      value.charCodeAt(0).toString(16).toUpperCase() +
-      ';' +
-      value.slice(1)
-  }
-
-  value = value ? sequence + ' ' + value : sequence
-
+    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
+  }
+  value = value ? sequence + " " + value : sequence;
   if (state.options.closeAtx) {
-    value += ' ' + sequence
-  }
-
-  subexit()
-  exit()
-
-  return value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/html.js
-/**
- * @typedef {import('mdast').Html} Html
- */
-
-html.peek = htmlPeek
-
-/**
- * @param {Html} node
- * @returns {string}
- */
-function html(node) {
-  return node.value || ''
-}
-
-/**
- * @returns {string}
- */
+    value += " " + sequence;
+  }
+  subexit();
+  exit();
+  return value;
+}
+html.peek = htmlPeek;
+function html(node2) {
+  return node2.value || "";
+}
 function htmlPeek() {
-  return '<'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/image.js
-/**
- * @typedef {import('mdast').Image} Image
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-image_image.peek = imagePeek
-
-/**
- * @param {Image} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function image_image(node, _, state, info) {
-  const quote = checkQuote(state)
-  const suffix = quote === '"' ? 'Quote' : 'Apostrophe'
-  const exit = state.enter('image')
-  let subexit = state.enter('label')
-  const tracker = state.createTracker(info)
-  let value = tracker.move('![')
+  return "<";
+}
+image.peek = imagePeek;
+function image(node2, _, state, info) {
+  const quote = checkQuote(state);
+  const suffix = quote === '"' ? "Quote" : "Apostrophe";
+  const exit = state.enter("image");
+  let subexit = state.enter("label");
+  const tracker = state.createTracker(info);
+  let value = tracker.move("![");
   value += tracker.move(
-    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})
-  )
-  value += tracker.move('](')
-
-  subexit()
-
+    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
+  );
+  value += tracker.move("](");
+  subexit();
   if (
     // If theres no url but there is a title
-    (!node.url && node.title) ||
-    // If there are control characters or whitespace.
-    /[\0- \u007F]/.test(node.url)
+    !node2.url && node2.title || // If there are control characters or whitespace.
+    /[\0- \u007F]/.test(node2.url)
   ) {
-    subexit = state.enter('destinationLiteral')
-    value += tracker.move('<')
+    subexit = state.enter("destinationLiteral");
+    value += tracker.move("<");
     value += tracker.move(
-      state.safe(node.url, {before: value, after: '>', ...tracker.current()})
-    )
-    value += tracker.move('>')
+      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
+    );
+    value += tracker.move(">");
   } else {
-    // No whitespace, raw is prettier.
-    subexit = state.enter('destinationRaw')
+    subexit = state.enter("destinationRaw");
     value += tracker.move(
-      state.safe(node.url, {
+      state.safe(node2.url, {
         before: value,
-        after: node.title ? ' ' : ')',
+        after: node2.title ? " " : ")",
         ...tracker.current()
       })
-    )
-  }
-
-  subexit()
-
-  if (node.title) {
-    subexit = state.enter(`title${suffix}`)
-    value += tracker.move(' ' + quote)
+    );
+  }
+  subexit();
+  if (node2.title) {
+    subexit = state.enter(`title${suffix}`);
+    value += tracker.move(" " + quote);
     value += tracker.move(
-      state.safe(node.title, {
+      state.safe(node2.title, {
         before: value,
         after: quote,
         ...tracker.current()
       })
-    )
-    value += tracker.move(quote)
-    subexit()
-  }
-
-  value += tracker.move(')')
-  exit()
-
-  return value
-}
-
-/**
- * @returns {string}
- */
+    );
+    value += tracker.move(quote);
+    subexit();
+  }
+  value += tracker.move(")");
+  exit();
+  return value;
+}
 function imagePeek() {
-  return '!'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
-/**
- * @typedef {import('mdast').ImageReference} ImageReference
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-imageReference.peek = imageReferencePeek
-
-/**
- * @param {ImageReference} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function imageReference(node, _, state, info) {
-  const type = node.referenceType
-  const exit = state.enter('imageReference')
-  let subexit = state.enter('label')
-  const tracker = state.createTracker(info)
-  let value = tracker.move('![')
-  const alt = state.safe(node.alt, {
+  return "!";
+}
+imageReference.peek = imageReferencePeek;
+function imageReference(node2, _, state, info) {
+  const type = node2.referenceType;
+  const exit = state.enter("imageReference");
+  let subexit = state.enter("label");
+  const tracker = state.createTracker(info);
+  let value = tracker.move("![");
+  const alt = state.safe(node2.alt, {
     before: value,
-    after: ']',
+    after: "]",
     ...tracker.current()
-  })
-  value += tracker.move(alt + '][')
-
-  subexit()
-  // Hide the fact that were in phrasing, because escapes dont work.
-  const stack = state.stack
-  state.stack = []
-  subexit = state.enter('reference')
-  // Note: for proper tracking, we should reset the output positions when we end
-  // up making a `shortcut` reference, because then there is no brace output.
-  // Practically, in that case, there is no content, so it doesnt matter that
-  // weve tracked one too many characters.
-  const reference = state.safe(state.associationId(node), {
+  });
+  value += tracker.move(alt + "][");
+  subexit();
+  const stack = state.stack;
+  state.stack = [];
+  subexit = state.enter("reference");
+  const reference = state.safe(state.associationId(node2), {
     before: value,
-    after: ']',
+    after: "]",
     ...tracker.current()
-  })
-  subexit()
-  state.stack = stack
-  exit()
-
-  if (type === 'full' || !alt || alt !== reference) {
-    value += tracker.move(reference + ']')
-  } else if (type === 'shortcut') {
-    // Remove the unwanted `[`.
-    value = value.slice(0, -1)
+  });
+  subexit();
+  state.stack = stack;
+  exit();
+  if (type === "full" || !alt || alt !== reference) {
+    value += tracker.move(reference + "]");
+  } else if (type === "shortcut") {
+    value = value.slice(0, -1);
   } else {
-    value += tracker.move(']')
+    value += tracker.move("]");
   }
-
-  return value
+  return value;
 }
-
-/**
- * @returns {string}
- */
 function imageReferencePeek() {
-  return '!'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
-/**
- * @typedef {import('mdast').InlineCode} InlineCode
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').State} State
- */
-
-inlineCode.peek = inlineCodePeek
-
-/**
- * @param {InlineCode} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @returns {string}
- */
-function inlineCode(node, _, state) {
-  let value = node.value || ''
-  let sequence = '`'
-  let index = -1
-
-  // If there is a single grave accent on its own in the code, use a fence of
-  // two.
-  // If there are two in a row, use one.
-  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {
-    sequence += '`'
-  }
-
-  // If this is not just spaces or eols (tabs dont count), and either the
-  // first or last character are a space, eol, or tick, then pad with spaces.
-  if (
-    /[^ \r\n]/.test(value) &&
-    ((/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value)) || /^`|`$/.test(value))
-  ) {
-    value = ' ' + value + ' '
-  }
-
-  // We have a potential problem: certain characters after eols could result in
-  // blocks being seen.
-  // For example, if someone injected the string `'\n# b'`, then that would
-  // result in an ATX heading.
-  // We cant escape characters in `inlineCode`, but because eols are
-  // transformed to spaces when going from markdown to HTML anyway, we can swap
-  // them out.
+  return "!";
+}
+inlineCode.peek = inlineCodePeek;
+function inlineCode(node2, _, state) {
+  let value = node2.value || "";
+  let sequence = "`";
+  let index = -1;
+  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
+    sequence += "`";
+  }
+  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
+    value = " " + value + " ";
+  }
   while (++index < state.unsafe.length) {
-    const pattern = state.unsafe[index]
-    const expression = state.compilePattern(pattern)
-    /** @type {RegExpExecArray | null} */
-    let match
-
-    // Only look for `atBreak`s.
-    // Btw: note that `atBreak` patterns will always start the regex at LF or
-    // CR.
-    if (!pattern.atBreak) continue
-
-    while ((match = expression.exec(value))) {
-      let position = match.index
-
-      // Support CRLF (patterns only look for one of the characters).
-      if (
-        value.charCodeAt(position) === 10 /* `\n` */ &&
-        value.charCodeAt(position - 1) === 13 /* `\r` */
-      ) {
-        position--
+    const pattern = state.unsafe[index];
+    const expression = state.compilePattern(pattern);
+    let match;
+    if (!pattern.atBreak) continue;
+    while (match = expression.exec(value)) {
+      let position = match.index;
+      if (value.charCodeAt(position) === 10 && value.charCodeAt(position - 1) === 13) {
+        position--;
       }
-
-      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)
+      value = value.slice(0, position) + " " + value.slice(match.index + 1);
     }
   }
-
-  return sequence + value + sequence
+  return sequence + value + sequence;
 }
-
-/**
- * @returns {string}
- */
 function inlineCodePeek() {
-  return '`'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
-/**
- * @typedef {import('mdast').Link} Link
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Link} node
- * @param {State} state
- * @returns {boolean}
- */
-function formatLinkAsAutolink(node, state) {
-  const raw = lib_toString(node)
-
+  return "`";
+}
+function formatLinkAsAutolink(node2, state) {
+  const raw = toString(node2);
   return Boolean(
-    !state.options.resourceLink &&
-      // If theres a url
-      node.url &&
-      // And theres a no title
-      !node.title &&
-      // And the content of `node` is a single text node
-      node.children &&
-      node.children.length === 1 &&
-      node.children[0].type === 'text' &&
-      // And if the url is the same as the content
-      (raw === node.url || 'mailto:' + raw === node.url) &&
-      // And that starts w/ a protocol
-      /^[a-z][a-z+.-]+:/i.test(node.url) &&
-      // And that doesnt contain ASCII control codes (character escapes and
-      // references dont work), space, or angle brackets
-      !/[\0- <>\u007F]/.test(node.url)
-  )
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/link.js
-/**
- * @typedef {import('mdast').Link} Link
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Exit} Exit
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-link_link.peek = linkPeek
-
-/**
- * @param {Link} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function link_link(node, _, state, info) {
-  const quote = checkQuote(state)
-  const suffix = quote === '"' ? 'Quote' : 'Apostrophe'
-  const tracker = state.createTracker(info)
-  /** @type {Exit} */
-  let exit
-  /** @type {Exit} */
-  let subexit
-
-  if (formatLinkAsAutolink(node, state)) {
-    // Hide the fact that were in phrasing, because escapes dont work.
-    const stack = state.stack
-    state.stack = []
-    exit = state.enter('autolink')
-    let value = tracker.move('<')
-    value += tracker.move(
-      state.containerPhrasing(node, {
-        before: value,
-        after: '>',
+    !state.options.resourceLink && // If theres a url
+    node2.url && // And theres a no title
+    !node2.title && // And the content of `node` is a single text node
+    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content
+    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocol
+    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnt contain ASCII control codes (character escapes and
+    // references dont work), space, or angle brackets
+    !/[\0- <>\u007F]/.test(node2.url)
+  );
+}
+link.peek = linkPeek;
+function link(node2, _, state, info) {
+  const quote = checkQuote(state);
+  const suffix = quote === '"' ? "Quote" : "Apostrophe";
+  const tracker = state.createTracker(info);
+  let exit;
+  let subexit;
+  if (formatLinkAsAutolink(node2, state)) {
+    const stack = state.stack;
+    state.stack = [];
+    exit = state.enter("autolink");
+    let value2 = tracker.move("<");
+    value2 += tracker.move(
+      state.containerPhrasing(node2, {
+        before: value2,
+        after: ">",
         ...tracker.current()
       })
-    )
-    value += tracker.move('>')
-    exit()
-    state.stack = stack
-    return value
-  }
-
-  exit = state.enter('link')
-  subexit = state.enter('label')
-  let value = tracker.move('[')
+    );
+    value2 += tracker.move(">");
+    exit();
+    state.stack = stack;
+    return value2;
+  }
+  exit = state.enter("link");
+  subexit = state.enter("label");
+  let value = tracker.move("[");
   value += tracker.move(
-    state.containerPhrasing(node, {
+    state.containerPhrasing(node2, {
       before: value,
-      after: '](',
+      after: "](",
       ...tracker.current()
     })
-  )
-  value += tracker.move('](')
-  subexit()
-
+  );
+  value += tracker.move("](");
+  subexit();
   if (
     // If theres no url but there is a title
-    (!node.url && node.title) ||
-    // If there are control characters or whitespace.
-    /[\0- \u007F]/.test(node.url)
+    !node2.url && node2.title || // If there are control characters or whitespace.
+    /[\0- \u007F]/.test(node2.url)
   ) {
-    subexit = state.enter('destinationLiteral')
-    value += tracker.move('<')
+    subexit = state.enter("destinationLiteral");
+    value += tracker.move("<");
     value += tracker.move(
-      state.safe(node.url, {before: value, after: '>', ...tracker.current()})
-    )
-    value += tracker.move('>')
+      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
+    );
+    value += tracker.move(">");
   } else {
-    // No whitespace, raw is prettier.
-    subexit = state.enter('destinationRaw')
+    subexit = state.enter("destinationRaw");
     value += tracker.move(
-      state.safe(node.url, {
+      state.safe(node2.url, {
         before: value,
-        after: node.title ? ' ' : ')',
+        after: node2.title ? " " : ")",
         ...tracker.current()
       })
-    )
-  }
-
-  subexit()
-
-  if (node.title) {
-    subexit = state.enter(`title${suffix}`)
-    value += tracker.move(' ' + quote)
+    );
+  }
+  subexit();
+  if (node2.title) {
+    subexit = state.enter(`title${suffix}`);
+    value += tracker.move(" " + quote);
     value += tracker.move(
-      state.safe(node.title, {
+      state.safe(node2.title, {
         before: value,
         after: quote,
         ...tracker.current()
       })
-    )
-    value += tracker.move(quote)
-    subexit()
-  }
-
-  value += tracker.move(')')
-
-  exit()
-  return value
-}
-
-/**
- * @param {Link} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @returns {string}
- */
-function linkPeek(node, _, state) {
-  return formatLinkAsAutolink(node, state) ? '<' : '['
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
-/**
- * @typedef {import('mdast').LinkReference} LinkReference
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-linkReference.peek = linkReferencePeek
-
-/**
- * @param {LinkReference} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function linkReference(node, _, state, info) {
-  const type = node.referenceType
-  const exit = state.enter('linkReference')
-  let subexit = state.enter('label')
-  const tracker = state.createTracker(info)
-  let value = tracker.move('[')
-  const text = state.containerPhrasing(node, {
+    );
+    value += tracker.move(quote);
+    subexit();
+  }
+  value += tracker.move(")");
+  exit();
+  return value;
+}
+function linkPeek(node2, _, state) {
+  return formatLinkAsAutolink(node2, state) ? "<" : "[";
+}
+linkReference.peek = linkReferencePeek;
+function linkReference(node2, _, state, info) {
+  const type = node2.referenceType;
+  const exit = state.enter("linkReference");
+  let subexit = state.enter("label");
+  const tracker = state.createTracker(info);
+  let value = tracker.move("[");
+  const text2 = state.containerPhrasing(node2, {
     before: value,
-    after: ']',
+    after: "]",
     ...tracker.current()
-  })
-  value += tracker.move(text + '][')
-
-  subexit()
-  // Hide the fact that were in phrasing, because escapes dont work.
-  const stack = state.stack
-  state.stack = []
-  subexit = state.enter('reference')
-  // Note: for proper tracking, we should reset the output positions when we end
-  // up making a `shortcut` reference, because then there is no brace output.
-  // Practically, in that case, there is no content, so it doesnt matter that
-  // weve tracked one too many characters.
-  const reference = state.safe(state.associationId(node), {
+  });
+  value += tracker.move(text2 + "][");
+  subexit();
+  const stack = state.stack;
+  state.stack = [];
+  subexit = state.enter("reference");
+  const reference = state.safe(state.associationId(node2), {
     before: value,
-    after: ']',
+    after: "]",
     ...tracker.current()
-  })
-  subexit()
-  state.stack = stack
-  exit()
-
-  if (type === 'full' || !text || text !== reference) {
-    value += tracker.move(reference + ']')
-  } else if (type === 'shortcut') {
-    // Remove the unwanted `[`.
-    value = value.slice(0, -1)
+  });
+  subexit();
+  state.stack = stack;
+  exit();
+  if (type === "full" || !text2 || text2 !== reference) {
+    value += tracker.move(reference + "]");
+  } else if (type === "shortcut") {
+    value = value.slice(0, -1);
   } else {
-    value += tracker.move(']')
+    value += tracker.move("]");
   }
-
-  return value
+  return value;
 }
-
-/**
- * @returns {string}
- */
 function linkReferencePeek() {
-  return '['
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['bullet'], null | undefined>}
- */
+  return "[";
+}
 function checkBullet(state) {
-  const marker = state.options.bullet || '*'
-
-  if (marker !== '*' && marker !== '+' && marker !== '-') {
+  const marker = state.options.bullet || "*";
+  if (marker !== "*" && marker !== "+" && marker !== "-") {
     throw new Error(
-      'Cannot serialize items with `' +
-        marker +
-        '` for `options.bullet`, expected `*`, `+`, or `-`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['bullet'], null | undefined>}
- */
+      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
+    );
+  }
+  return marker;
+}
 function checkBulletOther(state) {
-  const bullet = checkBullet(state)
-  const bulletOther = state.options.bulletOther
-
+  const bullet = checkBullet(state);
+  const bulletOther = state.options.bulletOther;
   if (!bulletOther) {
-    return bullet === '*' ? '-' : '*'
+    return bullet === "*" ? "-" : "*";
   }
-
-  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {
+  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
     throw new Error(
-      'Cannot serialize items with `' +
-        bulletOther +
-        '` for `options.bulletOther`, expected `*`, `+`, or `-`'
-    )
+      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
+    );
   }
-
   if (bulletOther === bullet) {
     throw new Error(
-      'Expected `bullet` (`' +
-        bullet +
-        '`) and `bulletOther` (`' +
-        bulletOther +
-        '`) to be different'
-    )
-  }
-
-  return bulletOther
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['bulletOrdered'], null | undefined>}
- */
+      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
+    );
+  }
+  return bulletOther;
+}
 function checkBulletOrdered(state) {
-  const marker = state.options.bulletOrdered || '.'
-
-  if (marker !== '.' && marker !== ')') {
+  const marker = state.options.bulletOrdered || ".";
+  if (marker !== "." && marker !== ")") {
     throw new Error(
-      'Cannot serialize items with `' +
-        marker +
-        '` for `options.bulletOrdered`, expected `.` or `)`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-rule.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['rule'], null | undefined>}
- */
+      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
+    );
+  }
+  return marker;
+}
 function checkRule(state) {
-  const marker = state.options.rule || '*'
-
-  if (marker !== '*' && marker !== '-' && marker !== '_') {
+  const marker = state.options.rule || "*";
+  if (marker !== "*" && marker !== "-" && marker !== "_") {
     throw new Error(
-      'Cannot serialize rules with `' +
-        marker +
-        '` for `options.rule`, expected `*`, `-`, or `_`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/list.js
-/**
- * @typedef {import('mdast').List} List
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-
-
-/**
- * @param {List} node
- * @param {Parents | undefined} parent
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function list(node, parent, state, info) {
-  const exit = state.enter('list')
-  const bulletCurrent = state.bulletCurrent
-  /** @type {string} */
-  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)
-  /** @type {string} */
-  const bulletOther = node.ordered
-    ? bullet === '.'
-      ? ')'
-      : '.'
-    : checkBulletOther(state)
-  let useDifferentMarker =
-    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false
-
-  if (!node.ordered) {
-    const firstListItem = node.children ? node.children[0] : undefined
-
-    // If theres an empty first list item directly in two list items,
-    // we have to use a different bullet:
-    //
-    // ```markdown
-    // * - *
-    // ```
-    //
-    // because otherwise it would become one big thematic break.
+      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
+    );
+  }
+  return marker;
+}
+function list(node2, parent, state, info) {
+  const exit = state.enter("list");
+  const bulletCurrent = state.bulletCurrent;
+  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
+  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
+  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
+  if (!node2.ordered) {
+    const firstListItem = node2.children ? node2.children[0] : void 0;
     if (
       // Bullet could be used as a thematic break marker:
-      (bullet === '*' || bullet === '-') &&
-      // Empty first list item:
-      firstListItem &&
-      (!firstListItem.children || !firstListItem.children[0]) &&
-      // Directly in two other list items:
-      state.stack[state.stack.length - 1] === 'list' &&
-      state.stack[state.stack.length - 2] === 'listItem' &&
-      state.stack[state.stack.length - 3] === 'list' &&
-      state.stack[state.stack.length - 4] === 'listItem' &&
-      // That are each the first child.
-      state.indexStack[state.indexStack.length - 1] === 0 &&
-      state.indexStack[state.indexStack.length - 2] === 0 &&
-      state.indexStack[state.indexStack.length - 3] === 0
+      (bullet === "*" || bullet === "-") && // Empty first list item:
+      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
+      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
+      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
     ) {
-      useDifferentMarker = true
+      useDifferentMarker = true;
     }
-
-    // If theres a thematic break at the start of the first list item,
-    // we have to use a different bullet:
-    //
-    // ```markdown
-    // * ---
-    // ```
-    //
-    // because otherwise it would become one big thematic break.
     if (checkRule(state) === bullet && firstListItem) {
-      let index = -1
-
-      while (++index < node.children.length) {
-        const item = node.children[index]
-
-        if (
-          item &&
-          item.type === 'listItem' &&
-          item.children &&
-          item.children[0] &&
-          item.children[0].type === 'thematicBreak'
-        ) {
-          useDifferentMarker = true
-          break
+      let index = -1;
+      while (++index < node2.children.length) {
+        const item = node2.children[index];
+        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
+          useDifferentMarker = true;
+          break;
         }
       }
     }
   }
-
   if (useDifferentMarker) {
-    bullet = bulletOther
-  }
-
-  state.bulletCurrent = bullet
-  const value = state.containerFlow(node, info)
-  state.bulletLastUsed = bullet
-  state.bulletCurrent = bulletCurrent
-  exit()
-  return value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['listItemIndent'], null | undefined>}
- */
+    bullet = bulletOther;
+  }
+  state.bulletCurrent = bullet;
+  const value = state.containerFlow(node2, info);
+  state.bulletLastUsed = bullet;
+  state.bulletCurrent = bulletCurrent;
+  exit();
+  return value;
+}
 function checkListItemIndent(state) {
-  const style = state.options.listItemIndent || 'one'
-
-  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {
+  const style = state.options.listItemIndent || "one";
+  if (style !== "tab" && style !== "one" && style !== "mixed") {
     throw new Error(
-      'Cannot serialize items with `' +
-        style +
-        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'
-    )
-  }
-
-  return style
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/list-item.js
-/**
- * @typedef {import('mdast').ListItem} ListItem
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').Map} Map
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-/**
- * @param {ListItem} node
- * @param {Parents | undefined} parent
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function listItem(node, parent, state, info) {
-  const listItemIndent = checkListItemIndent(state)
-  let bullet = state.bulletCurrent || checkBullet(state)
-
-  // Add the marker value for ordered lists.
-  if (parent && parent.type === 'list' && parent.ordered) {
-    bullet =
-      (typeof parent.start === 'number' && parent.start > -1
-        ? parent.start
-        : 1) +
-      (state.options.incrementListMarker === false
-        ? 0
-        : parent.children.indexOf(node)) +
-      bullet
-  }
-
-  let size = bullet.length + 1
-
-  if (
-    listItemIndent === 'tab' ||
-    (listItemIndent === 'mixed' &&
-      ((parent && parent.type === 'list' && parent.spread) || node.spread))
-  ) {
-    size = Math.ceil(size / 4) * 4
+      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
+    );
+  }
+  return style;
+}
+function listItem(node2, parent, state, info) {
+  const listItemIndent = checkListItemIndent(state);
+  let bullet = state.bulletCurrent || checkBullet(state);
+  if (parent && parent.type === "list" && parent.ordered) {
+    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
+  }
+  let size = bullet.length + 1;
+  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
+    size = Math.ceil(size / 4) * 4;
   }
-
-  const tracker = state.createTracker(info)
-  tracker.move(bullet + ' '.repeat(size - bullet.length))
-  tracker.shift(size)
-  const exit = state.enter('listItem')
+  const tracker = state.createTracker(info);
+  tracker.move(bullet + " ".repeat(size - bullet.length));
+  tracker.shift(size);
+  const exit = state.enter("listItem");
   const value = state.indentLines(
-    state.containerFlow(node, tracker.current()),
-    map
-  )
-  exit()
-
-  return value
-
-  /** @type {Map} */
-  function map(line, index, blank) {
+    state.containerFlow(node2, tracker.current()),
+    map2
+  );
+  exit();
+  return value;
+  function map2(line, index, blank) {
     if (index) {
-      return (blank ? '' : ' '.repeat(size)) + line
+      return (blank ? "" : " ".repeat(size)) + line;
     }
-
-    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
-/**
- * @typedef {import('mdast').Paragraph} Paragraph
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {Paragraph} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function paragraph(node, _, state, info) {
-  const exit = state.enter('paragraph')
-  const subexit = state.enter('phrasing')
-  const value = state.containerPhrasing(node, info)
-  subexit()
-  exit()
-  return value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-phrasing/lib/index.js
-/**
- * @typedef {import('mdast').Html} Html
- * @typedef {import('mdast').PhrasingContent} PhrasingContent
- */
-
-
-
-/**
- * Check if the given value is *phrasing content*.
- *
- * >  **Note**: Excludes `html`, which can be both phrasing or flow.
- *
- * @param node
- *   Thing to check, typically `Node`.
- * @returns
- *   Whether `value` is phrasing content.
- */
-
-const phrasing =
+    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line;
+  }
+}
+function paragraph(node2, _, state, info) {
+  const exit = state.enter("paragraph");
+  const subexit = state.enter("phrasing");
+  const value = state.containerPhrasing(node2, info);
+  subexit();
+  exit();
+  return value;
+}
+const phrasing = (
   /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
-  (
-    convert([
-      'break',
-      'delete',
-      'emphasis',
-      // To do: next major: removed since footnotes were added to GFM.
-      'footnote',
-      'footnoteReference',
-      'image',
-      'imageReference',
-      'inlineCode',
-      // Enabled by `mdast-util-math`:
-      'inlineMath',
-      'link',
-      'linkReference',
-      // Enabled by `mdast-util-mdx`:
-      'mdxJsxTextElement',
-      // Enabled by `mdast-util-mdx`:
-      'mdxTextExpression',
-      'strong',
-      'text',
-      // Enabled by `mdast-util-directive`:
-      'textDirective'
-    ])
-  )
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/root.js
-/**
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').Root} Root
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-/**
- * @param {Root} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function root(node, _, state, info) {
-  // Note: `html` nodes are ambiguous.
-  const hasPhrasing = node.children.some(function (d) {
-    return phrasing(d)
-  })
-  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow
-  return fn.call(state, node, info)
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-strong.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['strong'], null | undefined>}
- */
+  convert([
+    "break",
+    "delete",
+    "emphasis",
+    // To do: next major: removed since footnotes were added to GFM.
+    "footnote",
+    "footnoteReference",
+    "image",
+    "imageReference",
+    "inlineCode",
+    // Enabled by `mdast-util-math`:
+    "inlineMath",
+    "link",
+    "linkReference",
+    // Enabled by `mdast-util-mdx`:
+    "mdxJsxTextElement",
+    // Enabled by `mdast-util-mdx`:
+    "mdxTextExpression",
+    "strong",
+    "text",
+    // Enabled by `mdast-util-directive`:
+    "textDirective"
+  ])
+);
+function root(node2, _, state, info) {
+  const hasPhrasing = node2.children.some(function(d) {
+    return phrasing(d);
+  });
+  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
+  return container.call(state, node2, info);
+}
 function checkStrong(state) {
-  const marker = state.options.strong || '*'
-
-  if (marker !== '*' && marker !== '_') {
+  const marker = state.options.strong || "*";
+  if (marker !== "*" && marker !== "_") {
     throw new Error(
-      'Cannot serialize strong with `' +
-        marker +
-        '` for `options.strong`, expected `*`, or `_`'
-    )
-  }
-
-  return marker
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/strong.js
-/**
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').Strong} Strong
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-
-
-strong.peek = strongPeek
-
-// To do: there are cases where emphasis cannot form depending on the
-// previous or next character of sequences.
-// Theres no way around that though, except for injecting zero-width stuff.
-// Do we need to safeguard against that?
-/**
- * @param {Strong} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function strong(node, _, state, info) {
-  const marker = checkStrong(state)
-  const exit = state.enter('strong')
-  const tracker = state.createTracker(info)
-  let value = tracker.move(marker + marker)
-  value += tracker.move(
-    state.containerPhrasing(node, {
-      before: value,
+      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
+    );
+  }
+  return marker;
+}
+strong.peek = strongPeek;
+function strong(node2, _, state, info) {
+  const marker = checkStrong(state);
+  const exit = state.enter("strong");
+  const tracker = state.createTracker(info);
+  const before = tracker.move(marker + marker);
+  let between = tracker.move(
+    state.containerPhrasing(node2, {
       after: marker,
+      before,
       ...tracker.current()
     })
-  )
-  value += tracker.move(marker + marker)
-  exit()
-  return value
-}
-
-/**
- * @param {Strong} _
- * @param {Parents | undefined} _1
- * @param {State} state
- * @returns {string}
- */
+  );
+  const betweenHead = between.charCodeAt(0);
+  const open = encodeInfo(
+    info.before.charCodeAt(info.before.length - 1),
+    betweenHead,
+    marker
+  );
+  if (open.inside) {
+    between = encodeCharacterReference(betweenHead) + between.slice(1);
+  }
+  const betweenTail = between.charCodeAt(between.length - 1);
+  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
+  if (close.inside) {
+    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
+  }
+  const after = tracker.move(marker + marker);
+  exit();
+  state.attentionEncodeSurroundingInfo = {
+    after: close.outside,
+    before: open.outside
+  };
+  return before + between + after;
+}
 function strongPeek(_, _1, state) {
-  return state.options.strong || '*'
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/text.js
-/**
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').Text} Text
- * @typedef {import('../types.js').Info} Info
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {Text} node
- * @param {Parents | undefined} _
- * @param {State} state
- * @param {Info} info
- * @returns {string}
- */
-function text_text(node, _, state, info) {
-  return state.safe(node.value, info)
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
-/**
- * @typedef {import('../types.js').Options} Options
- * @typedef {import('../types.js').State} State
- */
-
-/**
- * @param {State} state
- * @returns {Exclude<Options['ruleRepetition'], null | undefined>}
- */
+  return state.options.strong || "*";
+}
+function text(node2, _, state, info) {
+  return state.safe(node2.value, info);
+}
 function checkRuleRepetition(state) {
-  const repetition = state.options.ruleRepetition || 3
-
+  const repetition = state.options.ruleRepetition || 3;
   if (repetition < 3) {
     throw new Error(
-      'Cannot serialize rules with repetition `' +
-        repetition +
-        '` for `options.ruleRepetition`, expected `3` or more'
-    )
-  }
-
-  return repetition
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
-/**
- * @typedef {import('mdast').Parents} Parents
- * @typedef {import('mdast').ThematicBreak} ThematicBreak
- * @typedef {import('../types.js').State} State
- */
-
-
-
-
-/**
- * @param {ThematicBreak} _
- * @param {Parents | undefined} _1
- * @param {State} state
- * @returns {string}
- */
+      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
+    );
+  }
+  return repetition;
+}
 function thematicBreak(_, _1, state) {
-  const value = (
-    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')
-  ).repeat(checkRuleRepetition(state))
-
-  return state.options.ruleSpaces ? value.slice(0, -1) : value
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-to-markdown/lib/handle/index.js
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-/**
- * Default (CommonMark) handlers.
- */
+  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
+  return state.options.ruleSpaces ? value.slice(0, -1) : value;
+}
 const handle = {
-  blockquote: blockquote,
+  blockquote,
   break: hardBreak,
-  code: code_code,
-  definition: definition,
-  emphasis: emphasis,
-  hardBreak: hardBreak,
-  heading: heading,
-  html: html,
-  image: image_image,
-  imageReference: imageReference,
-  inlineCode: inlineCode,
-  link: link_link,
-  linkReference: linkReference,
-  list: list,
-  listItem: listItem,
-  paragraph: paragraph,
-  root: root,
-  strong: strong,
-  text: text_text,
-  thematicBreak: thematicBreak
-}
-
-;// CONCATENATED MODULE: ./node_modules/mdast-util-gfm-task-list-item/lib/index.js
-/**
- * @typedef {import('mdast').ListItem} ListItem
- * @typedef {import('mdast').Paragraph} Paragraph
- * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
- * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
- * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
- * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
- * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
- */
-
-
-
-
-/**
- * Create an extension for `mdast-util-from-markdown` to enable GFM task
- * list items in markdown.
- *
- * @returns {FromMarkdownExtension}
- *   Extension for `mdast-util-from-markdown` to enable GFM task list items.
- */
+  code,
+  definition,
+  emphasis,
+  hardBreak,
+  heading,
+  html,
+  image,
+  imageReference,
+  inlineCode,
+  link,
+  linkReference,
+  list,
+  listItem,
+  paragraph,
+  root,
+  strong,
+  text,
+  thematicBreak
+};
 function gfmTaskListItemFromMarkdown() {
   return {
     exit: {
@@ -6155,209 +3027,94 @@ function gfmTaskListItemFromMarkdown() {
       taskListCheckValueUnchecked: exitCheck,
       paragraph: exitParagraphWithTaskListItem
     }
-  }
+  };
 }
-
-/**
- * Create an extension for `mdast-util-to-markdown` to enable GFM task list
- * items in markdown.
- *
- * @returns {ToMarkdownExtension}
- *   Extension for `mdast-util-to-markdown` to enable GFM task list items.
- */
 function gfmTaskListItemToMarkdown() {
   return {
-    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],
-    handlers: {listItem: listItemWithTaskListItem}
-  }
+    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
+    handlers: { listItem: listItemWithTaskListItem }
+  };
 }
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
 function exitCheck(token) {
-  // Were always in a paragraph, in a list item.
-  const node = this.stack[this.stack.length - 2]
-  ok(node.type === 'listItem')
-  node.checked = token.type === 'taskListCheckValueChecked'
-}
-
-/**
- * @this {CompileContext}
- * @type {FromMarkdownHandle}
- */
+  const node2 = this.stack[this.stack.length - 2];
+  ok$1(node2.type === "listItem");
+  node2.checked = token.type === "taskListCheckValueChecked";
+}
 function exitParagraphWithTaskListItem(token) {
-  const parent = this.stack[this.stack.length - 2]
-
-  if (
-    parent &&
-    parent.type === 'listItem' &&
-    typeof parent.checked === 'boolean'
-  ) {
-    const node = this.stack[this.stack.length - 1]
-    ok(node.type === 'paragraph')
-    const head = node.children[0]
-
-    if (head && head.type === 'text') {
-      const siblings = parent.children
-      let index = -1
-      /** @type {Paragraph | undefined} */
-      let firstParaghraph
-
+  const parent = this.stack[this.stack.length - 2];
+  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
+    const node2 = this.stack[this.stack.length - 1];
+    ok$1(node2.type === "paragraph");
+    const head = node2.children[0];
+    if (head && head.type === "text") {
+      const siblings = parent.children;
+      let index = -1;
+      let firstParaghraph;
       while (++index < siblings.length) {
-        const sibling = siblings[index]
-        if (sibling.type === 'paragraph') {
-          firstParaghraph = sibling
-          break
+        const sibling = siblings[index];
+        if (sibling.type === "paragraph") {
+          firstParaghraph = sibling;
+          break;
         }
       }
-
-      if (firstParaghraph === node) {
-        // Must start with a space or a tab.
-        head.value = head.value.slice(1)
-
+      if (firstParaghraph === node2) {
+        head.value = head.value.slice(1);
         if (head.value.length === 0) {
-          node.children.shift()
-        } else if (
-          node.position &&
-          head.position &&
-          typeof head.position.start.offset === 'number'
-        ) {
-          head.position.start.column++
-          head.position.start.offset++
-          node.position.start = Object.assign({}, head.position.start)
+          node2.children.shift();
+        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
+          head.position.start.column++;
+          head.position.start.offset++;
+          node2.position.start = Object.assign({}, head.position.start);
         }
       }
     }
   }
-
-  this.exit(token)
-}
-
-/**
- * @type {ToMarkdownHandle}
- * @param {ListItem} node
- */
-function listItemWithTaskListItem(node, parent, state, info) {
-  const head = node.children[0]
-  const checkable =
-    typeof node.checked === 'boolean' && head && head.type === 'paragraph'
-  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '
-  const tracker = state.createTracker(info)
-
+  this.exit(token);
+}
+function listItemWithTaskListItem(node2, parent, state, info) {
+  const head = node2.children[0];
+  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
+  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
+  const tracker = state.createTracker(info);
   if (checkable) {
-    tracker.move(checkbox)
+    tracker.move(checkbox);
   }
-
-  let value = handle.listItem(node, parent, state, {
+  let value = handle.listItem(node2, parent, state, {
     ...info,
     ...tracker.current()
-  })
-
+  });
   if (checkable) {
-    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check)
+    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
   }
-
-  return value
-
-  /**
-   * @param {string} $0
-   * @returns {string}
-   */
+  return value;
   function check($0) {
-    return $0 + checkbox
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-factory-space/index.js
-/**
- * @typedef {import('micromark-util-types').Effects} Effects
- * @typedef {import('micromark-util-types').State} State
- * @typedef {import('micromark-util-types').TokenType} TokenType
- */
-
-
-
-// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.
-
-/**
- * Parse spaces and tabs.
- *
- * There is no `nok` parameter:
- *
- * *   spaces in markdown are often optional, in which case this factory can be
- *     used and `ok` will be switched to whether spaces were found or not
- * *   one line ending or space can be detected with `markdownSpace(code)` right
- *     before using `factorySpace`
- *
- * ###### Examples
- *
- * Where `` represents a tab (plus how much it expands) and `` represents a
- * single space.
- *
- * ```markdown
- * 
- * 
- * 
- * ```
- *
- * @param {Effects} effects
- *   Context.
- * @param {State} ok
- *   State switched to when successful.
- * @param {TokenType} type
- *   Type (`' \t'`).
- * @param {number | undefined} [max=Infinity]
- *   Max (exclusive).
- * @returns {State}
- *   Start state.
- */
-function factorySpace(effects, ok, type, max) {
-  const limit = max ? max - 1 : Number.POSITIVE_INFINITY
-  let size = 0
-  return start
-
-  /** @type {State} */
-  function start(code) {
-    if (markdownSpace(code)) {
-      effects.enter(type)
-      return prefix(code)
+    return $0 + checkbox;
+  }
+}
+function factorySpace(effects, ok2, type, max) {
+  const limit = Number.POSITIVE_INFINITY;
+  let size = 0;
+  return start;
+  function start(code2) {
+    if (markdownSpace(code2)) {
+      effects.enter(type);
+      return prefix(code2);
     }
-    return ok(code)
-  }
-
-  /** @type {State} */
-  function prefix(code) {
-    if (markdownSpace(code) && size++ < limit) {
-      effects.consume(code)
-      return prefix
+    return ok2(code2);
+  }
+  function prefix(code2) {
+    if (markdownSpace(code2) && size++ < limit) {
+      effects.consume(code2);
+      return prefix;
     }
-    effects.exit(type)
-    return ok(code)
-  }
-}
-
-;// CONCATENATED MODULE: ./node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
-/**
- * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'
- */
-
-
-
+    effects.exit(type);
+    return ok2(code2);
+  }
+}
 const tasklistCheck = {
-  name: 'tasklistCheck',
+  name: "tasklistCheck",
   tokenize: tokenizeTasklistCheck
 };
-
-/**
- * Create an HTML extension for `micromark` to support GFM task list items
- * syntax.
- *
- * @returns {Extension}
- *   Extension for `micromark` that can be passed in `htmlExtensions` to
- *   support GFM task list items when serializing to HTML.
- */
 function gfmTaskListItem() {
   return {
     text: {
@@ -6365,363 +3122,278 @@ function gfmTaskListItem() {
     }
   };
 }
-
-/**
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function tokenizeTasklistCheck(effects, ok, nok) {
+function tokenizeTasklistCheck(effects, ok2, nok) {
   const self = this;
   return open;
-
-  /**
-   * At start of task list item check.
-   *
-   * ```markdown
-   * > | * [x] y.
-   *       ^
-   * ```
-   *
-   * @type {State}
-   */
-  function open(code) {
+  function open(code2) {
     if (
-    // Exit if theres stuff before.
-    self.previous !== null ||
-    // Exit if not in the first content that is the first child of a list
-    // item.
-    !self._gfmTasklistFirstContentOfListItem) {
-      return nok(code);
+      // Exit if theres stuff before.
+      self.previous !== null || // Exit if not in the first content that is the first child of a list
+      // item.
+      !self._gfmTasklistFirstContentOfListItem
+    ) {
+      return nok(code2);
     }
-    effects.enter('taskListCheck');
-    effects.enter('taskListCheckMarker');
-    effects.consume(code);
-    effects.exit('taskListCheckMarker');
+    effects.enter("taskListCheck");
+    effects.enter("taskListCheckMarker");
+    effects.consume(code2);
+    effects.exit("taskListCheckMarker");
     return inside;
   }
-
-  /**
-   * In task list item check.
-   *
-   * ```markdown
-   * > | * [x] y.
-   *        ^
-   * ```
-   *
-   * @type {State}
-   */
-  function inside(code) {
-    // Currently we match how GH works in files.
-    // To match how GH works in comments, use `markdownSpace` (`[\t ]`) instead
-    // of `markdownLineEndingOrSpace` (`[\t\n\r ]`).
-    if (markdownLineEndingOrSpace(code)) {
-      effects.enter('taskListCheckValueUnchecked');
-      effects.consume(code);
-      effects.exit('taskListCheckValueUnchecked');
+  function inside(code2) {
+    if (markdownLineEndingOrSpace(code2)) {
+      effects.enter("taskListCheckValueUnchecked");
+      effects.consume(code2);
+      effects.exit("taskListCheckValueUnchecked");
       return close;
     }
-    if (code === 88 || code === 120) {
-      effects.enter('taskListCheckValueChecked');
-      effects.consume(code);
-      effects.exit('taskListCheckValueChecked');
+    if (code2 === 88 || code2 === 120) {
+      effects.enter("taskListCheckValueChecked");
+      effects.consume(code2);
+      effects.exit("taskListCheckValueChecked");
       return close;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * At close of task list item check.
-   *
-   * ```markdown
-   * > | * [x] y.
-   *         ^
-   * ```
-   *
-   * @type {State}
-   */
-  function close(code) {
-    if (code === 93) {
-      effects.enter('taskListCheckMarker');
-      effects.consume(code);
-      effects.exit('taskListCheckMarker');
-      effects.exit('taskListCheck');
+  function close(code2) {
+    if (code2 === 93) {
+      effects.enter("taskListCheckMarker");
+      effects.consume(code2);
+      effects.exit("taskListCheckMarker");
+      effects.exit("taskListCheck");
       return after;
     }
-    return nok(code);
+    return nok(code2);
   }
-
-  /**
-   * @type {State}
-   */
-  function after(code) {
-    // EOL in paragraph means there must be something else after it.
-    if (markdownLineEnding(code)) {
-      return ok(code);
+  function after(code2) {
+    if (markdownLineEnding(code2)) {
+      return ok2(code2);
     }
-
-    // Space or tab?
-    // Check what comes after.
-    if (markdownSpace(code)) {
+    if (markdownSpace(code2)) {
       return effects.check({
         tokenize: spaceThenNonSpace
-      }, ok, nok)(code);
+      }, ok2, nok)(code2);
     }
-
-    // EOF, or non-whitespace, both wrong.
-    return nok(code);
+    return nok(code2);
   }
 }
-
-/**
- * @this {TokenizeContext}
- * @type {Tokenizer}
- */
-function spaceThenNonSpace(effects, ok, nok) {
+function spaceThenNonSpace(effects, ok2, nok) {
   return factorySpace(effects, after, "whitespace");
-
-  /**
-   * After whitespace, after task list item check.
-   *
-   * ```markdown
-   * > | * [x] y.
-   *           ^
-   * ```
-   *
-   * @type {State}
-   */
-  function after(code) {
-    // EOF means there was nothing, so bad.
-    // EOL means theres content after it, so good.
-    // Impossible to have more spaces.
-    // Anything else is good.
-    return code === null ? nok(code) : ok(code);
-  }
-}
-;// CONCATENATED MODULE: ./src/syntax-extensions/TaskListItemExtension.ts
-
-
-
-
-
+  function after(code2) {
+    return code2 === null ? nok(code2) : ok2(code2);
+  }
+}
 class TaskListItemView {
-    constructor(node, view, getPos) {
-        const checkbox = document.createElement("input");
-        checkbox.setAttribute("type", "checkbox");
-        checkbox.setAttribute("style", "cursor: pointer;");
-        if (node.attrs["checked"] === true) {
-            checkbox.setAttribute("checked", "checked");
+  constructor(node2, view, getPos) {
+    const checkbox = document.createElement("input");
+    checkbox.setAttribute("type", "checkbox");
+    checkbox.setAttribute("style", "cursor: pointer;");
+    if (node2.attrs["checked"] === true) {
+      checkbox.setAttribute("checked", "checked");
+    }
+    checkbox.addEventListener("click", (e) => {
+      const pos = getPos();
+      if (pos === void 0) {
+        return;
+      }
+      e.preventDefault();
+      view.dispatch(
+        view.state.tr.setNodeAttribute(
+          pos,
+          "checked",
+          !node2.attrs["checked"]
+        )
+      );
+    });
+    const checkboxContainer = document.createElement("span");
+    checkboxContainer.setAttribute("contenteditable", "false");
+    checkboxContainer.setAttribute("style", "position: absolute; left: 5px;");
+    checkboxContainer.appendChild(checkbox);
+    this.contentDOM = document.createElement("span");
+    this.contentDOM.setAttribute("style", "position: relative; left: 30px;");
+    this.dom = document.createElement("li");
+    this.dom.setAttribute(
+      "style",
+      "list-style-type: none; margin-left: -30px;"
+    );
+    this.dom.appendChild(checkboxContainer);
+    this.dom.appendChild(this.contentDOM);
+  }
+  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inherited from the NodeView interface
+  stopEvent() {
+    return true;
+  }
+}
+class TaskListItemExtension extends NodeExtension {
+  static isAtStart(state, view) {
+    if (!state.selection.empty) {
+      return false;
+    }
+    if (view !== void 0) {
+      return view.endOfTextblock("backward", state);
+    }
+    return state.selection.$anchor.parentOffset > 0;
+  }
+  proseMirrorInputRules(proseMirrorSchema) {
+    return [
+      new InputRule(/^\[([x\s]?)\][\s\S]$/u, (state, match, start) => {
+        const wrappingNode = state.doc.resolve(start).node(-1);
+        if (wrappingNode.type.name !== "regular_list_item") {
+          return null;
         }
-        checkbox.addEventListener("click", (e) => {
-            const pos = getPos();
-            if (pos === undefined) {
-                return;
-            }
-            e.preventDefault();
-            view.dispatch(view.state.tr.setNodeAttribute(pos, "checked", !node.attrs["checked"]));
-        });
-        const checkboxContainer = document.createElement("span");
-        checkboxContainer.setAttribute("contenteditable", "false");
-        checkboxContainer.setAttribute("style", "position: absolute; left: 5px;");
-        checkboxContainer.appendChild(checkbox);
-        this.contentDOM = document.createElement("span");
-        this.contentDOM.setAttribute("style", "position: relative; left: 30px;");
-        this.dom = document.createElement("li");
-        this.dom.setAttribute("style", "list-style-type: none; margin-left: -30px;");
-        this.dom.appendChild(checkboxContainer);
-        this.dom.appendChild(this.contentDOM);
-    }
-    // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inherited from the NodeView interface
-    stopEvent() {
-        return true;
-    }
-}
-/**
- * @public
- */
-class TaskListItemExtension extends external_prosemirror_unified_namespaceObject.NodeExtension {
-    static isAtStart(state, view) {
-        if (!state.selection.empty) {
-            return false;
+        return state.tr.replaceRangeWith(
+          start - 2,
+          start + wrappingNode.nodeSize,
+          proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(
+            { checked: match[1] === "x" },
+            wrappingNode.content.cut(3 + match[1].length)
+          )
+        );
+      })
+    ];
+  }
+  proseMirrorKeymap(proseMirrorSchema) {
+    return {
+      Backspace: (state, dispatch, view) => {
+        if (!TaskListItemExtension.isAtStart(state, view)) {
+          return false;
         }
-        if (view !== undefined) {
-            return view.endOfTextblock("backward", state);
+        const taskListItemNode = state.selection.$anchor.node(-1);
+        if (taskListItemNode.type.name !== "task_list_item") {
+          return false;
         }
-        return state.selection.$anchor.parentOffset > 0;
-    }
-    proseMirrorInputRules(proseMirrorSchema) {
-        return [
-            new external_prosemirror_inputrules_namespaceObject.InputRule(/^\[([x\s]?)\][\s\S]$/u, (state, match, start) => {
-                const wrappingNode = state.doc.resolve(start).node(-1);
-                if (wrappingNode.type.name !== "regular_list_item") {
-                    return null;
-                }
-                return state.tr.replaceRangeWith(start - 2, start + wrappingNode.nodeSize, proseMirrorSchema.nodes[this.proseMirrorNodeName()].create({ checked: match[1] === "x" }, wrappingNode.content.cut(3 + match[1].length)));
-            }),
-        ];
-    }
-    proseMirrorKeymap(proseMirrorSchema) {
-        return {
-            Backspace: (state, dispatch, view) => {
-                if (!TaskListItemExtension.isAtStart(state, view)) {
-                    return false;
-                }
-                const taskListItemNode = state.selection.$anchor.node(-1);
-                if (taskListItemNode.type.name !== "task_list_item") {
-                    return false;
-                }
-                if (dispatch === undefined) {
-                    return true;
-                }
-                dispatch(state.tr.replaceRangeWith(state.selection.$from.before() - 2, state.selection.$from.before() + taskListItemNode.nodeSize, proseMirrorSchema.nodes["regular_list_item"].create({}, taskListItemNode.content)));
-                return true;
-            },
-        };
-    }
-    proseMirrorNodeName() {
-        return "task_list_item";
-    }
-    proseMirrorNodeSpec() {
-        return {
-            attrs: { checked: { default: false } },
-            content: "paragraph block*",
-            defining: true,
-            group: "list_item",
-            parseDOM: [
-                {
-                    getAttrs(dom) {
-                        const checkbox = dom.firstChild;
-                        if (!(checkbox instanceof HTMLInputElement)) {
-                            return false;
-                        }
-                        return { checked: checkbox.checked };
-                    },
-                    tag: "li",
-                },
-            ],
-            toDOM(node) {
-                return [
-                    "li",
-                    { style: "list-style-type: none;, margin-left: -30px;" },
-                    [
-                        "span",
-                        {
-                            contenteditable: "false",
-                            style: "position: absolute; left: 5px;",
-                        },
-                        [
-                            "input",
-                            {
-                                checked: node.attrs["checked"]
-                                    ? "checked"
-                                    : undefined,
-                                disabled: "disabled",
-                                type: "checkbox",
-                            },
-                        ],
-                    ],
-                    ["span", { style: "position: relative; left: 30px" }, 0],
-                ];
-            },
-        };
-    }
-    proseMirrorNodeToUnistNodes(node, convertedChildren) {
+        if (dispatch === void 0) {
+          return true;
+        }
+        dispatch(
+          state.tr.replaceRangeWith(
+            state.selection.$from.before() - 2,
+            state.selection.$from.before() + taskListItemNode.nodeSize,
+            proseMirrorSchema.nodes["regular_list_item"].create(
+              {},
+              taskListItemNode.content
+            )
+          )
+        );
+        return true;
+      }
+    };
+  }
+  proseMirrorNodeName() {
+    return "task_list_item";
+  }
+  proseMirrorNodeSpec() {
+    return {
+      attrs: { checked: { default: false } },
+      content: "paragraph block*",
+      defining: true,
+      group: "list_item",
+      parseDOM: [
+        {
+          getAttrs(dom) {
+            const checkbox = dom.firstChild;
+            if (!(checkbox instanceof HTMLInputElement)) {
+              return false;
+            }
+            return { checked: checkbox.checked };
+          },
+          tag: "li"
+        }
+      ],
+      toDOM(node2) {
         return [
+          "li",
+          { style: "list-style-type: none;, margin-left: -30px;" },
+          [
+            "span",
             {
-                checked: node.attrs["checked"],
-                children: convertedChildren,
-                type: this.unistNodeName(),
+              contenteditable: "false",
+              style: "position: absolute; left: 5px;"
             },
+            [
+              "input",
+              {
+                checked: node2.attrs["checked"] ? "checked" : void 0,
+                disabled: "disabled",
+                type: "checkbox"
+              }
+            ]
+          ],
+          ["span", { style: "position: relative; left: 30px" }, 0]
         ];
-    }
-    proseMirrorNodeView() {
-        return (node, view, getPos) => new TaskListItemView(node, view, getPos);
-    }
-    unifiedInitializationHook(processor) {
-        return processor.use(buildUnifiedExtension([gfmTaskListItem()], [gfmTaskListItemFromMarkdown()], [gfmTaskListItemToMarkdown()]));
-    }
-    unistNodeName() {
-        return "listItem";
-    }
-    unistNodeToProseMirrorNodes(node, proseMirrorSchema, convertedChildren) {
-        return (0,external_prosemirror_unified_namespaceObject.createProseMirrorNode)(this.proseMirrorNodeName(), proseMirrorSchema, convertedChildren, { checked: node.checked });
-    }
-    unistToProseMirrorTest(node) {
-        return (node.type === this.unistNodeName() &&
-            "checked" in node &&
-            typeof node.checked === "boolean");
-    }
-}
-
-;// CONCATENATED MODULE: ./src/GFMExtension.ts
-
-
-
-
-
-/**
- * @public
- */
-class GFMExtension extends external_prosemirror_unified_namespaceObject.Extension {
-    dependencies() {
-        return [
-            new MarkdownExtension(),
-            new ExtendedAutolinkExtension(),
-            new StrikethroughExtension(),
-            new TaskListItemExtension(),
-        ];
-    }
-}
-
-;// CONCATENATED MODULE: ./src/index.ts
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-var __webpack_exports__BlockquoteExtension = __webpack_exports__.xT;
-var __webpack_exports__BoldExtension = __webpack_exports__.ll;
-var __webpack_exports__BreakExtension = __webpack_exports__.j5;
-var __webpack_exports__CodeBlockExtension = __webpack_exports__.US;
-var __webpack_exports__DefinitionExtension = __webpack_exports__.rb;
-var __webpack_exports__ExtendedAutolinkExtension = __webpack_exports__.Qh;
-var __webpack_exports__GFMExtension = __webpack_exports__.Om;
-var __webpack_exports__HeadingExtension = __webpack_exports__.oq;
-var __webpack_exports__HorizontalRuleExtension = __webpack_exports__.SY;
-var __webpack_exports__ImageExtension = __webpack_exports__.zS;
-var __webpack_exports__ImageReferenceExtension = __webpack_exports__.OO;
-var __webpack_exports__InlineCodeExtension = __webpack_exports__.eX;
-var __webpack_exports__ItalicExtension = __webpack_exports__.A6;
-var __webpack_exports__LinkExtension = __webpack_exports__.O$;
-var __webpack_exports__LinkReferenceExtension = __webpack_exports__.lt;
-var __webpack_exports__ListItemExtension = __webpack_exports__.vs;
-var __webpack_exports__MarkdownExtension = __webpack_exports__.Db;
-var __webpack_exports__OrderedListExtension = __webpack_exports__.XS;
-var __webpack_exports__ParagraphExtension = __webpack_exports__.yV;
-var __webpack_exports__RootExtension = __webpack_exports__.sY;
-var __webpack_exports__StrikethroughExtension = __webpack_exports__.zd;
-var __webpack_exports__TaskListItemExtension = __webpack_exports__.uG;
-var __webpack_exports__TextExtension = __webpack_exports__.r2;
-var __webpack_exports__UnorderedListExtension = __webpack_exports__.Mv;
-export { __webpack_exports__BlockquoteExtension as BlockquoteExtension, __webpack_exports__BoldExtension as BoldExtension, __webpack_exports__BreakExtension as BreakExtension, __webpack_exports__CodeBlockExtension as CodeBlockExtension, __webpack_exports__DefinitionExtension as DefinitionExtension, __webpack_exports__ExtendedAutolinkExtension as ExtendedAutolinkExtension, __webpack_exports__GFMExtension as GFMExtension, __webpack_exports__HeadingExtension as HeadingExtension, __webpack_exports__HorizontalRuleExtension as HorizontalRuleExtension, __webpack_exports__ImageExtension as ImageExtension, __webpack_exports__ImageReferenceExtension as ImageReferenceExtension, __webpack_exports__InlineCodeExtension as InlineCodeExtension, __webpack_exports__ItalicExtension as ItalicExtension, __webpack_exports__LinkExtension as LinkExtension, __webpack_exports__LinkReferenceExtension as LinkReferenceExtension, __webpack_exports__ListItemExtension as ListItemExtension, __webpack_exports__MarkdownExtension as MarkdownExtension, __webpack_exports__OrderedListExtension as OrderedListExtension, __webpack_exports__ParagraphExtension as ParagraphExtension, __webpack_exports__RootExtension as RootExtension, __webpack_exports__StrikethroughExtension as StrikethroughExtension, __webpack_exports__TaskListItemExtension as TaskListItemExtension, __webpack_exports__TextExtension as TextExtension, __webpack_exports__UnorderedListExtension as UnorderedListExtension };
-
+      }
+    };
+  }
+  proseMirrorNodeToUnistNodes(node2, convertedChildren) {
+    return [
+      {
+        checked: node2.attrs["checked"],
+        children: convertedChildren,
+        type: this.unistNodeName()
+      }
+    ];
+  }
+  proseMirrorNodeView() {
+    return (node2, view, getPos) => new TaskListItemView(node2, view, getPos);
+  }
+  unifiedInitializationHook(processor) {
+    return processor.use(
+      buildUnifiedExtension(
+        [gfmTaskListItem()],
+        [gfmTaskListItemFromMarkdown()],
+        [gfmTaskListItemToMarkdown()]
+      )
+    );
+  }
+  unistNodeName() {
+    return "listItem";
+  }
+  unistNodeToProseMirrorNodes(node2, proseMirrorSchema, convertedChildren) {
+    return createProseMirrorNode(
+      this.proseMirrorNodeName(),
+      proseMirrorSchema,
+      convertedChildren,
+      { checked: node2.checked }
+    );
+  }
+  unistToProseMirrorTest(node2) {
+    return node2.type === this.unistNodeName() && "checked" in node2 && typeof node2.checked === "boolean";
+  }
+}
+class GFMExtension extends Extension {
+  dependencies() {
+    return [
+      new MarkdownExtension(),
+      new ExtendedAutolinkExtension(),
+      new StrikethroughExtension(),
+      new TaskListItemExtension()
+    ];
+  }
+}
+export {
+  BlockquoteExtension,
+  BoldExtension,
+  BreakExtension,
+  CodeBlockExtension,
+  DefinitionExtension,
+  ExtendedAutolinkExtension,
+  GFMExtension,
+  HeadingExtension,
+  HorizontalRuleExtension,
+  ImageExtension,
+  ImageReferenceExtension,
+  InlineCodeExtension,
+  ItalicExtension,
+  LinkExtension,
+  LinkReferenceExtension,
+  ListItemExtension,
+  MarkdownExtension,
+  OrderedListExtension,
+  ParagraphExtension,
+  RootExtension,
+  StrikethroughExtension,
+  TaskListItemExtension,
+  TextExtension,
+  UnorderedListExtension
+};
 //# sourceMappingURL=prosemirror-remark.js.map
diff --git a/dist/prosemirror-remark.js.map b/dist/prosemirror-remark.js.map
index f344f886932b3e71c4e7c479bd10560e10390145..9cdc813ab42ffba8093117b7faa31c28dc7313ea 100644
--- a/dist/prosemirror-remark.js.map
+++ b/dist/prosemirror-remark.js.map
@@ -1 +1 @@
-{"version":3,"file":"prosemirror-remark.js","mappings":"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,CAAC;IAEe,yBAAyB,CACvC,SAAwE;QAExE,OAAO,SAAS,CAAC,GAAG,CAAC,gDAAW,CAAC,CAAC,GAAG,CAAC,oDAAe,EAAE;YACrD,MAAM,EAAE,IAAI;YACZ,cAAc,EAAE,KAAK;YACrB,YAAY,EAAE,IAAI;YAClB,IAAI,EAAE,GAAG;SACV,CAMA,CAAC;IACJ,CAAC;CACF;;;ACxED;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,YAAY;AACZ;AACA;AACO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AC1BO;AACP;AACA;;AAEO;;AAEA;;AAEA;;;ACRP;AACA,aAAa,qCAAqC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA;AACO,gDAAgD;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C,EAAE,IAAI,EAAE;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;ACnPe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;;ACVA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC;;AAEA;AACA;AACA;AACA,aAAa,oEAAoE;AACjF;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,2BAA2B;AACtC;AACA,aAAa;AACb;AACA;AACA,aAAa,gCAAgC;AAC7C;AACA;AACA;AACA;AACA,aAAa,yFAAyF;AACtG;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,MAAM;AACjB;AACA,WAAW,oBAAoB;AAC/B;AACA,WAAW,oBAAoB;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,MAAM;AACjB;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,2BAA2B;AACtC;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,YAAY;AACZ,gLAAgL,gBAAgB;AAChM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,MAAM;AACrB,eAAe,2BAA2B;AAC1C,eAAe,2BAA2B;AAC1C,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,YAAY;AACZ,oLAAoL,gBAAgB;AACpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,MAAE;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,sCAAsC;AACjD,aAAa;AACb;AACA;AACA,aAAa,cAAc;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,mCAAmC,yBAAyB;;AAE5D;;AAEA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA,oCAAoC,yBAAyB;AAC7D,iBAAiB,SAAS;AAC1B;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;;AAEA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,MAAE;AACX;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;;AClSA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;;;ACNA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC;;AAEA;AACA,aAAa,8DAA8D;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;;AAEA;AACA,aAAa,4CAA4C;AACzD,aAAa;AACb;;AAEA;AACA,aAAa,sKAAsK;AACnL;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa,kDAAkD;AAC/D;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB,UAAU;AACV,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa,oDAAoD;AACjE;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB,UAAU;AACV,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAoE;AACjF;AACA;AACA,aAAa,wDAAwD;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,uBAAuB;AAClC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA,aAAa,+GAA+G;AAC5H;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;;AAEqC;AAC0B;;AAE/D,WAAW,uBAAuB;AAClC;;AAEA;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,2BAA2B;AACtC,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA;AACA,WAAW,MAAM;AACjB,WAAW,oBAAoB;AAC/B,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA,WAAW,WAAW;AACtB;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,sCAAsC;AACjD;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;AACO;AACP,aAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;;AAEA;;AAEA;AACA,aAAa,WAAW;AACxB,aAAa,oBAAoB;AACjC,aAAa,oBAAoB;AACjC;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,KAAK;AAC1B,OAAO;AACP;;AAEA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA,iBAAiB,uBAAuB;AACxC;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,oBAAoB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,aAAa;;AAErD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AC7YA;AACA,aAAa,uBAAuB;AACpC,aAAa,yBAAyB;AACtC,aAAa,iCAAiC;AAC9C,aAAa,sBAAsB;AACnC,aAAa,sBAAsB;AACnC,aAAa,yCAAyC;AACtD,aAAa,kDAAkD;AAC/D;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,2BAA2B;AACzC;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA,aAAa,6CAA6C;AAC1D;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;;AAEyC;AACY;AAChB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,0CAA0C;AACrD;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb;AACA;AACO;AACP;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,IAAI,YAAY;AAChB;;AAEA,aAAa,+DAA+D;AAC5E;AACA;AACA,eAAe,qBAAqB;AACpC;;AAEA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,gBAAgB;AAC7B;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,qBAAqB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,6CAA6C;AACjE;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,+CAA+C,kBAAM;AACrD;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzQA;AACA,YAAY,oCAAoC;AAChD,YAAY,sHAAsH;AAClI,YAAY,+CAA+C;AAC3D,YAAY,uBAAuB;AACnC;;AAE6B;AACM;AAC2C;AACpB;;AAE1D,WAAW,eAAe;AAC1B;AACA,WAAW,sBAAsB;AACjC;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,cAAc,iDAAiD;AAC/D;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA,EAAE,EAAM;AACR;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA,WAAW,uBAAuB;AAClC;AACA,EAAE,cAAc;AAChB;AACA;AACA;AACA,oBAAoB,EAAE,IAAI,EAAE;AAC5B;AACA,KAAK;AACL;AACA;;AAEA;AACA,UAAU;AACV,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;;AAEA;AACA,qBAAqB,8BAA8B;AACnD;;AAEA;AACA;;AAEA;AACA,UAAU;AACV,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,mBAAmB;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,+BAA+B,MAAM;;AAErC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wBAAwB,MAAM;AAC9B,sBAAsB,MAAM;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AACxB;AACA;AACA;AACA;;;ACvRA;AACA,YAAY,sFAAsF;AAClG;;AAEyJ;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,iBAAiB;AAC5B,MAAM,WAAI;;AAEV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACO;AACP;AACA,QAAQ;AACR;AACA;;AAEA,WAAW,MAAM;AACjB;;AAEA;AACA;AACA,EAAE,WAAI;AACN;AACA,6BAA6B;AAC7B;AACA,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;AACJ,WAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ,UAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,4BAA4B,YAAY,UAAU,yBAAyB,UAAU,iBAAiB,UAAU,kBAAkB;AAClI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,aAAa,qBAAqB;AAClC;AACA,aAAa,qBAAqB;AAClC;AACA,aAAa,qBAAqB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAyB,UAAU,iBAAiB,yBAAyB,kBAAkB;AACxH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAyB,UAAU,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB,UAAU,iBAAiB;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,uDAAuD,yBAAyB,UAAU,iBAAiB;AAC3G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,WAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,UAAU;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,qHAAqH,yBAAyB;AAC9I;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,UAAU;AACpB;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA,qEAAqE,iBAAiB;AACtF;;AAEA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh1BO,SAAS,qBAAqB,CACnC,mBAA8C,EAC9C,sBAAoD,EACpD,oBAAgD;IAEhD,OAAO;;QACL,uEAAuE;QACvE,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAEzB,UAAI,CAAC,mBAAmB,oCAAxB,IAAI,CAAC,mBAAmB,GAAK,EAAE,EAAC;QAChC,UAAI,CAAC,sBAAsB,oCAA3B,IAAI,CAAC,sBAAsB,GAAK,EAAE,EAAC;QACnC,UAAI,CAAC,oBAAoB,oCAAzB,IAAI,CAAC,oBAAoB,GAAK,EAAE,EAAC;QAEjC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,GAAG,mBAAmB,CAAC,CAAC;QACtD,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,GAAG,sBAAsB,CAAC,CAAC;QAC5D,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,oBAAoB,CAAC,CAAC;IAC1D,CAAC,CAAC;AACJ,CAAC;;;AChBwC;AACqC;AAC9B;AAEuB;AAEvE;;GAEG;AACI,MAAM,yBAA0B,SAAQ,sDAAS;IACtC,yBAAyB,CACvC,SAAwE;QAExE,OAAO,SAAS,CAAC,GAAG,CAClB,qBAAqB,CACnB,CAAC,kBAAkB,EAAE,CAAC,EACtB,CAAC,8BAA8B,EAAE,CAAC,EAClC,CAAC,4BAA4B,EAAE,CAAC,CACjC,CACF,CAAC;IACJ,CAAC;CACF;;;AC3BD;AACA,aAAa,wBAAwB;AACrC;AACA,aAAa,mDAAmD;AAChE,aAAa,8CAA8C;AAC3D,aAAa,2CAA2C;AACxD;AACA,aAAa,gDAAgD;AAC7D,aAAa,yCAAyC;AACtD,aAAa,0CAA0C;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,cAAc,6BAA6B;AAC3C;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,WAAW,kBAAkB;AAC7B;AACA;AACA;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,aAAa,gBAAgB;AAC7B;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,UAAU;AACrB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;AChFA;AACA,aAAa,qCAAqC;AAClD;;AAMiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,IAAI,yBAAyB;AAC7B,IAAI,iBAAiB;AACrB;AACA;AACA;AACA,MAAM,kBAAkB;AACxB;AACA;AACA;;;AClCA;AACA,aAAa,sCAAsC;AACnD,aAAa,yCAAyC;AACtD,aAAa,gDAAgD;AAC7D;;AAEA;AACA;AACA;AACA,WAAW,OAAO,kCAAkC,GAAG;AACvD;AACA,WAAW,cAAc;AACzB;AACA,WAAW,iBAAiB;AAC5B;AACA,aAAa;AACb;AACA;AACO;AACP,aAAa,iBAAiB;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACjCA;AACA,YAAY,SAAS;AACrB,YAAY,sEAAsE;AAClF;;AAEgD;AACsB;AACd;AACxD;AACA;AACA;AACA,WAAW,4BAA4B,WAAW;AAClD;AACA,aAAa;AACb;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA,qCAAqC;AACrC,mCAAmC;AACnC;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA,qCAAqC;AACrC,mCAAmC;AACnC;;AAEA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,cAAc,MAAM,mCAAmC,UAAU;AACjE;;AAEA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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Aa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;ACnCA;AACA,aAAa,sBAAsB;AACnC,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,sBAAsB;AACnC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,2BAA2B;AACxC,aAAa,6BAA6B;AAC1C;;AAE4C;AAC2B;AACtB;;AAEjD;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO,SAAS,SAAI;AACpB,iBAAiB,UAAU;AAC3B;AACA;;AAEA,MAAM,oBAAoB;AAC1B;AACA,yCAAyC,QAAG;AAC5C;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;AACvD;AACA;;AAEA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,KAAK;AAChB,SAAS,QAAG;AACZ;AACA;;;AC7EA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,4BAA4B;AACzC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEiD;;AAEjD;AACA,WAAW,YAAY;AACvB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAgD;AAC5E;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AC7EA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,0BAA0B;AACvC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEuD;;AAEvD;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;;AC/CA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC,aAAa,kDAAkD;AAC/D;;AAEA;AACA,aAAa,8DAA8D;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;;AAEA;AACA,aAAa,4CAA4C;AACzD,aAAa;AACb;;AAEA;AACA,aAAa,sKAAsK;AACnL;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa,kDAAkD;AAC/D;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,WAAW;AACzB;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB,UAAU;AACV,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB,UAAU;AACV,cAAc,MAAM;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,wDAAwD;AACnE;AACA,WAAW,6DAA6D;AACxE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA,aAAa,6CAA6C;AAC1D;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,aAAa;AAC3B;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;;AAEqD;;AAEQ;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,2BAA2B;AACtC,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA;AACA,WAAW,MAAM;AACjB,WAAW,oBAAoB;AAC/B,WAAW,4BAA4B;AACvC,aAAa;AACb;AACA,WAAW,WAAW;AACtB;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,sCAAsC;AACjD;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb;AACA;AACA,cAAc,WAAW;AACzB;AACA,cAAc,MAAM;AACpB;AACA;AACO;AACP,aAAa,4BAA4B;AACzC;AACA,aAAa,MAAM;AACnB;AACA,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,YAAY;;AAEd;AACA,aAAa,WAAW;AACxB,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxTA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA,cAAc,4BAA4B;AAC1C;AACA;;AAEA,WAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,4BAA4B;AACvC;AACA,aAAa;AACb;AACA;AACO,SAAS,YAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAG;AAChB;AACA;;AAEA;AACA,WAAW,OAAG;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA,SAAS,OAAG;AACZ,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;AC3GA;AACA,aAAa,yBAAyB;AACtC,aAAa,6BAA6B;AAC1C;;AAE4C;AACC;;AAE7C;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA,EAAE,KAAK;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA,GAAG;;AAEH;AACA;AACA,MAAM,YAAQ;AACd;AACA;AACA;;;ACjCA;AACA,aAAa,yBAAyB;AACtC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEyE;;AAEzE;AACA,WAAW,SAAS;AACpB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;;AAEA,MAAM,qBAAqB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AC/EA;AACA,aAAa,sBAAsB;AACnC;;AAEA;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;ACnBA;AACA,aAAa,uBAAuB;AACpC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEiD;;AAEjD,WAAK;;AAEL;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO,SAAS,WAAK;AACrB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAgD;AAC5E;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;ACnFA;AACA,aAAa,gCAAgC;AAC7C,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEA;;AAEA;AACA,WAAW,gBAAgB;AAC3B,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AChEA;AACA,aAAa,4BAA4B;AACzC,aAAa,yBAAyB;AACtC,aAAa,6BAA6B;AAC1C;;AAEA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AC5EA;AACA,aAAa,sBAAsB;AACnC,aAAa,6BAA6B;AAC1C;;AAE6C;;AAE7C;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP,cAAc,YAAQ;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA,aAAa,sBAAsB;AACnC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEiD;AACsB;;AAEvE,SAAI;;AAEJ;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO,SAAS,SAAI;AACpB,gBAAgB,UAAU;AAC1B;AACA;AACA,aAAa,MAAM;AACnB;AACA,aAAa,MAAM;AACnB;;AAEA,MAAM,oBAAoB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAgD;AAC5E;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA,SAAS,oBAAoB;AAC7B;;;ACnHA;AACA,aAAa,+BAA+B;AAC5C,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEA;;AAEA;AACA,WAAW,eAAe;AAC1B,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AChEA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAE6C;;AAE7C;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP,iBAAiB,WAAW;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACtCA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,sBAAsB;AACnC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEmD;AACW;AACI;AACnB;;AAE/C;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA,aAAa,QAAQ;AACrB,8BAA8B,kBAAkB,UAAU,WAAW;AACrE,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,MAAM,gBAAgB;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAS;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrGA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,0BAA0B;AACvC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,2BAA2B;AACxC,aAAa,6BAA6B;AAC1C;;AAEmD;AACkB;;AAErE;AACA,WAAW,UAAU;AACrB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,yBAAyB,mBAAmB;AAC5C,sCAAsC,WAAW;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AChEA;AACA,aAAa,2BAA2B;AACxC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrBA;AACA,aAAa,sBAAsB;AACnC,aAAa,iCAAiC;AAC9C;;AAEqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,aAAa,4DAA4D;AACzE;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5CA;AACA,aAAa,yBAAyB;AACtC,aAAa,sBAAsB;AACnC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAE4C;;AAE5C;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA,WAAW,QAAQ;AACnB,GAAG;AACH;AACA;AACA;;;ACvBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,yBAAyB;AACtC,aAAa,wBAAwB;AACrC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEmD;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;;AC/CA;AACA,aAAa,yBAAyB;AACtC,aAAa,sBAAsB;AACnC,aAAa,4BAA4B;AACzC,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa;AACb;AACO,SAAS,SAAI;AACpB;AACA;;;AChBA;AACA,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACrBA;AACA,aAAa,yBAAyB;AACtC,aAAa,+BAA+B;AAC5C,aAAa,6BAA6B;AAC1C;;AAEoE;AACrB;;AAE/C;AACA,WAAW,eAAe;AAC1B,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA,IAAI,SAAS;AACb,WAAW,mBAAmB;;AAE9B;AACA;;;ACrB0C;AACN;AACN;AACY;AACJ;AACF;AACN;AACE;AACmB;AACR;AACb;AACmB;AACnB;AACS;AACC;AACV;AACI;AACJ;AACmB;;AAEjD;AACA;AACA;AACO;AACP,YAAY;AACZ,SAAS,SAAS;AAClB,MAAM;AACN,YAAY;AACZ,UAAU;AACV,WAAW;AACX,SAAS;AACT,MAAM;AACN,OAAO;AACP,gBAAgB;AAChB,YAAY;AACZ,MAAM;AACN,eAAe;AACf,MAAM;AACN,UAAU;AACV,WAAW;AACX,MAAM;AACN,QAAQ;AACR,MAAM;AACN,eAAe;AACf;;;AC5CA;AACA,aAAa,0BAA0B;AACvC,aAAa,2BAA2B;AACxC,aAAa,mDAAmD;AAChE,aAAa,8CAA8C;AAC3D,aAAa,2CAA2C;AACxD,aAAa,0CAA0C;AACvD,aAAa,yCAAyC;AACtD;;AAEmC;AACmB;;AAEtD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA,cAAc,8CAA8C;AAC5D,eAAe;AACf;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA,EAAE,EAAM;AACR;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAM;AACV;;AAEA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,MAAe;AAC7B;AACA;AACA,GAAG;;AAEH;AACA,qDAAqD,IAAI;AACzD;;AAEA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;;;AC5IA;AACA,aAAa,wCAAwC;AACrD,aAAa,sCAAsC;AACnD,aAAa,0CAA0C;AACvD;;AAEsD;;AAEtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,WAAW;AACtB;AACA,WAAW,oBAAoB;AAC/B;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjEA;AACA,YAAY,8CAA8C;AAC1D;;AAEuD;AACiD;AACxG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ,kBAAkB;AAC1B;AACA;;AAEA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA,SAAS,YAAY;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IuC;AACkC;AACtB;AACwB;AAEJ;AAEvE,MAAM,gBAAgB;IAIpB,YACE,IAAqB,EACrB,IAAgB,EAChB,MAAgC;QAEhC,MAAM,QAAQ,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QACjD,QAAQ,CAAC,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAC1C,QAAQ,CAAC,YAAY,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;QACnD,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,IAAI,EAAE,CAAC;YACnC,QAAQ,CAAC,YAAY,CAAC,SAAS,EAAE,SAAS,CAA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","sources":["webpack://prosemirror-remark/webpack/bootstrap","webpack://prosemirror-remark/webpack/runtime/define property getters","webpack://prosemirror-remark/webpack/runtime/hasOwnProperty shorthand","webpack://prosemirror-remark/external module \"prosemirror-unified\"","webpack://prosemirror-remark/external module \"remark-parse\"","webpack://prosemirror-remark/external module \"remark-stringify\"","webpack://prosemirror-remark/external module \"prosemirror-commands\"","webpack://prosemirror-remark/external module \"prosemirror-inputrules\"","webpack://prosemirror-remark/./src/syntax-extensions/BlockquoteExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/BoldExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/BreakExtension.ts","webpack://prosemirror-remark/external module \"prosemirror-state\"","webpack://prosemirror-remark/./src/syntax-extensions/TextExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/CodeBlockExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/DefinitionExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ParagraphExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/HeadingExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/HorizontalRuleExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ImageExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ImageReferenceExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/InlineCodeExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ItalicExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/LinkExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/LinkReferenceExtension.ts","webpack://prosemirror-remark/external module \"prosemirror-schema-list\"","webpack://prosemirror-remark/./src/syntax-extensions/ListItemExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/OrderedListExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/RootExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/UnorderedListExtension.ts","webpack://prosemirror-remark/./src/MarkdownExtension.ts","webpack://prosemirror-remark/./node_modules/ccount/index.js","webpack://prosemirror-remark/./node_modules/devlop/lib/default.js","webpack://prosemirror-remark/./node_modules/micromark-util-character/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","webpack://prosemirror-remark/./node_modules/unist-util-is/lib/index.js","webpack://prosemirror-remark/./node_modules/unist-util-visit-parents/lib/color.js","webpack://prosemirror-remark/./node_modules/unist-util-visit-parents/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-find-and-replace/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-gfm-autolink-literal/lib/index.js","webpack://prosemirror-remark/./node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","webpack://prosemirror-remark/./src/utils/buildUnifiedExtension.ts","webpack://prosemirror-remark/./src/syntax-extensions/ExtendedAutolinkExtension.ts","webpack://prosemirror-remark/./node_modules/mdast-util-gfm-strikethrough/lib/index.js","webpack://prosemirror-remark/./node_modules/micromark-util-chunked/index.js","webpack://prosemirror-remark/./node_modules/micromark-util-classify-character/index.js","webpack://prosemirror-remark/./node_modules/micromark-util-resolve-all/index.js","webpack://prosemirror-remark/./node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","webpack://prosemirror-remark/./src/syntax-extensions/StrikethroughExtension.ts","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/break.js","webpack://prosemirror-remark/./node_modules/longest-streak/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-fence.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/code.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-quote.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/definition.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","webpack://prosemirror-remark/./node_modules/unist-util-visit/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-string/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/heading.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/html.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/image.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/link.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-rule.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/list.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/list-item.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","webpack://prosemirror-remark/./node_modules/mdast-util-phrasing/lib/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/root.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-strong.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/strong.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/text.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","webpack://prosemirror-remark/./node_modules/mdast-util-to-markdown/lib/handle/index.js","webpack://prosemirror-remark/./node_modules/mdast-util-gfm-task-list-item/lib/index.js","webpack://prosemirror-remark/./node_modules/micromark-factory-space/index.js","webpack://prosemirror-remark/./node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","webpack://prosemirror-remark/./src/syntax-extensions/TaskListItemExtension.ts","webpack://prosemirror-remark/./src/GFMExtension.ts","webpack://prosemirror-remark/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"Extension\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.Extension), [\"MarkExtension\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.MarkExtension), [\"MarkInputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.MarkInputRule), [\"NodeExtension\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.NodeExtension), [\"createProseMirrorNode\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_unified_0a343064__.createProseMirrorNode) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"default\"]: () => (__WEBPACK_EXTERNAL_MODULE_remark_parse_76724963__[\"default\"]) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"default\"]: () => (__WEBPACK_EXTERNAL_MODULE_remark_stringify_a28ae2a6__[\"default\"]) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"chainCommands\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.chainCommands), [\"exitCode\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.exitCode), [\"setBlockType\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.setBlockType), [\"toggleMark\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.toggleMark), [\"wrapIn\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_commands_5e270ab3__.wrapIn) });","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"InputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.InputRule), [\"textblockTypeInputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.textblockTypeInputRule), [\"wrappingInputRule\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_inputrules_847ff8d2__.wrappingInputRule) });","import type { BlockContent, Blockquote, DefinitionContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { wrapIn } from \"prosemirror-commands\";\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BlockquoteExtension extends NodeExtension<Blockquote> {\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}>\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Mod->\": wrapIn(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"blockquote\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{ tag: \"blockquote\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"blockquote\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<Blockquote> {\n    return [\n      {\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"blockquote\" {\n    return \"blockquote\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Blockquote,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Emphasis, Strong, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BoldExtension extends MarkExtension<Strong> {\n  public override processConvertedUnistNode(\n    convertedNode: Emphasis | Text,\n  ): Strong {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /\\*\\*([^\\s](?:.*[^\\s])?)\\*\\*([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /__([^\\s](?:.*[^\\s])?)__([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Mod-b\": toggleMark(markType),\n      \"Mod-B\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"strong\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"b\" },\n        { tag: \"strong\" },\n        {\n          getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/u.test(value) && null,\n          style: \"font-weight\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"strong\"];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"strong\" {\n    return \"strong\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Strong,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","import type { Break } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { chainCommands, exitCode } from \"prosemirror-commands\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BreakExtension extends NodeExtension<Break> {\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const command = chainCommands(exitCode, (state, dispatch) => {\n      if (dispatch) {\n        dispatch(\n          state.tr\n            .replaceSelectionWith(\n              proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(),\n            )\n            .scrollIntoView(),\n        );\n      }\n      return true;\n    });\n\n    const isMac =\n      typeof navigator !== \"undefined\"\n        ? /Mac|iP(hone|[oa]d)/u.test(navigator.platform) // eslint-disable-line @typescript-eslint/no-deprecated -- In the tested systems, it will be defined\n        : false;\n\n    return {\n      \"Mod-Enter\": command,\n      \"Shift-Enter\": command,\n      ...(isMac && { \"Ctrl-Enter\": command }),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"hard_break\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"inline\",\n      inline: true,\n      parseDOM: [{ tag: \"br\" }],\n      selectable: false,\n      toDOM(): DOMOutputSpec {\n        return [\"br\"];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<Break> {\n    return [{ type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"break\" {\n    return \"break\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Break,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"Selection\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_state_1d692759__.Selection) });","import type { Text } from \"mdast\";\nimport type {\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class TextExtension extends NodeExtension<Text> {\n  public override proseMirrorNodeName(): string {\n    return \"text\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"inline\",\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n  ): Array<Text> {\n    return [{ type: this.unistNodeName(), value: node.text ?? \"\" }];\n  }\n\n  public override unistNodeName(): \"text\" {\n    return \"text\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Text,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return [proseMirrorSchema.text(node.value)];\n  }\n}\n","import type { Code, Text } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { setBlockType } from \"prosemirror-commands\";\nimport { type InputRule, textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  type Command,\n  type EditorState,\n  Selection,\n  type Transaction,\n} from \"prosemirror-state\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { TextExtension } from \"./TextExtension\";\n\n/**\n * @public\n */\nexport class CodeBlockExtension extends NodeExtension<Code> {\n  private static liftOutOfCodeBlock() {\n    return (\n      state: EditorState,\n      dispatch?: (tr: Transaction) => void,\n    ): boolean => {\n      const { $from, $to } = state.selection;\n      if (\n        // Mustn't be a complex selection\n        !$from.sameParent($to) ||\n        // Must be in a code block\n        $from.parent.type.name !== \"code_block\" ||\n        // Must be at the end of the code block\n        $from.parentOffset !== $from.parent.content.size ||\n        // There must already be a preceding empty line\n        !$from.parent.textBetween(0, $from.parentOffset).endsWith(\"\\n\\n\")\n      ) {\n        return false;\n      }\n      if (dispatch) {\n        const tr = state.tr;\n        dispatch(\n          tr\n            // Delete the preceding empty line\n            .deleteRange($from.pos - 2, $from.pos)\n            // Insert empty paragraph\n            .insert(\n              $from.pos - 1,\n              tr.doc.type.schema.nodes[\"paragraph\"].create(),\n            )\n            // Put the cursor into the empty paragraph\n            .setSelection(Selection.near(tr.doc.resolve($from.pos), 1))\n            .scrollIntoView(),\n        );\n      }\n      return true;\n    };\n  }\n\n  public override dependencies(): Array<Extension> {\n    return [new TextExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      textblockTypeInputRule(\n        /^\\s{0,3}```$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n      textblockTypeInputRule(\n        /^\\s{4}$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      Enter: CodeBlockExtension.liftOutOfCodeBlock(),\n      \"Shift-Mod-\\\\\": setBlockType(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"code_block\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      code: true,\n      content: \"text*\",\n      defining: true,\n      group: \"block\",\n      marks: \"\",\n      parseDOM: [{ preserveWhitespace: \"full\", tag: \"pre\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"pre\", [\"code\", 0]];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<Text>,\n  ): Array<Code> {\n    return [\n      {\n        type: this.unistNodeName(),\n        value: convertedChildren.map((child) => child.value).join(\"\"),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"code\" {\n    return \"code\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Code,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      [proseMirrorSchema.text(node.value)],\n    );\n  }\n}\n","import type { Definition } from \"mdast\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport interface DefinitionExtensionContext {\n  definitions: Record<\n    string,\n    { title: string | null | undefined; url: string }\n  >;\n}\n\n/**\n * @public\n */\nexport class DefinitionExtension extends NodeExtension<Definition> {\n  public override proseMirrorNodeName(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeSpec(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<Definition> {\n    return [];\n  }\n\n  public override unistNodeName(): \"definition\" {\n    return \"definition\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Definition,\n    _proseMirrorSchema: Schema<string, string>,\n    _convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    if (context.DefinitionExtension === undefined) {\n      context.DefinitionExtension = { definitions: {} };\n    }\n    context.DefinitionExtension.definitions[node.identifier] = {\n      title: node.title,\n      url: node.url,\n    };\n    return [];\n  }\n}\n","import type { Paragraph, PhrasingContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ParagraphExtension extends NodeExtension<Paragraph> {\n  public override proseMirrorNodeName(): string {\n    return \"paragraph\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{ tag: \"p\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"p\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<PhrasingContent>,\n  ): Array<Paragraph> {\n    return [{ children: convertedChildren, type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"paragraph\" {\n    return \"paragraph\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Paragraph,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Heading, PhrasingContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command, EditorState } from \"prosemirror-state\";\nimport type { EditorView } from \"prosemirror-view\";\n\nimport { setBlockType } from \"prosemirror-commands\";\nimport { type InputRule, textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ParagraphExtension } from \"./ParagraphExtension\";\nimport { TextExtension } from \"./TextExtension\";\n\n/**\n * @public\n */\nexport class HeadingExtension extends NodeExtension<Heading> {\n  private static headingLevelCommandBuilder(\n    proseMirrorSchema: Schema<string, string>,\n    levelUpdate: -1 | 1,\n    onlyAtStart: boolean,\n  ): Command {\n    return (state, dispatch, view) => {\n      if (onlyAtStart && !HeadingExtension.isAtStart(state, view)) {\n        return false;\n      }\n\n      const { $anchor } = state.selection;\n      const headingNode = $anchor.parent;\n      if (headingNode.type.name !== \"heading\") {\n        return false;\n      }\n\n      const newHeadingLevel =\n        (headingNode.attrs[\"level\"] as number) + levelUpdate;\n\n      if (newHeadingLevel < 0 || newHeadingLevel > 6) {\n        return false;\n      }\n      if (dispatch === undefined) {\n        return true;\n      }\n\n      const headingPosition = $anchor.before($anchor.depth);\n\n      if (newHeadingLevel > 0) {\n        dispatch(\n          state.tr.setNodeMarkup(headingPosition, undefined, {\n            level: newHeadingLevel,\n          }),\n        );\n      } else {\n        dispatch(\n          state.tr.setNodeMarkup(\n            headingPosition,\n            proseMirrorSchema.nodes[\"paragraph\"],\n          ),\n        );\n      }\n      return true;\n    };\n  }\n\n  private static isAtStart(\n    state: EditorState,\n    view: EditorView | undefined,\n  ): boolean {\n    if (!state.selection.empty) {\n      return false;\n    }\n    if (view !== undefined) {\n      return view.endOfTextblock(\"backward\", state);\n    }\n    return state.selection.$anchor.parentOffset > 0;\n  }\n\n  public override dependencies(): Array<Extension> {\n    return [new ParagraphExtension(), new TextExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      textblockTypeInputRule(\n        /^\\s{0,3}(#{1,6})\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        (match) => ({ level: match[1].length }),\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const keymap: Record<string, Command> = {\n      // eslint-disable-next-line @typescript-eslint/naming-convention -- This is a key\n      \"#\": HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        +1,\n        true,\n      ),\n      Backspace: HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        -1,\n        true,\n      ),\n      \"Shift-Tab\": HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        -1,\n        false,\n      ),\n      Tab: HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        +1,\n        false,\n      ),\n    };\n\n    for (let i = 1; i <= 6; i++) {\n      keymap[`Shift-Mod-${i.toString()}`] = setBlockType(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        { level: i },\n      );\n    }\n    return keymap;\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"heading\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { level: { default: 1 } },\n      content: \"text*\",\n      defining: true,\n      group: \"block\",\n      parseDOM: [\n        { attrs: { level: 1 }, tag: \"h1\" },\n        { attrs: { level: 2 }, tag: \"h2\" },\n        { attrs: { level: 3 }, tag: \"h3\" },\n        { attrs: { level: 4 }, tag: \"h4\" },\n        { attrs: { level: 5 }, tag: \"h5\" },\n        { attrs: { level: 6 }, tag: \"h6\" },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [`h${(node.attrs[\"level\"] as number).toString()}`, 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<PhrasingContent>,\n  ): Array<Heading> {\n    return [\n      {\n        children: convertedChildren,\n        depth: node.attrs[\"level\"] as 1 | 2 | 3 | 4 | 5 | 6,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"heading\" {\n    return \"heading\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Heading,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        level: node.depth,\n      },\n    );\n  }\n}\n","import type { ThematicBreak } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class HorizontalRuleExtension extends NodeExtension<ThematicBreak> {\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new InputRule(/^\\s{0,3}(?:\\*\\*\\*|---|___)\\n$/u, (state, _, start, end) =>\n        state.tr.replaceWith(\n          start,\n          end,\n          createProseMirrorNode(\n            this.proseMirrorNodeName(),\n            proseMirrorSchema,\n            [],\n          ),\n        ),\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Mod-_\": (state, dispatch): true => {\n        if (dispatch) {\n          dispatch(\n            state.tr\n              .replaceSelectionWith(\n                proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(),\n              )\n              .scrollIntoView(),\n          );\n        }\n        return true;\n      },\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"horizontal_rule\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"block\",\n      parseDOM: [{ tag: \"hr\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"div\", [\"hr\"]];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<ThematicBreak> {\n    return [\n      {\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"thematicBreak\" {\n    return \"thematicBreak\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: ThematicBreak,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Image } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ParagraphExtension } from \"./ParagraphExtension\";\n\n/**\n * @public\n */\nexport class ImageExtension extends NodeExtension<Image> {\n  public override dependencies(): Array<Extension> {\n    return [new ParagraphExtension()];\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"image\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: {\n        alt: { default: null },\n        src: {},\n        title: { default: null },\n      },\n      draggable: true,\n      group: \"inline\",\n      inline: true,\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): {\n            alt: string | null;\n            src: string | null;\n            title: string | null;\n          } {\n            return {\n              alt: (dom as HTMLElement).getAttribute(\"alt\"),\n              src: (dom as HTMLElement).getAttribute(\"src\"),\n              title: (dom as HTMLElement).getAttribute(\"title\"),\n            };\n          },\n          tag: \"img[src]\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\"img\", node.attrs];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n  ): Array<Image> {\n    return [\n      {\n        type: this.unistNodeName(),\n        url: node.attrs[\"src\"] as string,\n        ...(node.attrs[\"alt\"] !== null && { alt: node.attrs[\"alt\"] as string }),\n        ...(node.attrs[\"title\"] !== null && {\n          title: node.attrs[\"title\"] as string,\n        }),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"image\" {\n    return \"image\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Image,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        alt: node.alt,\n        src: node.url,\n        title: node.title,\n      },\n    );\n  }\n}\n","import type { ImageReference } from \"mdast\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { type Extension, NodeExtension } from \"prosemirror-unified\";\n\nimport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./DefinitionExtension\";\nimport { ImageExtension } from \"./ImageExtension\";\n\n/**\n * @public\n */\nexport interface ImageReferenceExtensionContext {\n  proseMirrorNodes: Record<string, ProseMirrorNode>;\n}\n\n/**\n * @public\n */\nexport class ImageReferenceExtension extends NodeExtension<ImageReference> {\n  public override dependencies(): Array<Extension> {\n    return [new DefinitionExtension(), new ImageExtension()];\n  }\n\n  public override postUnistToProseMirrorHook(\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n      ImageReferenceExtension: ImageReferenceExtensionContext;\n    }>,\n  ): void {\n    if (\n      context.ImageReferenceExtension === undefined ||\n      context.DefinitionExtension === undefined\n    ) {\n      return;\n    }\n    for (const id in context.ImageReferenceExtension.proseMirrorNodes) {\n      if (!(id in context.DefinitionExtension.definitions)) {\n        continue;\n      }\n      const definition = context.DefinitionExtension.definitions[id];\n      const attrs = context.ImageReferenceExtension.proseMirrorNodes[id]\n        .attrs as Record<\n        string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Attrs can be any\n        any\n      >;\n      attrs[\"src\"] = definition.url;\n      if (definition.title !== undefined) {\n        attrs[\"title\"] = definition.title;\n      }\n    }\n  }\n\n  public override proseMirrorNodeName(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeSpec(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<ImageReference> {\n    return [];\n  }\n\n  public override unistNodeName(): \"imageReference\" {\n    return \"imageReference\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: ImageReference,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      ImageReferenceExtension: ImageReferenceExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    const proseMirrorNode = proseMirrorSchema.nodes[\"image\"].createAndFill(\n      { alt: node.alt, src: \"\", title: node.label },\n      convertedChildren,\n    );\n    if (proseMirrorNode === null) {\n      return [];\n    }\n    if (context.ImageReferenceExtension === undefined) {\n      context.ImageReferenceExtension = { proseMirrorNodes: {} };\n    }\n    context.ImageReferenceExtension.proseMirrorNodes[node.identifier] =\n      proseMirrorNode;\n    return [proseMirrorNode];\n  }\n}\n","import type { InlineCode, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class InlineCodeExtension extends MarkExtension<InlineCode> {\n  public override processConvertedUnistNode(convertedNode: Text): InlineCode {\n    return { type: this.unistNodeName(), value: convertedNode.value };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /`([^\\s](?:.*[^\\s])?)`([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Ctrl-`\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"code\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      inclusive: false,\n      parseDOM: [{ tag: \"code\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"code\"];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"inlineCode\" {\n    return \"inlineCode\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: InlineCode,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return [\n      proseMirrorSchema\n        .text(node.value)\n        .mark([proseMirrorSchema.marks[this.proseMirrorMarkName()].create()]),\n    ];\n  }\n}\n","import type { Emphasis, Strong, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ItalicExtension extends MarkExtension<Emphasis> {\n  public override processConvertedUnistNode(\n    convertedNode: Strong | Text,\n  ): Emphasis {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /(?<!\\*)\\*([^\\s*](?:.*[^\\s])?)\\*([^*])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /(?<!_)_([^\\s_](?:.*[^\\s])?)_([^_])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Mod-i\": toggleMark(markType),\n      \"Mod-I\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"em\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"i\" },\n        { tag: \"em\" },\n        {\n          getAttrs: (value) => value === \"italic\" && null,\n          style: \"font-style\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"em\"];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"emphasis\" {\n    return \"emphasis\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Emphasis,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","import type { Link, Text } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  Mark,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { MarkExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class LinkExtension extends MarkExtension<Link> {\n  public override processConvertedUnistNode(\n    convertedNode: Text,\n    originalMark: Mark,\n  ): Link {\n    return {\n      type: this.unistNodeName(),\n      url: originalMark.attrs[\"href\"] as string,\n      ...(originalMark.attrs[\"title\"] !== null && {\n        title: originalMark.attrs[\"title\"] as string,\n      }),\n      children: [convertedNode],\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"link\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      attrs: { href: {}, title: { default: null } },\n      inclusive: false,\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): {\n            href: string | null;\n            title: string | null;\n          } {\n            return {\n              href: (dom as HTMLElement).getAttribute(\"href\"),\n              title: (dom as HTMLElement).getAttribute(\"title\"),\n            };\n          },\n          tag: \"a[href]\",\n        },\n      ],\n      toDOM(node: Mark): DOMOutputSpec {\n        return [\"a\", node.attrs];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"link\" {\n    return \"link\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Link,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create({\n            href: node.url,\n            title: node.title,\n          }),\n        ]),\n      ),\n    );\n  }\n}\n","import type { LinkReference } from \"mdast\";\nimport type { Mark, Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { type Extension, MarkExtension } from \"prosemirror-unified\";\n\nimport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./DefinitionExtension\";\nimport { LinkExtension } from \"./LinkExtension\";\n\n/**\n * @public\n */\nexport interface LinkReferenceExtensionContext {\n  marks: Record<string, Mark>;\n}\n\n/**\n * @public\n */\nexport class LinkReferenceExtension extends MarkExtension<LinkReference> {\n  public override dependencies(): Array<Extension> {\n    return [new DefinitionExtension(), new LinkExtension()];\n  }\n\n  public override postUnistToProseMirrorHook(\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n      LinkReferenceExtension: LinkReferenceExtensionContext;\n    }>,\n  ): void {\n    if (\n      context.LinkReferenceExtension === undefined ||\n      context.DefinitionExtension === undefined\n    ) {\n      return;\n    }\n    for (const id in context.LinkReferenceExtension.marks) {\n      if (!(id in context.DefinitionExtension.definitions)) {\n        continue;\n      }\n      const definition = context.DefinitionExtension.definitions[id];\n      const attrs = context.LinkReferenceExtension.marks[id].attrs as Record<\n        string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Attrs can be any\n        any\n      >;\n      attrs[\"href\"] = definition.url;\n      if (definition.title !== undefined) {\n        attrs[\"title\"] = definition.title;\n      }\n    }\n  }\n\n  public override processConvertedUnistNode(\n    convertedNode: LinkReference,\n  ): LinkReference {\n    return convertedNode;\n  }\n\n  public override proseMirrorMarkName(): null {\n    return null;\n  }\n\n  public override proseMirrorMarkSpec(): null {\n    return null;\n  }\n\n  public override unistNodeName(): \"linkReference\" {\n    return \"linkReference\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: LinkReference,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      LinkReferenceExtension: LinkReferenceExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    const mark = proseMirrorSchema.marks[\"link\"].create({\n      href: null,\n      title: null,\n    });\n    if (context.LinkReferenceExtension === undefined) {\n      context.LinkReferenceExtension = { marks: {} };\n    }\n    context.LinkReferenceExtension.marks[node.identifier] = mark;\n    return convertedChildren.map((child) =>\n      child.mark(child.marks.concat([mark])),\n    );\n  }\n}\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"liftListItem\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.liftListItem), [\"sinkListItem\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.sinkListItem), [\"splitListItem\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.splitListItem), [\"wrapInList\"]: () => (__WEBPACK_EXTERNAL_MODULE_prosemirror_schema_list_6ac4a27c__.wrapInList) });","import type { BlockContent, DefinitionContent, ListItem } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  liftListItem,\n  sinkListItem,\n  splitListItem,\n} from \"prosemirror-schema-list\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ListItemExtension extends NodeExtension<ListItem> {\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const nodeType = proseMirrorSchema.nodes[this.proseMirrorNodeName()];\n    return {\n      Enter: splitListItem(nodeType),\n      \"Shift-Tab\": liftListItem(nodeType),\n      Tab: sinkListItem(nodeType),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"regular_list_item\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"paragraph block*\",\n      defining: true,\n      group: \"list_item\",\n      parseDOM: [{ tag: \"li\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"li\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<ListItem> {\n    return [\n      {\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"listItem\" {\n    return \"listItem\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: ListItem,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() &&\n      (!(\"checked\" in node) || typeof node.checked !== \"boolean\")\n    );\n  }\n}\n","import type { List, ListContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { wrapInList } from \"prosemirror-schema-list\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ListItemExtension } from \"./ListItemExtension\";\n\n/**\n * @public\n */\nexport class OrderedListExtension extends NodeExtension<List> {\n  public override dependencies(): Array<Extension> {\n    return [new ListItemExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}(\\d+)\\.\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        (match) => ({ start: +match[1] }),\n        (match, node) =>\n          node.childCount + (node.attrs[\"start\"] as number) === +match[1],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Shift-Mod-9\": wrapInList(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"ordered_list\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { spread: { default: false }, start: { default: 1 } },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): { spread: boolean; start: number } {\n            const start = (dom as HTMLElement).getAttribute(\"start\");\n            return {\n              spread:\n                (dom as HTMLElement).getAttribute(\"data-spread\") === \"true\",\n              start: start !== null ? parseInt(start, 10) : 1,\n            };\n          },\n          tag: \"ol\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\n          \"ol\",\n          {\n            \"data-spread\": node.attrs[\"spread\"] as boolean,\n            start: node.attrs[\"start\"] as number,\n          },\n          0,\n        ];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<ListContent>,\n  ): Array<List> {\n    const spread = node.attrs[\"spread\"] as boolean;\n    return [\n      {\n        children: convertedChildren.map((child) => {\n          child.spread = spread;\n          return child;\n        }),\n        ordered: true,\n        spread,\n        start: node.attrs[\"start\"] as number,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"list\" {\n    return \"list\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: List,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        spread: node.spread,\n        start: node.start ?? 1,\n      },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() && (node as List).ordered === true\n    );\n  }\n}\n","import type { Root, RootContent } from \"mdast\";\nimport type {\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class RootExtension extends NodeExtension<Root> {\n  public override proseMirrorNodeName(): string {\n    return \"doc\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return { content: \"block+\" };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<RootContent>,\n  ): Array<Root> {\n    return [{ children: convertedChildren, type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"root\" {\n    return \"root\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Root,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { List, ListContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { wrapInList } from \"prosemirror-schema-list\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ListItemExtension } from \"./ListItemExtension\";\n\n/**\n * @public\n */\nexport class UnorderedListExtension extends NodeExtension<List> {\n  public override dependencies(): Array<Extension> {\n    return [new ListItemExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}([-+*])\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Shift-Mod-8\": wrapInList(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"bullet_list\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { spread: { default: false } },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): { spread: boolean } {\n            return {\n              spread:\n                (dom as HTMLElement).getAttribute(\"data-spread\") === \"true\",\n            };\n          },\n          tag: \"ul\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\"ul\", { \"data-spread\": node.attrs[\"spread\"] as boolean }, 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<ListContent>,\n  ): Array<List> {\n    const spread = node.attrs[\"spread\"] as boolean;\n    return [\n      {\n        children: convertedChildren.map((child) => {\n          child.spread = spread;\n          return child;\n        }),\n        ordered: false,\n        spread,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"list\" {\n    return \"list\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: List,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        spread: node.spread,\n      },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() && (node as List).ordered !== true\n    );\n  }\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { Extension } from \"prosemirror-unified\";\nimport remarkParse from \"remark-parse\";\nimport remarkStringify from \"remark-stringify\";\n\nimport { BlockquoteExtension } from \"./syntax-extensions/BlockquoteExtension\";\nimport { BoldExtension } from \"./syntax-extensions/BoldExtension\";\nimport { BreakExtension } from \"./syntax-extensions/BreakExtension\";\nimport { CodeBlockExtension } from \"./syntax-extensions/CodeBlockExtension\";\nimport { DefinitionExtension } from \"./syntax-extensions/DefinitionExtension\";\nimport { HeadingExtension } from \"./syntax-extensions/HeadingExtension\";\nimport { HorizontalRuleExtension } from \"./syntax-extensions/HorizontalRuleExtension\";\nimport { ImageExtension } from \"./syntax-extensions/ImageExtension\";\nimport { ImageReferenceExtension } from \"./syntax-extensions/ImageReferenceExtension\";\nimport { InlineCodeExtension } from \"./syntax-extensions/InlineCodeExtension\";\nimport { ItalicExtension } from \"./syntax-extensions/ItalicExtension\";\nimport { LinkExtension } from \"./syntax-extensions/LinkExtension\";\nimport { LinkReferenceExtension } from \"./syntax-extensions/LinkReferenceExtension\";\nimport { ListItemExtension } from \"./syntax-extensions/ListItemExtension\";\nimport { OrderedListExtension } from \"./syntax-extensions/OrderedListExtension\";\nimport { ParagraphExtension } from \"./syntax-extensions/ParagraphExtension\";\nimport { RootExtension } from \"./syntax-extensions/RootExtension\";\nimport { TextExtension } from \"./syntax-extensions/TextExtension\";\nimport { UnorderedListExtension } from \"./syntax-extensions/UnorderedListExtension\";\n\n/**\n * @public\n */\nexport class MarkdownExtension extends Extension {\n  public override dependencies(): Array<Extension> {\n    return [\n      // ParagraphExtension needs to be first so that it is the default block.\n      new ParagraphExtension(),\n      new BlockquoteExtension(),\n      new BoldExtension(),\n      new BreakExtension(),\n      new CodeBlockExtension(),\n      new DefinitionExtension(),\n      new HeadingExtension(),\n      new HorizontalRuleExtension(),\n      new ImageExtension(),\n      new ImageReferenceExtension(),\n      new InlineCodeExtension(),\n      new ItalicExtension(),\n      new LinkExtension(),\n      new LinkReferenceExtension(),\n      new ListItemExtension(),\n      new OrderedListExtension(),\n      new RootExtension(),\n      new TextExtension(),\n      new UnorderedListExtension(),\n    ];\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(remarkParse).use(remarkStringify, {\n      fences: true,\n      listItemIndent: \"one\",\n      resourceLink: true,\n      rule: \"-\",\n    }) as unknown as Processor<\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      string\n    >;\n  }\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodes parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodes children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isnt a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`)  whole match\n *   * `...capture` (`Array<string>`)  matches from regex capture groups\n *   * `match` (`RegExpMatchObject`)  info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * or when `false`, do not replace at all\n *   * or when `string`, replace with a text node of that value\n *   * or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasnt a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n","/**\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\nimport {ccount} from 'ccount'\nimport {ok as assert} from 'devlop'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '@',\n        before: '[+\\\\-.\\\\w]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: '.',\n        before: '[Ww]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: ':',\n        before: '[ps]',\n        after: '\\\\/',\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'link')\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Array<PhrasingContent> | Link | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    // If its an email, the previous character should not be a slash.\n    (!email || code !== 47)\n  )\n}\n","/**\n * @import {Code, ConstructRecord, Event, Extension, Previous, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nconst wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n};\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nconst trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n};\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n};\nconst wwwAutolink = {\n  name: 'wwwAutolink',\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nconst protocolAutolink = {\n  name: 'protocolAutolink',\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n};\nconst emailAutolink = {\n  name: 'emailAutolink',\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n\n/** @type {ConstructRecord} */\nconst text = {};\n\n/**\n * Create an extension for `micromark` to support GitHub autolink literal\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   autolink literal syntax.\n */\nexport function gfmAutolinkLiteral() {\n  return {\n    text\n  };\n}\n\n/** @type {Code} */\nlet code = 48;\n\n// Add alphanumerics.\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, protocolAutolink];\ntext[104] = [emailAutolink, protocolAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink];\n\n// To do: perform email autolink literals on events, afterwards.\n// Thats where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this;\n  /** @type {boolean | undefined} */\n  let dot;\n  /** @type {boolean} */\n  let data;\n  return start;\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n    if (code === 64) {\n      effects.consume(code);\n      return emailDomain;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === 46) {\n      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {\n      data = true;\n      effects.consume(code);\n      return emailDomain;\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally wed truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isnt trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code);\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code);\n    dot = true;\n    return emailDomain;\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this;\n  return wwwStart;\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (code !== 87 && code !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww');\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this;\n  let buffer = '';\n  let seen = false;\n  return protocolStart;\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if ((code === 72 || code === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n      effects.enter('literalAutolink');\n      effects.enter('literalAutolinkHttp');\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    if (code === 58) {\n      const protocol = buffer.toLowerCase();\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code);\n        return protocolSlashesInside;\n      }\n    }\n    return nok(code);\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === 47) {\n      effects.consume(code);\n      if (seen) {\n        return afterProtocol;\n      }\n      seen = true;\n      return protocolSlashesInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === null || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0;\n  return wwwPrefixInside;\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === 87 || code === 119) && size < 3) {\n      size++;\n      effects.consume(code);\n      return wwwPrefixInside;\n    }\n    if (code === 46 && size === 3) {\n      effects.consume(code);\n      return wwwPrefixAfter;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === null ? nok(code) : ok(code);\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment;\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment;\n  /** @type {boolean | undefined} */\n  let seen;\n  return domainInside;\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === 46 || code === 95) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code);\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {\n      return domainAfter(code);\n    }\n    seen = true;\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === 95) {\n      underscoreInLastSegment = true;\n    }\n    // Otherwise, its a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment;\n      underscoreInLastSegment = undefined;\n    }\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: thats GH says a dot is needed, but its not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code);\n    }\n    return ok(code);\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0;\n  let sizeClose = 0;\n  return pathInside;\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === 40) {\n      sizeOpen++;\n      effects.consume(code);\n      return pathInside;\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we dont check for a trail.\n    if (code === 41 && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code);\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {\n      return effects.check(trail, ok, pathAtPunctuation)(code);\n    }\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === 41) {\n      sizeClose++;\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail;\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {\n      effects.consume(code);\n      return trail;\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === 38) {\n      effects.consume(code);\n      return trailCharacterReferenceStart;\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === 93) {\n      effects.consume(code);\n      return trailBracketAfter;\n    }\n    if (\n    // `<` is an end.\n    code === 60 ||\n    // So is whitespace.\n    code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * >  **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (code === null || code === 40 || code === 91 || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return trail(code);\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceStart(code) {\n    // When non-alpha, its not a trail.\n    return asciiAlpha(code) ? trailCharacterReferenceInside(code) : nok(code);\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === 59) {\n      effects.consume(code);\n      return trail;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return trailCharacterReferenceInside;\n    }\n\n    // Its not a trail.\n    return nok(code);\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start;\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code);\n    return after;\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code);\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || markdownLineEndingOrSpace(code);\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code);\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash inside atext.\n  // The reference code is a bit weird, but thats what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === 47 || gfmAtext(code));\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n  while (index--) {\n    const token = events[index][1];\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    }\n\n    // If weve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n  if (events.length > 0 && !result) {\n    // Mark the last token as walked into w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n  return result;\n}","import type { Extension as FromMarkdownExtension } from \"mdast-util-from-markdown\";\nimport type { Options as ToMarkdownExtension } from \"mdast-util-to-markdown\";\nimport type { Extension as MicromarkExtension } from \"micromark-util-types\";\nimport type { Processor } from \"unified\";\n\nexport function buildUnifiedExtension(\n  micromarkExtensions: Array<MicromarkExtension>,\n  fromMarkdownExtensions: Array<FromMarkdownExtension>,\n  toMarkdownExtensions: Array<ToMarkdownExtension>,\n): () => void {\n  return function (this: Processor) {\n    // eslint-disable-next-line no-invalid-this -- this provided by unified\n    const data = this.data();\n\n    data.micromarkExtensions ??= [];\n    data.fromMarkdownExtensions ??= [];\n    data.toMarkdownExtensions ??= [];\n\n    data.micromarkExtensions.push(...micromarkExtensions);\n    data.fromMarkdownExtensions.push(...fromMarkdownExtensions);\n    data.toMarkdownExtensions.push(...toMarkdownExtensions);\n  };\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown,\n} from \"mdast-util-gfm-autolink-literal\";\nimport { gfmAutolinkLiteral } from \"micromark-extension-gfm-autolink-literal\";\nimport { Extension } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\n/**\n * @public\n */\nexport class ExtendedAutolinkExtension extends Extension {\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmAutolinkLiteral()],\n        [gfmAutolinkLiteralFromMarkdown()],\n        [gfmAutolinkLiteralToMarkdown()],\n      ),\n    );\n  }\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: ['delete'],\n    enter: {strikethrough: enterStrikethrough},\n    exit: {strikethrough: exitStrikethrough}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '~',\n        inConstruct: 'phrasing',\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: {delete: handleDelete}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  const exit = state.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {undefined}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if theres only a couple (10k) items.\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, its fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, its fine.\n      list.splice(...parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * >  **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {Array<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @import {Options} from 'micromark-extension-gfm-strikethrough'\n * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {};\n  let single = options_.singleTilde;\n  const tokenizer = {\n    name: 'strikethrough',\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  };\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1;\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index;\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&\n          // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            };\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];\n            const insideSpan = context.parser.constructs.insideSpan.null;\n            if (insideSpan) {\n              // Between.\n              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan, events.slice(open + 1, index), context));\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = \"data\";\n      }\n    }\n    return events;\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      if (previous === 126 && events[events.length - 1][1].type !== \"characterEscape\") {\n        return nok(code);\n      }\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous);\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = classifyCharacter(code);\n      token._open = !after || after === 2 && Boolean(before);\n      token._close = !before || before === 2 && Boolean(after);\n      return ok(code);\n    }\n  }\n}","import type { Delete, Emphasis, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown,\n} from \"mdast-util-gfm-strikethrough\";\nimport { gfmStrikethrough } from \"micromark-extension-gfm-strikethrough\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\n/**\n * @public\n */\nexport class StrikethroughExtension extends MarkExtension<Delete> {\n  public override processConvertedUnistNode(\n    convertedNode: Emphasis | Text,\n  ): Delete {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /~([^\\s](?:.*[^\\s~])?)~([^~])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /~~([^\\s](?:.*[^\\s])?)~~([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"strikethrough\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"s\" },\n        { tag: \"del\" },\n        {\n          getAttrs: (value) =>\n            /(^|[\\s])line-through([\\s]|$)/u.test(value) && null,\n          style: \"text-decoration\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"s\"];\n      },\n    };\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmStrikethrough()],\n        [gfmStrikethroughFromMarkdown()],\n        [gfmStrikethroughToMarkdown()],\n      ),\n    );\n  }\n\n  public override unistNodeName(): \"delete\" {\n    return \"delete\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Delete,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @typedef {import('../types.js').ConstructName} ConstructName\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we cant put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If theres no info\n      !node.lang &&\n      // And theres a non-whitespace character\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnt start or end in a blank\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If theres no url, or\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot form depending on the\n// previous or next character of sequences.\n// Theres no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when its released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').State} State\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Exit} Exit\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If theres an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If theres a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * >  **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return fn.call(state, node, info)\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot form depending on the\n// previous or next character of sequences.\n// Theres no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @typedef {import('../types.js').Options} Options\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `` represents a tab (plus how much it expands) and `` represents a\n * single space.\n *\n * ```markdown\n * \n * \n * \n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nconst tasklistCheck = {\n  name: 'tasklistCheck',\n  tokenize: tokenizeTasklistCheck\n};\n\n/**\n * Create an HTML extension for `micromark` to support GFM task list items\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM task list items when serializing to HTML.\n */\nexport function gfmTaskListItem() {\n  return {\n    text: {\n      [91]: tasklistCheck\n    }\n  };\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this;\n  return open;\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n    // Exit if theres stuff before.\n    self.previous !== null ||\n    // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n    return nok(code);\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return after;\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code);\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok)(code);\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, \"whitespace\");\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means theres content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code);\n  }\n}","import type { BlockContent, DefinitionContent, ListItem } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command, EditorState } from \"prosemirror-state\";\nimport type {\n  EditorView,\n  NodeView,\n  NodeViewConstructor,\n} from \"prosemirror-view\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown,\n} from \"mdast-util-gfm-task-list-item\";\nimport { gfmTaskListItem } from \"micromark-extension-gfm-task-list-item\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\nclass TaskListItemView implements NodeView {\n  public readonly contentDOM: HTMLElement;\n  public readonly dom: HTMLElement;\n\n  public constructor(\n    node: ProseMirrorNode,\n    view: EditorView,\n    getPos: () => number | undefined,\n  ) {\n    const checkbox = document.createElement(\"input\");\n    checkbox.setAttribute(\"type\", \"checkbox\");\n    checkbox.setAttribute(\"style\", \"cursor: pointer;\");\n    if (node.attrs[\"checked\"] === true) {\n      checkbox.setAttribute(\"checked\", \"checked\");\n    }\n    checkbox.addEventListener(\"click\", (e) => {\n      const pos = getPos();\n      if (pos === undefined) {\n        return;\n      }\n      e.preventDefault();\n      view.dispatch(\n        view.state.tr.setNodeAttribute(\n          pos,\n          \"checked\",\n          !(node.attrs[\"checked\"] as boolean),\n        ),\n      );\n    });\n\n    const checkboxContainer = document.createElement(\"span\");\n    checkboxContainer.setAttribute(\"contenteditable\", \"false\");\n    checkboxContainer.setAttribute(\"style\", \"position: absolute; left: 5px;\");\n    checkboxContainer.appendChild(checkbox);\n\n    this.contentDOM = document.createElement(\"span\");\n    this.contentDOM.setAttribute(\"style\", \"position: relative; left: 30px;\");\n\n    this.dom = document.createElement(\"li\");\n    this.dom.setAttribute(\n      \"style\",\n      \"list-style-type: none; margin-left: -30px;\",\n    );\n    this.dom.appendChild(checkboxContainer);\n    this.dom.appendChild(this.contentDOM);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inherited from the NodeView interface\n  public stopEvent(): boolean {\n    return true;\n  }\n}\n\n/**\n * @public\n */\nexport class TaskListItemExtension extends NodeExtension<ListItem> {\n  private static isAtStart(\n    state: EditorState,\n    view: EditorView | undefined,\n  ): boolean {\n    if (!state.selection.empty) {\n      return false;\n    }\n    if (view !== undefined) {\n      return view.endOfTextblock(\"backward\", state);\n    }\n    return state.selection.$anchor.parentOffset > 0;\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new InputRule(/^\\[([x\\s]?)\\][\\s\\S]$/u, (state, match, start) => {\n        const wrappingNode = state.doc.resolve(start).node(-1);\n        if (wrappingNode.type.name !== \"regular_list_item\") {\n          return null;\n        }\n        return state.tr.replaceRangeWith(\n          start - 2,\n          start + wrappingNode.nodeSize,\n          proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(\n            { checked: match[1] === \"x\" },\n            wrappingNode.content.cut(3 + match[1].length),\n          ),\n        );\n      }),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      Backspace: (state, dispatch, view): boolean => {\n        if (!TaskListItemExtension.isAtStart(state, view)) {\n          return false;\n        }\n        const taskListItemNode = state.selection.$anchor.node(-1);\n        if (taskListItemNode.type.name !== \"task_list_item\") {\n          return false;\n        }\n        if (dispatch === undefined) {\n          return true;\n        }\n        dispatch(\n          state.tr.replaceRangeWith(\n            state.selection.$from.before() - 2,\n            state.selection.$from.before() + taskListItemNode.nodeSize,\n            proseMirrorSchema.nodes[\"regular_list_item\"].create(\n              {},\n              taskListItemNode.content,\n            ),\n          ),\n        );\n        return true;\n      },\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"task_list_item\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { checked: { default: false } },\n      content: \"paragraph block*\",\n      defining: true,\n      group: \"list_item\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): false | { checked: boolean } {\n            const checkbox = (dom as HTMLElement).firstChild;\n            if (!(checkbox instanceof HTMLInputElement)) {\n              return false;\n            }\n            return { checked: checkbox.checked };\n          },\n          tag: \"li\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\n          \"li\",\n          { style: \"list-style-type: none;, margin-left: -30px;\" },\n          [\n            \"span\",\n            {\n              contenteditable: \"false\",\n              style: \"position: absolute; left: 5px;\",\n            },\n            [\n              \"input\",\n              {\n                checked: (node.attrs[\"checked\"] as boolean)\n                  ? \"checked\"\n                  : undefined,\n                disabled: \"disabled\",\n                type: \"checkbox\",\n              },\n            ],\n          ],\n          [\"span\", { style: \"position: relative; left: 30px\" }, 0],\n        ];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<ListItem> {\n    return [\n      {\n        checked: node.attrs[\"checked\"] as boolean,\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override proseMirrorNodeView(): NodeViewConstructor | null {\n    return (node, view, getPos) => new TaskListItemView(node, view, getPos);\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmTaskListItem()],\n        [gfmTaskListItemFromMarkdown()],\n        [gfmTaskListItemToMarkdown()],\n      ),\n    );\n  }\n\n  public override unistNodeName(): \"listItem\" {\n    return \"listItem\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: ListItem,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      { checked: node.checked },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() &&\n      \"checked\" in node &&\n      typeof node.checked === \"boolean\"\n    );\n  }\n}\n","import { Extension } from \"prosemirror-unified\";\n\nimport { MarkdownExtension } from \"./MarkdownExtension\";\nimport { ExtendedAutolinkExtension } from \"./syntax-extensions/ExtendedAutolinkExtension\";\nimport { StrikethroughExtension } from \"./syntax-extensions/StrikethroughExtension\";\nimport { TaskListItemExtension } from \"./syntax-extensions/TaskListItemExtension\";\n\n/**\n * @public\n */\nexport class GFMExtension extends Extension {\n  public override dependencies(): Array<Extension> {\n    return [\n      new MarkdownExtension(),\n      new ExtendedAutolinkExtension(),\n      new StrikethroughExtension(),\n      new TaskListItemExtension(),\n    ];\n  }\n}\n","export { GFMExtension } from \"./GFMExtension\";\nexport { MarkdownExtension } from \"./MarkdownExtension\";\nexport { BlockquoteExtension } from \"./syntax-extensions/BlockquoteExtension\";\nexport { BoldExtension } from \"./syntax-extensions/BoldExtension\";\nexport { BreakExtension } from \"./syntax-extensions/BreakExtension\";\nexport { CodeBlockExtension } from \"./syntax-extensions/CodeBlockExtension\";\nexport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./syntax-extensions/DefinitionExtension\";\nexport { ExtendedAutolinkExtension } from \"./syntax-extensions/ExtendedAutolinkExtension\";\nexport { HeadingExtension } from \"./syntax-extensions/HeadingExtension\";\nexport { HorizontalRuleExtension } from \"./syntax-extensions/HorizontalRuleExtension\";\nexport { ImageExtension } from \"./syntax-extensions/ImageExtension\";\nexport {\n  ImageReferenceExtension,\n  type ImageReferenceExtensionContext,\n} from \"./syntax-extensions/ImageReferenceExtension\";\nexport { InlineCodeExtension } from \"./syntax-extensions/InlineCodeExtension\";\nexport { ItalicExtension } from \"./syntax-extensions/ItalicExtension\";\nexport { LinkExtension } from \"./syntax-extensions/LinkExtension\";\nexport {\n  LinkReferenceExtension,\n  type LinkReferenceExtensionContext,\n} from \"./syntax-extensions/LinkReferenceExtension\";\nexport { ListItemExtension } from \"./syntax-extensions/ListItemExtension\";\nexport { OrderedListExtension } from \"./syntax-extensions/OrderedListExtension\";\nexport { ParagraphExtension } from \"./syntax-extensions/ParagraphExtension\";\nexport { RootExtension } from \"./syntax-extensions/RootExtension\";\nexport { StrikethroughExtension } from \"./syntax-extensions/StrikethroughExtension\";\nexport { TaskListItemExtension } from \"./syntax-extensions/TaskListItemExtension\";\nexport { TextExtension } from \"./syntax-extensions/TextExtension\";\nexport { UnorderedListExtension } from \"./syntax-extensions/UnorderedListExtension\";\n"],"names":[],"sourceRoot":""}
\ No newline at end of file
+{"version":3,"file":"prosemirror-remark.js","sources":["../src/syntax-extensions/BlockquoteExtension.ts","../src/syntax-extensions/BoldExtension.ts","../src/syntax-extensions/BreakExtension.ts","../src/syntax-extensions/TextExtension.ts","../src/syntax-extensions/CodeBlockExtension.ts","../src/syntax-extensions/DefinitionExtension.ts","../src/syntax-extensions/ParagraphExtension.ts","../src/syntax-extensions/HeadingExtension.ts","../src/syntax-extensions/HorizontalRuleExtension.ts","../src/syntax-extensions/ImageExtension.ts","../src/syntax-extensions/ImageReferenceExtension.ts","../src/syntax-extensions/InlineCodeExtension.ts","../src/syntax-extensions/ItalicExtension.ts","../src/syntax-extensions/LinkExtension.ts","../src/syntax-extensions/LinkReferenceExtension.ts","../src/syntax-extensions/ListItemExtension.ts","../src/syntax-extensions/OrderedListExtension.ts","../src/syntax-extensions/RootExtension.ts","../src/syntax-extensions/UnorderedListExtension.ts","../src/MarkdownExtension.ts","../node_modules/ccount/index.js","../node_modules/devlop/lib/default.js","../node_modules/micromark-util-character/index.js","../node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/color.js","../node_modules/unist-util-visit-parents/lib/index.js","../node_modules/mdast-util-find-and-replace/lib/index.js","../node_modules/mdast-util-gfm-autolink-literal/lib/index.js","../node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","../src/utils/buildUnifiedExtension.ts","../src/syntax-extensions/ExtendedAutolinkExtension.ts","../node_modules/mdast-util-gfm-strikethrough/lib/index.js","../node_modules/micromark-util-chunked/index.js","../node_modules/micromark-util-classify-character/index.js","../node_modules/micromark-util-resolve-all/index.js","../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","../src/syntax-extensions/StrikethroughExtension.ts","../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/handle/break.js","../node_modules/longest-streak/index.js","../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../node_modules/mdast-util-to-markdown/lib/handle/code.js","../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js","../node_modules/mdast-util-to-markdown/lib/util/encode-info.js","../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../node_modules/unist-util-visit/lib/index.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../node_modules/mdast-util-to-markdown/lib/handle/html.js","../node_modules/mdast-util-to-markdown/lib/handle/image.js","../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../node_modules/mdast-util-to-markdown/lib/handle/link.js","../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../node_modules/mdast-util-to-markdown/lib/handle/list.js","../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../node_modules/mdast-util-phrasing/lib/index.js","../node_modules/mdast-util-to-markdown/lib/handle/root.js","../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../node_modules/mdast-util-to-markdown/lib/handle/text.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../node_modules/mdast-util-to-markdown/lib/handle/index.js","../node_modules/mdast-util-gfm-task-list-item/lib/index.js","../node_modules/micromark-factory-space/index.js","../node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","../src/syntax-extensions/TaskListItemExtension.ts","../src/GFMExtension.ts"],"sourcesContent":["import type { BlockContent, Blockquote, DefinitionContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { wrapIn } from \"prosemirror-commands\";\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BlockquoteExtension extends NodeExtension<Blockquote> {\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}>\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Mod->\": wrapIn(proseMirrorSchema.nodes[this.proseMirrorNodeName()]),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"blockquote\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{ tag: \"blockquote\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"blockquote\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<Blockquote> {\n    return [\n      {\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"blockquote\" {\n    return \"blockquote\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Blockquote,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Emphasis, Strong, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BoldExtension extends MarkExtension<Strong> {\n  public override processConvertedUnistNode(\n    convertedNode: Emphasis | Text,\n  ): Strong {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /\\*\\*([^\\s](?:.*[^\\s])?)\\*\\*([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /__([^\\s](?:.*[^\\s])?)__([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Mod-b\": toggleMark(markType),\n      \"Mod-B\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"strong\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"b\" },\n        { tag: \"strong\" },\n        {\n          getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/u.test(value) && null,\n          style: \"font-weight\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"strong\", 0];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"strong\" {\n    return \"strong\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Strong,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","import type { Break } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { chainCommands, exitCode } from \"prosemirror-commands\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class BreakExtension extends NodeExtension<Break> {\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const command = chainCommands(exitCode, (state, dispatch) => {\n      if (dispatch) {\n        dispatch(\n          state.tr\n            .replaceSelectionWith(\n              proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(),\n            )\n            .scrollIntoView(),\n        );\n      }\n      return true;\n    });\n\n    const isMac =\n      typeof navigator !== \"undefined\"\n        ? /Mac|iP(hone|[oa]d)/u.test(navigator.platform) // eslint-disable-line @typescript-eslint/no-deprecated -- In the tested systems, it will be defined\n        : false;\n\n    return {\n      \"Mod-Enter\": command,\n      \"Shift-Enter\": command,\n      ...(isMac && { \"Ctrl-Enter\": command }),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"hard_break\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"inline\",\n      inline: true,\n      parseDOM: [{ tag: \"br\" }],\n      selectable: false,\n      toDOM(): DOMOutputSpec {\n        return [\"br\"];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<Break> {\n    return [{ type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"break\" {\n    return \"break\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Break,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Text } from \"mdast\";\nimport type {\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class TextExtension extends NodeExtension<Text> {\n  public override proseMirrorNodeName(): string {\n    return \"text\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"inline\",\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n  ): Array<Text> {\n    return [{ type: this.unistNodeName(), value: node.text ?? \"\" }];\n  }\n\n  public override unistNodeName(): \"text\" {\n    return \"text\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Text,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return [proseMirrorSchema.text(node.value)];\n  }\n}\n","import type { Code, Text } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { setBlockType } from \"prosemirror-commands\";\nimport { type InputRule, textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  type Command,\n  type EditorState,\n  Selection,\n  type Transaction,\n} from \"prosemirror-state\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { TextExtension } from \"./TextExtension\";\n\n/**\n * @public\n */\nexport class CodeBlockExtension extends NodeExtension<Code> {\n  private static liftOutOfCodeBlock() {\n    return (\n      state: EditorState,\n      dispatch?: (tr: Transaction) => void,\n    ): boolean => {\n      const { $from, $to } = state.selection;\n      if (\n        // Mustn't be a complex selection\n        !$from.sameParent($to) ||\n        // Must be in a code block\n        $from.parent.type.name !== \"code_block\" ||\n        // Must be at the end of the code block\n        $from.parentOffset !== $from.parent.content.size ||\n        // There must already be a preceding empty line\n        !$from.parent.textBetween(0, $from.parentOffset).endsWith(\"\\n\\n\")\n      ) {\n        return false;\n      }\n      if (dispatch) {\n        const tr = state.tr;\n        dispatch(\n          tr\n            // Delete the preceding empty line\n            .deleteRange($from.pos - 2, $from.pos)\n            // Insert empty paragraph\n            .insert(\n              $from.pos - 1,\n              tr.doc.type.schema.nodes[\"paragraph\"].create(),\n            )\n            // Put the cursor into the empty paragraph\n            .setSelection(Selection.near(tr.doc.resolve($from.pos), 1))\n            .scrollIntoView(),\n        );\n      }\n      return true;\n    };\n  }\n\n  public override dependencies(): Array<Extension> {\n    return [new TextExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      textblockTypeInputRule(\n        /^\\s{0,3}```(?! )[^\\n`]*\\n$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n      textblockTypeInputRule(\n        /^\\s{4}$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      Enter: CodeBlockExtension.liftOutOfCodeBlock(),\n      \"Shift-Mod-\\\\\": setBlockType(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"code_block\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      code: true,\n      content: \"text*\",\n      defining: true,\n      group: \"block\",\n      marks: \"\",\n      parseDOM: [{ preserveWhitespace: \"full\", tag: \"pre\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"pre\", [\"code\", 0]];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<Text>,\n  ): Array<Code> {\n    return [\n      {\n        type: this.unistNodeName(),\n        value: convertedChildren.map((child) => child.value).join(\"\"),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"code\" {\n    return \"code\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Code,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      [proseMirrorSchema.text(node.value)],\n    );\n  }\n}\n","import type { Definition } from \"mdast\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport interface DefinitionExtensionContext {\n  definitions: Record<\n    string,\n    { title: string | null | undefined; url: string }\n  >;\n}\n\n/**\n * @public\n */\nexport class DefinitionExtension extends NodeExtension<Definition> {\n  public override proseMirrorNodeName(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeSpec(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<Definition> {\n    return [];\n  }\n\n  public override unistNodeName(): \"definition\" {\n    return \"definition\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Definition,\n    _proseMirrorSchema: Schema<string, string>,\n    _convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    if (context.DefinitionExtension === undefined) {\n      context.DefinitionExtension = { definitions: {} };\n    }\n    context.DefinitionExtension.definitions[node.identifier] = {\n      title: node.title,\n      url: node.url,\n    };\n    return [];\n  }\n}\n","import type { Paragraph, PhrasingContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ParagraphExtension extends NodeExtension<Paragraph> {\n  public override proseMirrorNodeName(): string {\n    return \"paragraph\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{ tag: \"p\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"p\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<PhrasingContent>,\n  ): Array<Paragraph> {\n    return [{ children: convertedChildren, type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"paragraph\" {\n    return \"paragraph\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Paragraph,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Heading, PhrasingContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command, EditorState } from \"prosemirror-state\";\nimport type { EditorView } from \"prosemirror-view\";\n\nimport { setBlockType } from \"prosemirror-commands\";\nimport { type InputRule, textblockTypeInputRule } from \"prosemirror-inputrules\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ParagraphExtension } from \"./ParagraphExtension\";\nimport { TextExtension } from \"./TextExtension\";\n\n/**\n * @public\n */\nexport class HeadingExtension extends NodeExtension<Heading> {\n  private static headingLevelCommandBuilder(\n    proseMirrorSchema: Schema<string, string>,\n    levelUpdate: -1 | 1,\n    onlyAtStart: boolean,\n  ): Command {\n    return (state, dispatch, view) => {\n      if (onlyAtStart && !HeadingExtension.isAtStart(state, view)) {\n        return false;\n      }\n\n      const { $anchor } = state.selection;\n      const headingNode = $anchor.parent;\n      if (headingNode.type.name !== \"heading\") {\n        return false;\n      }\n\n      const newHeadingLevel =\n        (headingNode.attrs[\"level\"] as number) + levelUpdate;\n\n      if (newHeadingLevel < 0 || newHeadingLevel > 6) {\n        return false;\n      }\n      if (dispatch === undefined) {\n        return true;\n      }\n\n      const headingPosition = $anchor.before($anchor.depth);\n\n      if (newHeadingLevel > 0) {\n        dispatch(\n          state.tr.setNodeMarkup(headingPosition, undefined, {\n            level: newHeadingLevel,\n          }),\n        );\n      } else {\n        dispatch(\n          state.tr.setNodeMarkup(\n            headingPosition,\n            proseMirrorSchema.nodes[\"paragraph\"],\n          ),\n        );\n      }\n      return true;\n    };\n  }\n\n  private static isAtStart(\n    state: EditorState,\n    view: EditorView | undefined,\n  ): boolean {\n    if (!state.selection.empty) {\n      return false;\n    }\n    if (view !== undefined) {\n      return view.endOfTextblock(\"backward\", state);\n    }\n    return state.selection.$anchor.parentOffset > 0;\n  }\n\n  public override dependencies(): Array<Extension> {\n    return [new ParagraphExtension(), new TextExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      textblockTypeInputRule(\n        /^\\s{0,3}(#{1,6})\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        (match) => ({ level: match[1].length }),\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const keymap: Record<string, Command> = {\n      \"#\": HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        +1,\n        true,\n      ),\n      Backspace: HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        -1,\n        true,\n      ),\n      \"Shift-Tab\": HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        -1,\n        false,\n      ),\n      Tab: HeadingExtension.headingLevelCommandBuilder(\n        proseMirrorSchema,\n        +1,\n        false,\n      ),\n    };\n\n    for (let i = 1; i <= 6; i++) {\n      keymap[`Shift-Mod-${i.toString()}`] = setBlockType(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        { level: i },\n      );\n    }\n    return keymap;\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"heading\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { level: { default: 1 } },\n      content: \"text*\",\n      defining: true,\n      group: \"block\",\n      parseDOM: [\n        { attrs: { level: 1 }, tag: \"h1\" },\n        { attrs: { level: 2 }, tag: \"h2\" },\n        { attrs: { level: 3 }, tag: \"h3\" },\n        { attrs: { level: 4 }, tag: \"h4\" },\n        { attrs: { level: 5 }, tag: \"h5\" },\n        { attrs: { level: 6 }, tag: \"h6\" },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [`h${(node.attrs[\"level\"] as number).toString()}`, 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<PhrasingContent>,\n  ): Array<Heading> {\n    return [\n      {\n        children: convertedChildren,\n        depth: node.attrs[\"level\"] as 1 | 2 | 3 | 4 | 5 | 6,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"heading\" {\n    return \"heading\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Heading,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        level: node.depth,\n      },\n    );\n  }\n}\n","import type { ThematicBreak } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class HorizontalRuleExtension extends NodeExtension<ThematicBreak> {\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new InputRule(/^\\s{0,3}(?:\\*\\*\\*|---|___)\\n$/u, (state, _, start, end) =>\n        state.tr.replaceWith(\n          start,\n          end,\n          createProseMirrorNode(\n            this.proseMirrorNodeName(),\n            proseMirrorSchema,\n            [],\n          ),\n        ),\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Mod-_\": (state, dispatch): true => {\n        if (dispatch) {\n          dispatch(\n            state.tr\n              .replaceSelectionWith(\n                proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(),\n              )\n              .scrollIntoView(),\n          );\n        }\n        return true;\n      },\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"horizontal_rule\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      group: \"block\",\n      parseDOM: [{ tag: \"hr\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"div\", [\"hr\"]];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<ThematicBreak> {\n    return [\n      {\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"thematicBreak\" {\n    return \"thematicBreak\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: ThematicBreak,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { Image } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ParagraphExtension } from \"./ParagraphExtension\";\n\n/**\n * @public\n */\nexport class ImageExtension extends NodeExtension<Image> {\n  public override dependencies(): Array<Extension> {\n    return [new ParagraphExtension()];\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"image\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: {\n        alt: { default: null },\n        src: {},\n        title: { default: null },\n      },\n      draggable: true,\n      group: \"inline\",\n      inline: true,\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): {\n            alt: string | null;\n            src: string | null;\n            title: string | null;\n          } {\n            return {\n              alt: (dom as HTMLElement).getAttribute(\"alt\"),\n              src: (dom as HTMLElement).getAttribute(\"src\"),\n              title: (dom as HTMLElement).getAttribute(\"title\"),\n            };\n          },\n          tag: \"img[src]\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\"img\", node.attrs];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n  ): Array<Image> {\n    return [\n      {\n        type: this.unistNodeName(),\n        url: node.attrs[\"src\"] as string,\n        ...(node.attrs[\"alt\"] !== null && { alt: node.attrs[\"alt\"] as string }),\n        ...(node.attrs[\"title\"] !== null && {\n          title: node.attrs[\"title\"] as string,\n        }),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"image\" {\n    return \"image\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Image,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        alt: node.alt,\n        src: node.url,\n        title: node.title,\n      },\n    );\n  }\n}\n","import type { ImageReference } from \"mdast\";\nimport type { Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { type Extension, NodeExtension } from \"prosemirror-unified\";\n\nimport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./DefinitionExtension\";\nimport { ImageExtension } from \"./ImageExtension\";\n\n/**\n * @public\n */\nexport interface ImageReferenceExtensionContext {\n  proseMirrorNodes: Record<string, ProseMirrorNode>;\n}\n\n/**\n * @public\n */\nexport class ImageReferenceExtension extends NodeExtension<ImageReference> {\n  public override dependencies(): Array<Extension> {\n    return [new DefinitionExtension(), new ImageExtension()];\n  }\n\n  public override postUnistToProseMirrorHook(\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n      ImageReferenceExtension: ImageReferenceExtensionContext;\n    }>,\n  ): void {\n    if (\n      context.ImageReferenceExtension === undefined ||\n      context.DefinitionExtension === undefined\n    ) {\n      return;\n    }\n    for (const id in context.ImageReferenceExtension.proseMirrorNodes) {\n      if (!(id in context.DefinitionExtension.definitions)) {\n        continue;\n      }\n      const definition = context.DefinitionExtension.definitions[id];\n      const attrs = context.ImageReferenceExtension.proseMirrorNodes[id]\n        .attrs as Record<\n        string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Attrs can be any\n        any\n      >;\n      attrs[\"src\"] = definition.url;\n      if (definition.title !== undefined) {\n        attrs[\"title\"] = definition.title;\n      }\n    }\n  }\n\n  public override proseMirrorNodeName(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeSpec(): null {\n    return null;\n  }\n\n  public override proseMirrorNodeToUnistNodes(): Array<ImageReference> {\n    return [];\n  }\n\n  public override unistNodeName(): \"imageReference\" {\n    return \"imageReference\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: ImageReference,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      ImageReferenceExtension: ImageReferenceExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    const proseMirrorNode = proseMirrorSchema.nodes[\"image\"].createAndFill(\n      { alt: node.alt, src: \"\", title: node.label },\n      convertedChildren,\n    );\n    if (proseMirrorNode === null) {\n      return [];\n    }\n    if (context.ImageReferenceExtension === undefined) {\n      context.ImageReferenceExtension = { proseMirrorNodes: {} };\n    }\n    context.ImageReferenceExtension.proseMirrorNodes[node.identifier] =\n      proseMirrorNode;\n    return [proseMirrorNode];\n  }\n}\n","import type { InlineCode, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class InlineCodeExtension extends MarkExtension<InlineCode> {\n  public override processConvertedUnistNode(convertedNode: Text): InlineCode {\n    return { type: this.unistNodeName(), value: convertedNode.value };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /(?<!`)(?<b>`+)(?!`)(?<s> ?)(?<i>.*)\\k<s>(?<!`)\\k<b>(?<t>[^`])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Ctrl-`\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"code\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      inclusive: false,\n      parseDOM: [{ tag: \"code\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"code\", 0];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"inlineCode\" {\n    return \"inlineCode\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: InlineCode,\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<ProseMirrorNode> {\n    return [\n      proseMirrorSchema\n        .text(node.value)\n        .mark([proseMirrorSchema.marks[this.proseMirrorMarkName()].create()]),\n    ];\n  }\n}\n","import type { Emphasis, Strong, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\n\nimport { toggleMark } from \"prosemirror-commands\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ItalicExtension extends MarkExtension<Emphasis> {\n  public override processConvertedUnistNode(\n    convertedNode: Strong | Text,\n  ): Emphasis {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /(?<!\\*)\\*([^\\s*](?:.*[^\\s])?)\\*([^*])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /(?<!_)_([^\\s_](?:.*[^\\s])?)_([^_])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const markType = proseMirrorSchema.marks[this.proseMirrorMarkName()];\n    return {\n      \"Mod-i\": toggleMark(markType),\n      \"Mod-I\": toggleMark(markType),\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"em\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"i\" },\n        { tag: \"em\" },\n        {\n          getAttrs: (value) => value === \"italic\" && null,\n          style: \"font-style\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"em\", 0];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"emphasis\" {\n    return \"emphasis\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Emphasis,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","import type { Link, Text } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  Mark,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { MarkExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class LinkExtension extends MarkExtension<Link> {\n  public override processConvertedUnistNode(\n    convertedNode: Text,\n    originalMark: Mark,\n  ): Link {\n    return {\n      type: this.unistNodeName(),\n      url: originalMark.attrs[\"href\"] as string,\n      ...(originalMark.attrs[\"title\"] !== null && {\n        title: originalMark.attrs[\"title\"] as string,\n      }),\n      children: [convertedNode],\n    };\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"link\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      attrs: { href: {}, title: { default: null } },\n      inclusive: false,\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): {\n            href: string | null;\n            title: string | null;\n          } {\n            return {\n              href: (dom as HTMLElement).getAttribute(\"href\"),\n              title: (dom as HTMLElement).getAttribute(\"title\"),\n            };\n          },\n          tag: \"a[href]\",\n        },\n      ],\n      toDOM(node: Mark): DOMOutputSpec {\n        return [\"a\", node.attrs, 0];\n      },\n    };\n  }\n\n  public override unistNodeName(): \"link\" {\n    return \"link\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: Link,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create({\n            href: node.url,\n            title: node.title,\n          }),\n        ]),\n      ),\n    );\n  }\n}\n","import type { LinkReference } from \"mdast\";\nimport type { Mark, Node as ProseMirrorNode, Schema } from \"prosemirror-model\";\n\nimport { type Extension, MarkExtension } from \"prosemirror-unified\";\n\nimport {\n  DefinitionExtension,\n  type DefinitionExtensionContext,\n} from \"./DefinitionExtension\";\nimport { LinkExtension } from \"./LinkExtension\";\n\n/**\n * @public\n */\nexport interface LinkReferenceExtensionContext {\n  marks: Record<string, Mark>;\n}\n\n/**\n * @public\n */\nexport class LinkReferenceExtension extends MarkExtension<LinkReference> {\n  public override dependencies(): Array<Extension> {\n    return [new DefinitionExtension(), new LinkExtension()];\n  }\n\n  public override postUnistToProseMirrorHook(\n    context: Partial<{\n      DefinitionExtension: DefinitionExtensionContext;\n      LinkReferenceExtension: LinkReferenceExtensionContext;\n    }>,\n  ): void {\n    if (\n      context.LinkReferenceExtension === undefined ||\n      context.DefinitionExtension === undefined\n    ) {\n      return;\n    }\n    for (const id in context.LinkReferenceExtension.marks) {\n      if (!(id in context.DefinitionExtension.definitions)) {\n        continue;\n      }\n      const definition = context.DefinitionExtension.definitions[id];\n      const attrs = context.LinkReferenceExtension.marks[id].attrs as Record<\n        string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Attrs can be any\n        any\n      >;\n      attrs[\"href\"] = definition.url;\n      if (definition.title !== undefined) {\n        attrs[\"title\"] = definition.title;\n      }\n    }\n  }\n\n  public override processConvertedUnistNode(\n    convertedNode: LinkReference,\n  ): LinkReference {\n    return convertedNode;\n  }\n\n  public override proseMirrorMarkName(): null {\n    return null;\n  }\n\n  public override proseMirrorMarkSpec(): null {\n    return null;\n  }\n\n  public override unistNodeName(): \"linkReference\" {\n    return \"linkReference\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: LinkReference,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n    context: Partial<{\n      LinkReferenceExtension: LinkReferenceExtensionContext;\n    }>,\n  ): Array<ProseMirrorNode> {\n    const mark = proseMirrorSchema.marks[\"link\"].create({\n      href: null,\n      title: null,\n    });\n    if (context.LinkReferenceExtension === undefined) {\n      context.LinkReferenceExtension = { marks: {} };\n    }\n    context.LinkReferenceExtension.marks[node.identifier] = mark;\n    return convertedChildren.map((child) =>\n      child.mark(child.marks.concat([mark])),\n    );\n  }\n}\n","import type { BlockContent, DefinitionContent, ListItem } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  liftListItem,\n  sinkListItem,\n  splitListItem,\n} from \"prosemirror-schema-list\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class ListItemExtension extends NodeExtension<ListItem> {\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    const nodeType = proseMirrorSchema.nodes[this.proseMirrorNodeName()];\n    return {\n      Enter: splitListItem(nodeType),\n      \"Shift-Tab\": liftListItem(nodeType),\n      Tab: sinkListItem(nodeType),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"regular_list_item\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      content: \"paragraph block*\",\n      defining: true,\n      group: \"list_item\",\n      parseDOM: [{ tag: \"li\" }],\n      toDOM(): DOMOutputSpec {\n        return [\"li\", 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<ListItem> {\n    return [\n      {\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"listItem\" {\n    return \"listItem\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: ListItem,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() &&\n      (!(\"checked\" in node) || typeof node.checked !== \"boolean\")\n    );\n  }\n}\n","import type { List, ListContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { wrapInList } from \"prosemirror-schema-list\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ListItemExtension } from \"./ListItemExtension\";\n\n/**\n * @public\n */\nexport class OrderedListExtension extends NodeExtension<List> {\n  public override dependencies(): Array<Extension> {\n    return [new ListItemExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}(\\d+)\\.\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n        (match) => ({ start: +match[1] }),\n        (match, node) =>\n          node.childCount + (node.attrs[\"start\"] as number) === +match[1],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Shift-Mod-9\": wrapInList(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"ordered_list\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { spread: { default: false }, start: { default: 1 } },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): { spread: boolean; start: number } {\n            const start = (dom as HTMLElement).getAttribute(\"start\");\n            return {\n              spread:\n                (dom as HTMLElement).getAttribute(\"data-spread\") === \"true\",\n              start: start !== null ? parseInt(start, 10) : 1,\n            };\n          },\n          tag: \"ol\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\n          \"ol\",\n          {\n            \"data-spread\": node.attrs[\"spread\"] as boolean,\n            start: node.attrs[\"start\"] as number,\n          },\n          0,\n        ];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<ListContent>,\n  ): Array<List> {\n    const spread = node.attrs[\"spread\"] as boolean;\n    return [\n      {\n        children: convertedChildren.map((child) => {\n          child.spread = spread;\n          return child;\n        }),\n        ordered: true,\n        spread,\n        start: node.attrs[\"start\"] as number,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"list\" {\n    return \"list\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: List,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        spread: node.spread,\n        start: node.start ?? 1,\n      },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() && (node as List).ordered === true\n    );\n  }\n}\n","import type { Root, RootContent } from \"mdast\";\nimport type {\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\n\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\n/**\n * @public\n */\nexport class RootExtension extends NodeExtension<Root> {\n  public override proseMirrorNodeName(): string {\n    return \"doc\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return { content: \"block+\" };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    _node: ProseMirrorNode,\n    convertedChildren: Array<RootContent>,\n  ): Array<Root> {\n    return [{ children: convertedChildren, type: this.unistNodeName() }];\n  }\n\n  public override unistNodeName(): \"root\" {\n    return \"root\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Root,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n    );\n  }\n}\n","import type { List, ListContent } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command } from \"prosemirror-state\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { type InputRule, wrappingInputRule } from \"prosemirror-inputrules\";\nimport { wrapInList } from \"prosemirror-schema-list\";\nimport {\n  createProseMirrorNode,\n  type Extension,\n  NodeExtension,\n} from \"prosemirror-unified\";\n\nimport { ListItemExtension } from \"./ListItemExtension\";\n\n/**\n * @public\n */\nexport class UnorderedListExtension extends NodeExtension<List> {\n  public override dependencies(): Array<Extension> {\n    return [new ListItemExtension()];\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      wrappingInputRule(\n        /^\\s{0,3}([-+*])\\s$/u,\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      \"Shift-Mod-8\": wrapInList(\n        proseMirrorSchema.nodes[this.proseMirrorNodeName()],\n      ),\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"bullet_list\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { spread: { default: false } },\n      content: \"list_item+\",\n      group: \"block\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): { spread: boolean } {\n            return {\n              spread:\n                (dom as HTMLElement).getAttribute(\"data-spread\") === \"true\",\n            };\n          },\n          tag: \"ul\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\"ul\", { \"data-spread\": node.attrs[\"spread\"] as boolean }, 0];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<ListContent>,\n  ): Array<List> {\n    const spread = node.attrs[\"spread\"] as boolean;\n    return [\n      {\n        children: convertedChildren.map((child) => {\n          child.spread = spread;\n          return child;\n        }),\n        ordered: false,\n        spread,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override unistNodeName(): \"list\" {\n    return \"list\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: List,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      {\n        spread: node.spread,\n      },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() && (node as List).ordered !== true\n    );\n  }\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport { Extension } from \"prosemirror-unified\";\nimport remarkParse from \"remark-parse\";\nimport remarkStringify from \"remark-stringify\";\n\nimport { BlockquoteExtension } from \"./syntax-extensions/BlockquoteExtension\";\nimport { BoldExtension } from \"./syntax-extensions/BoldExtension\";\nimport { BreakExtension } from \"./syntax-extensions/BreakExtension\";\nimport { CodeBlockExtension } from \"./syntax-extensions/CodeBlockExtension\";\nimport { DefinitionExtension } from \"./syntax-extensions/DefinitionExtension\";\nimport { HeadingExtension } from \"./syntax-extensions/HeadingExtension\";\nimport { HorizontalRuleExtension } from \"./syntax-extensions/HorizontalRuleExtension\";\nimport { ImageExtension } from \"./syntax-extensions/ImageExtension\";\nimport { ImageReferenceExtension } from \"./syntax-extensions/ImageReferenceExtension\";\nimport { InlineCodeExtension } from \"./syntax-extensions/InlineCodeExtension\";\nimport { ItalicExtension } from \"./syntax-extensions/ItalicExtension\";\nimport { LinkExtension } from \"./syntax-extensions/LinkExtension\";\nimport { LinkReferenceExtension } from \"./syntax-extensions/LinkReferenceExtension\";\nimport { ListItemExtension } from \"./syntax-extensions/ListItemExtension\";\nimport { OrderedListExtension } from \"./syntax-extensions/OrderedListExtension\";\nimport { ParagraphExtension } from \"./syntax-extensions/ParagraphExtension\";\nimport { RootExtension } from \"./syntax-extensions/RootExtension\";\nimport { TextExtension } from \"./syntax-extensions/TextExtension\";\nimport { UnorderedListExtension } from \"./syntax-extensions/UnorderedListExtension\";\n\n/**\n * @public\n */\nexport class MarkdownExtension extends Extension {\n  public override dependencies(): Array<Extension> {\n    return [\n      // ParagraphExtension needs to be first so that it is the default block.\n      new ParagraphExtension(),\n      new BlockquoteExtension(),\n      new BoldExtension(),\n      new BreakExtension(),\n      new CodeBlockExtension(),\n      new DefinitionExtension(),\n      new HeadingExtension(),\n      new HorizontalRuleExtension(),\n      new ImageExtension(),\n      new ImageReferenceExtension(),\n      new InlineCodeExtension(),\n      new ItalicExtension(),\n      new LinkExtension(),\n      new LinkReferenceExtension(),\n      new ListItemExtension(),\n      new OrderedListExtension(),\n      new RootExtension(),\n      new TextExtension(),\n      new UnorderedListExtension(),\n    ];\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(remarkParse).use(remarkStringify, {\n      fences: true,\n      listItemIndent: \"one\",\n      resourceLink: true,\n      rule: \"-\",\n    }) as unknown as Processor<\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      UnistNode,\n      string\n    >;\n  }\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodes parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodes children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isnt a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`)  whole match\n *   * `...capture` (`Array<string>`)  matches from regex capture groups\n *   * `match` (`RegExpMatchObject`)  info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * or when `false`, do not replace at all\n *   * or when `string`, replace with a text node of that value\n *   * or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {import('unist-util-visit-parents').BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasnt a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n","/**\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\nimport {ccount} from 'ccount'\nimport {ok as assert} from 'devlop'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '@',\n        before: '[+\\\\-.\\\\w]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: '.',\n        before: '[Ww]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: ':',\n        before: '[ps]',\n        after: '\\\\/',\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'link')\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Array<PhrasingContent> | Link | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    // If its an email, the previous character should not be a slash.\n    (!email || code !== 47)\n  )\n}\n","/**\n * @import {Code, ConstructRecord, Event, Extension, Previous, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { asciiAlpha, asciiAlphanumeric, asciiControl, markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\nconst wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n};\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n};\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n};\nconst trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n};\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n};\nconst wwwAutolink = {\n  name: 'wwwAutolink',\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nconst protocolAutolink = {\n  name: 'protocolAutolink',\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n};\nconst emailAutolink = {\n  name: 'emailAutolink',\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\n\n/** @type {ConstructRecord} */\nconst text = {};\n\n/**\n * Create an extension for `micromark` to support GitHub autolink literal\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   autolink literal syntax.\n */\nexport function gfmAutolinkLiteral() {\n  return {\n    text\n  };\n}\n\n/** @type {Code} */\nlet code = 48;\n\n// Add alphanumerics.\nwhile (code < 123) {\n  text[code] = emailAutolink;\n  code++;\n  if (code === 58) code = 65;else if (code === 91) code = 97;\n}\ntext[43] = emailAutolink;\ntext[45] = emailAutolink;\ntext[46] = emailAutolink;\ntext[95] = emailAutolink;\ntext[72] = [emailAutolink, protocolAutolink];\ntext[104] = [emailAutolink, protocolAutolink];\ntext[87] = [emailAutolink, wwwAutolink];\ntext[119] = [emailAutolink, wwwAutolink];\n\n// To do: perform email autolink literals on events, afterwards.\n// Thats where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this;\n  /** @type {boolean | undefined} */\n  let dot;\n  /** @type {boolean} */\n  let data;\n  return start;\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (!gfmAtext(code) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkEmail');\n    return atext(code);\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code);\n      return atext;\n    }\n    if (code === 64) {\n      effects.consume(code);\n      return emailDomain;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === 46) {\n      return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code);\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {\n      data = true;\n      effects.consume(code);\n      return emailDomain;\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally wed truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isnt trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code);\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code);\n    dot = true;\n    return emailDomain;\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail');\n      effects.exit('literalAutolink');\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this;\n  return wwwStart;\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (code !== 87 && code !== 119 || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code);\n    }\n    effects.enter('literalAutolink');\n    effects.enter('literalAutolinkWww');\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code);\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this;\n  let buffer = '';\n  let seen = false;\n  return protocolStart;\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if ((code === 72 || code === 104) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n      effects.enter('literalAutolink');\n      effects.enter('literalAutolinkHttp');\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code);\n      effects.consume(code);\n      return protocolPrefixInside;\n    }\n    if (code === 58) {\n      const protocol = buffer.toLowerCase();\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code);\n        return protocolSlashesInside;\n      }\n    }\n    return nok(code);\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === 47) {\n      effects.consume(code);\n      if (seen) {\n        return afterProtocol;\n      }\n      seen = true;\n      return protocolSlashesInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === null || asciiControl(code) || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || unicodePunctuation(code) ? nok(code) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code);\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp');\n    effects.exit('literalAutolink');\n    return ok(code);\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0;\n  return wwwPrefixInside;\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === 87 || code === 119) && size < 3) {\n      size++;\n      effects.consume(code);\n      return wwwPrefixInside;\n    }\n    if (code === 46 && size === 3) {\n      effects.consume(code);\n      return wwwPrefixAfter;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === null ? nok(code) : ok(code);\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment;\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment;\n  /** @type {boolean | undefined} */\n  let seen;\n  return domainInside;\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === 46 || code === 95) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code);\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code) || code !== 45 && unicodePunctuation(code)) {\n      return domainAfter(code);\n    }\n    seen = true;\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === 95) {\n      underscoreInLastSegment = true;\n    }\n    // Otherwise, its a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment;\n      underscoreInLastSegment = undefined;\n    }\n    effects.consume(code);\n    return domainInside;\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: thats GH says a dot is needed, but its not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code);\n    }\n    return ok(code);\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0;\n  let sizeClose = 0;\n  return pathInside;\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === 40) {\n      sizeOpen++;\n      effects.consume(code);\n      return pathInside;\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we dont check for a trail.\n    if (code === 41 && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code);\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (code === 33 || code === 34 || code === 38 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 60 || code === 63 || code === 93 || code === 95 || code === 126) {\n      return effects.check(trail, ok, pathAtPunctuation)(code);\n    }\n    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === 41) {\n      sizeClose++;\n    }\n    effects.consume(code);\n    return pathInside;\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail;\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (code === 33 || code === 34 || code === 39 || code === 41 || code === 42 || code === 44 || code === 46 || code === 58 || code === 59 || code === 63 || code === 95 || code === 126) {\n      effects.consume(code);\n      return trail;\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === 38) {\n      effects.consume(code);\n      return trailCharacterReferenceStart;\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === 93) {\n      effects.consume(code);\n      return trailBracketAfter;\n    }\n    if (\n    // `<` is an end.\n    code === 60 ||\n    // So is whitespace.\n    code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * >  **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (code === null || code === 40 || code === 91 || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n      return ok(code);\n    }\n    return trail(code);\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceStart(code) {\n    // When non-alpha, its not a trail.\n    return asciiAlpha(code) ? trailCharacterReferenceInside(code) : nok(code);\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === 59) {\n      effects.consume(code);\n      return trail;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return trailCharacterReferenceInside;\n    }\n\n    // Its not a trail.\n    return nok(code);\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start;\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code);\n    return after;\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code);\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return code === null || code === 40 || code === 42 || code === 95 || code === 91 || code === 93 || code === 126 || markdownLineEndingOrSpace(code);\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code);\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash inside atext.\n  // The reference code is a bit weird, but thats what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === 47 || gfmAtext(code));\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return code === 43 || code === 45 || code === 46 || code === 95 || asciiAlphanumeric(code);\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n  while (index--) {\n    const token = events[index][1];\n    if ((token.type === 'labelLink' || token.type === 'labelImage') && !token._balanced) {\n      result = true;\n      break;\n    }\n\n    // If weve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n  if (events.length > 0 && !result) {\n    // Mark the last token as walked into w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n  return result;\n}","import type { Extension as FromMarkdownExtension } from \"mdast-util-from-markdown\";\nimport type { Options as ToMarkdownExtension } from \"mdast-util-to-markdown\";\nimport type { Extension as MicromarkExtension } from \"micromark-util-types\";\nimport type { Processor } from \"unified\";\n\nexport function buildUnifiedExtension(\n  micromarkExtensions: Array<MicromarkExtension>,\n  fromMarkdownExtensions: Array<FromMarkdownExtension>,\n  toMarkdownExtensions: Array<ToMarkdownExtension>,\n): () => void {\n  return function (this: Processor) {\n    // eslint-disable-next-line no-invalid-this -- this provided by unified\n    const data = this.data();\n\n    data.micromarkExtensions ??= [];\n    data.fromMarkdownExtensions ??= [];\n    data.toMarkdownExtensions ??= [];\n\n    data.micromarkExtensions.push(...micromarkExtensions);\n    data.fromMarkdownExtensions.push(...fromMarkdownExtensions);\n    data.toMarkdownExtensions.push(...toMarkdownExtensions);\n  };\n}\n","import type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown,\n} from \"mdast-util-gfm-autolink-literal\";\nimport { gfmAutolinkLiteral } from \"micromark-extension-gfm-autolink-literal\";\nimport { Extension } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\n/**\n * @public\n */\nexport class ExtendedAutolinkExtension extends Extension {\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmAutolinkLiteral()],\n        [gfmAutolinkLiteralFromMarkdown()],\n        [gfmAutolinkLiteralToMarkdown()],\n      ),\n    );\n  }\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: ['delete'],\n    enter: {strikethrough: enterStrikethrough},\n    exit: {strikethrough: exitStrikethrough}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '~',\n        inConstruct: 'phrasing',\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: {delete: handleDelete}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  const exit = state.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {undefined}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if theres only a couple (10k) items.\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, its fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, its fine.\n      list.splice(...parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * >  **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {Array<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @import {Options} from 'micromark-extension-gfm-strikethrough'\n * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {};\n  let single = options_.singleTilde;\n  const tokenizer = {\n    name: 'strikethrough',\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  };\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1;\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index;\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&\n          // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            };\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]];\n            const insideSpan = context.parser.constructs.insideSpan.null;\n            if (insideSpan) {\n              // Between.\n              splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan, events.slice(open + 1, index), context));\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = \"data\";\n      }\n    }\n    return events;\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      if (previous === 126 && events[events.length - 1][1].type !== \"characterEscape\") {\n        return nok(code);\n      }\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous);\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = classifyCharacter(code);\n      token._open = !after || after === 2 && Boolean(before);\n      token._close = !before || before === 2 && Boolean(after);\n      return ok(code);\n    }\n  }\n}","import type { Delete, Emphasis, Text } from \"mdast\";\nimport type { InputRule } from \"prosemirror-inputrules\";\nimport type {\n  DOMOutputSpec,\n  MarkSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown,\n} from \"mdast-util-gfm-strikethrough\";\nimport { gfmStrikethrough } from \"micromark-extension-gfm-strikethrough\";\nimport { MarkExtension, MarkInputRule } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\n/**\n * @public\n */\nexport class StrikethroughExtension extends MarkExtension<Delete> {\n  public override processConvertedUnistNode(\n    convertedNode: Emphasis | Text,\n  ): Delete {\n    return { children: [convertedNode], type: this.unistNodeName() };\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new MarkInputRule(\n        /~([^\\s](?:.*[^\\s~])?)~([^~])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n      new MarkInputRule(\n        /~~([^\\s](?:.*[^\\s])?)~~([\\s\\S])$/u,\n        proseMirrorSchema.marks[this.proseMirrorMarkName()],\n      ),\n    ];\n  }\n\n  public override proseMirrorMarkName(): string {\n    return \"strikethrough\";\n  }\n\n  public override proseMirrorMarkSpec(): MarkSpec {\n    return {\n      parseDOM: [\n        { tag: \"s\" },\n        { tag: \"del\" },\n        {\n          getAttrs: (value) =>\n            /(^|[\\s])line-through([\\s]|$)/u.test(value) && null,\n          style: \"text-decoration\",\n        },\n      ],\n      toDOM(): DOMOutputSpec {\n        return [\"s\", 0];\n      },\n    };\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmStrikethrough()],\n        [gfmStrikethroughFromMarkdown()],\n        [gfmStrikethroughToMarkdown()],\n      ),\n    );\n  }\n\n  public override unistNodeName(): \"delete\" {\n    return \"delete\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    _node: Delete,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return convertedChildren.map((child) =>\n      child.mark(\n        child.marks.concat([\n          proseMirrorSchema.marks[this.proseMirrorMarkName()].create(),\n        ]),\n      ),\n    );\n  }\n}\n","/**\n * @import {Blockquote, Parents} from 'mdast'\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @import {Break, Parents} from 'mdast'\n * @import {Info, State} from 'mdast-util-to-markdown'\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we cant put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Code} from 'mdast'\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If theres no info\n      !node.lang &&\n      // And theres a non-whitespace character\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnt start or end in a blank\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {Code, Parents} from 'mdast'\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Definition, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If theres no url, or\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Encode a code point as a character reference.\n *\n * @param {number} code\n *   Code point to encode.\n * @returns {string}\n *   Encoded character reference.\n */\nexport function encodeCharacterReference(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @import {EncodeSides} from '../types.js'\n */\n\nimport {classifyCharacter} from 'micromark-util-classify-character'\n\n/**\n * Check whether to encode (as a character reference) the characters\n * surrounding an attention run.\n *\n * Which characters are around an attention run influence whether it works or\n * not.\n *\n * See <https://github.com/orgs/syntax-tree/discussions/60> for more info.\n * See this markdown in a particular renderer to see what works:\n *\n * ```markdown\n * |                         | A (letter inside) | B (punctuation inside) | C (whitespace inside) | D (nothing inside) |\n * | ----------------------- | ----------------- | ---------------------- | --------------------- | ------------------ |\n * | 1 (letter outside)      | x*y*z             | x*.*z                  | x* *z                 | x**z               |\n * | 2 (punctuation outside) | .*y*.             | .*.*.                  | .* *.                 | .**.               |\n * | 3 (whitespace outside)  | x *y* z           | x *.* z                | x * * z               | x ** z             |\n * | 4 (nothing outside)     | *x*               | *.*                    | * *                   | **                 |\n * ```\n *\n * @param {number} outside\n *   Code point on the outer side of the run.\n * @param {number} inside\n *   Code point on the inner side of the run.\n * @param {'*' | '_'} marker\n *   Marker of the run.\n *   Underscores are handled more strictly (they form less often) than\n *   asterisks.\n * @returns {EncodeSides}\n *   Whether to encode characters.\n */\n// Important: punctuation must never be encoded.\n// Punctuation is solely used by markdown constructs.\n// And by encoding itself.\n// Encoding them will break constructs or double encode things.\nexport function encodeInfo(outside, inside, marker) {\n  const outsideKind = classifyCharacter(outside)\n  const insideKind = classifyCharacter(inside)\n\n  // Letter outside:\n  if (outsideKind === undefined) {\n    return insideKind === undefined\n      ? // Letter inside:\n        // we have to encode *both* letters for `_` as it is looser.\n        // it already forms for `*` (and GFMs `~`).\n        marker === '_'\n        ? {inside: true, outside: true}\n        : {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (letter, whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: encode outer (letter)\n          {inside: false, outside: true}\n  }\n\n  // Whitespace outside:\n  if (outsideKind === 1) {\n    return insideKind === undefined\n      ? // Letter inside: already forms.\n        {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: already forms.\n          {inside: false, outside: false}\n  }\n\n  // Punctuation outside:\n  return insideKind === undefined\n    ? // Letter inside: already forms.\n      {inside: false, outside: false}\n    : insideKind === 1\n      ? // Whitespace inside: encode inner (whitespace).\n        {inside: true, outside: false}\n      : // Punctuation inside: already forms.\n        {inside: false, outside: false}\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Emphasis, Parents} from 'mdast'\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nemphasis.peek = emphasisPeek\n\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when its released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Heading} from 'mdast'\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Heading, Parents} from 'mdast'\n */\n\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @import {Html} from 'mdast'\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Image, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {ImageReference, Parents} from 'mdast'\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Link} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Link, Parents} from 'mdast'\n * @import {Exit} from '../types.js'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {LinkReference, Parents} from 'mdast'\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {List, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If theres an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If theres a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {ListItem, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Paragraph, Parents} from 'mdast'\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * >  **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Root} from 'mdast'\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n\n  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return container.call(state, node, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Strong} from 'mdast'\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nstrong.peek = strongPeek\n\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker + marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker + marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Text} from 'mdast'\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Parents, ThematicBreak} from 'mdast'\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `` represents a tab (plus how much it expands) and `` represents a\n * single space.\n *\n * ```markdown\n * \n * \n * \n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns {State}\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nconst tasklistCheck = {\n  name: 'tasklistCheck',\n  tokenize: tokenizeTasklistCheck\n};\n\n/**\n * Create an HTML extension for `micromark` to support GFM task list items\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM task list items when serializing to HTML.\n */\nexport function gfmTaskListItem() {\n  return {\n    text: {\n      [91]: tasklistCheck\n    }\n  };\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this;\n  return open;\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n    // Exit if theres stuff before.\n    self.previous !== null ||\n    // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n    return nok(code);\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return after;\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code);\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok)(code);\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, \"whitespace\");\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means theres content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code);\n  }\n}","import type { BlockContent, DefinitionContent, ListItem } from \"mdast\";\nimport type {\n  DOMOutputSpec,\n  NodeSpec,\n  Node as ProseMirrorNode,\n  Schema,\n} from \"prosemirror-model\";\nimport type { Command, EditorState } from \"prosemirror-state\";\nimport type {\n  EditorView,\n  NodeView,\n  NodeViewConstructor,\n} from \"prosemirror-view\";\nimport type { Processor } from \"unified\";\nimport type { Node as UnistNode } from \"unist\";\n\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown,\n} from \"mdast-util-gfm-task-list-item\";\nimport { gfmTaskListItem } from \"micromark-extension-gfm-task-list-item\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { createProseMirrorNode, NodeExtension } from \"prosemirror-unified\";\n\nimport { buildUnifiedExtension } from \"../utils/buildUnifiedExtension\";\n\nclass TaskListItemView implements NodeView {\n  public readonly contentDOM: HTMLElement;\n  public readonly dom: HTMLElement;\n\n  public constructor(\n    node: ProseMirrorNode,\n    view: EditorView,\n    getPos: () => number | undefined,\n  ) {\n    const checkbox = document.createElement(\"input\");\n    checkbox.setAttribute(\"type\", \"checkbox\");\n    checkbox.setAttribute(\"style\", \"cursor: pointer;\");\n    if (node.attrs[\"checked\"] === true) {\n      checkbox.setAttribute(\"checked\", \"checked\");\n    }\n    checkbox.addEventListener(\"click\", (e) => {\n      const pos = getPos();\n      if (pos === undefined) {\n        return;\n      }\n      e.preventDefault();\n      view.dispatch(\n        view.state.tr.setNodeAttribute(\n          pos,\n          \"checked\",\n          !(node.attrs[\"checked\"] as boolean),\n        ),\n      );\n    });\n\n    const checkboxContainer = document.createElement(\"span\");\n    checkboxContainer.setAttribute(\"contenteditable\", \"false\");\n    checkboxContainer.setAttribute(\"style\", \"position: absolute; left: 5px;\");\n    checkboxContainer.appendChild(checkbox);\n\n    this.contentDOM = document.createElement(\"span\");\n    this.contentDOM.setAttribute(\"style\", \"position: relative; left: 30px;\");\n\n    this.dom = document.createElement(\"li\");\n    this.dom.setAttribute(\n      \"style\",\n      \"list-style-type: none; margin-left: -30px;\",\n    );\n    this.dom.appendChild(checkboxContainer);\n    this.dom.appendChild(this.contentDOM);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this -- Inherited from the NodeView interface\n  public stopEvent(): boolean {\n    return true;\n  }\n}\n\n/**\n * @public\n */\nexport class TaskListItemExtension extends NodeExtension<ListItem> {\n  private static isAtStart(\n    state: EditorState,\n    view: EditorView | undefined,\n  ): boolean {\n    if (!state.selection.empty) {\n      return false;\n    }\n    if (view !== undefined) {\n      return view.endOfTextblock(\"backward\", state);\n    }\n    return state.selection.$anchor.parentOffset > 0;\n  }\n\n  public override proseMirrorInputRules(\n    proseMirrorSchema: Schema<string, string>,\n  ): Array<InputRule> {\n    return [\n      new InputRule(/^\\[([x\\s]?)\\][\\s\\S]$/u, (state, match, start) => {\n        const wrappingNode = state.doc.resolve(start).node(-1);\n        if (wrappingNode.type.name !== \"regular_list_item\") {\n          return null;\n        }\n        return state.tr.replaceRangeWith(\n          start - 2,\n          start + wrappingNode.nodeSize,\n          proseMirrorSchema.nodes[this.proseMirrorNodeName()].create(\n            { checked: match[1] === \"x\" },\n            wrappingNode.content.cut(3 + match[1].length),\n          ),\n        );\n      }),\n    ];\n  }\n\n  public override proseMirrorKeymap(\n    proseMirrorSchema: Schema<string, string>,\n  ): Record<string, Command> {\n    return {\n      Backspace: (state, dispatch, view): boolean => {\n        if (!TaskListItemExtension.isAtStart(state, view)) {\n          return false;\n        }\n        const taskListItemNode = state.selection.$anchor.node(-1);\n        if (taskListItemNode.type.name !== \"task_list_item\") {\n          return false;\n        }\n        if (dispatch === undefined) {\n          return true;\n        }\n        dispatch(\n          state.tr.replaceRangeWith(\n            state.selection.$from.before() - 2,\n            state.selection.$from.before() + taskListItemNode.nodeSize,\n            proseMirrorSchema.nodes[\"regular_list_item\"].create(\n              {},\n              taskListItemNode.content,\n            ),\n          ),\n        );\n        return true;\n      },\n    };\n  }\n\n  public override proseMirrorNodeName(): string {\n    return \"task_list_item\";\n  }\n\n  public override proseMirrorNodeSpec(): NodeSpec {\n    return {\n      attrs: { checked: { default: false } },\n      content: \"paragraph block*\",\n      defining: true,\n      group: \"list_item\",\n      parseDOM: [\n        {\n          getAttrs(dom: Node | string): false | { checked: boolean } {\n            const checkbox = (dom as HTMLElement).firstChild;\n            if (!(checkbox instanceof HTMLInputElement)) {\n              return false;\n            }\n            return { checked: checkbox.checked };\n          },\n          tag: \"li\",\n        },\n      ],\n      toDOM(node: ProseMirrorNode): DOMOutputSpec {\n        return [\n          \"li\",\n          { style: \"list-style-type: none;, margin-left: -30px;\" },\n          [\n            \"span\",\n            {\n              contenteditable: \"false\",\n              style: \"position: absolute; left: 5px;\",\n            },\n            [\n              \"input\",\n              {\n                checked: (node.attrs[\"checked\"] as boolean)\n                  ? \"checked\"\n                  : undefined,\n                disabled: \"disabled\",\n                type: \"checkbox\",\n              },\n            ],\n          ],\n          [\"span\", { style: \"position: relative; left: 30px\" }, 0],\n        ];\n      },\n    };\n  }\n\n  public override proseMirrorNodeToUnistNodes(\n    node: ProseMirrorNode,\n    convertedChildren: Array<BlockContent | DefinitionContent>,\n  ): Array<ListItem> {\n    return [\n      {\n        checked: node.attrs[\"checked\"] as boolean,\n        children: convertedChildren,\n        type: this.unistNodeName(),\n      },\n    ];\n  }\n\n  public override proseMirrorNodeView(): NodeViewConstructor | null {\n    return (node, view, getPos) => new TaskListItemView(node, view, getPos);\n  }\n\n  public override unifiedInitializationHook(\n    processor: Processor<UnistNode, UnistNode, UnistNode, UnistNode, string>,\n  ): Processor<UnistNode, UnistNode, UnistNode, UnistNode, string> {\n    return processor.use(\n      buildUnifiedExtension(\n        [gfmTaskListItem()],\n        [gfmTaskListItemFromMarkdown()],\n        [gfmTaskListItemToMarkdown()],\n      ),\n    );\n  }\n\n  public override unistNodeName(): \"listItem\" {\n    return \"listItem\";\n  }\n\n  public override unistNodeToProseMirrorNodes(\n    node: ListItem,\n    proseMirrorSchema: Schema<string, string>,\n    convertedChildren: Array<ProseMirrorNode>,\n  ): Array<ProseMirrorNode> {\n    return createProseMirrorNode(\n      this.proseMirrorNodeName(),\n      proseMirrorSchema,\n      convertedChildren,\n      { checked: node.checked },\n    );\n  }\n\n  public override unistToProseMirrorTest(node: UnistNode): boolean {\n    return (\n      node.type === this.unistNodeName() &&\n      \"checked\" in node &&\n      typeof node.checked === \"boolean\"\n    );\n  }\n}\n","import { Extension } from \"prosemirror-unified\";\n\nimport { MarkdownExtension } from \"./MarkdownExtension\";\nimport { ExtendedAutolinkExtension } from \"./syntax-extensions/ExtendedAutolinkExtension\";\nimport { StrikethroughExtension } from \"./syntax-extensions/StrikethroughExtension\";\nimport { TaskListItemExtension } from \"./syntax-extensions/TaskListItemExtension\";\n\n/**\n * @public\n */\nexport class GFMExtension extends Extension {\n  public override dependencies(): Array<Extension> {\n    return [\n      new MarkdownExtension(),\n      new ExtendedAutolinkExtension(),\n      new StrikethroughExtension(),\n      new TaskListItemExtension(),\n    ];\n  }\n}\n"],"names":["node","definition","ok","code","index","all","visit","list","escape","assert","domain","path","trail","text","previous","map","exit","value","subexit","defaultHandlers"],"mappings":"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","x_google_ignoreList":[20,21,22,23,24,25,26,27,28,29,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80]}
